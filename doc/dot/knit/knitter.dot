digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 89"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-46"]


section_1 -> { header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8}

header_2 [label="1 : Knitter Module"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

section_6 [label="section: 14-25"]

section_7 [label="section: 26-46"]

section_8 [label="section: 47-89"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Knitter Module"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   A knitter is the actor responsible for knitting together our source
 code.  They are defined by language, which is to say that the unit of 
 action is not a runtime or document, knitters will expand to be 
 responsible for an arbitrary number of these.
"]
prose_4 -> { raw_12 literal_13 raw_14 literal_15 raw_16 literal_17 raw_18}
{rank=same; raw_12 literal_13 raw_14 literal_15 raw_16 literal_17 raw_18}

raw_12 [label="raw"]

literal_13 [label="literal"]

raw_14 [label="raw"]

literal_15 [label="literal"]

raw_16 [label="raw"]

literal_17 [label="literal"]

raw_18 [label="raw"]


raw_12 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 The bootstrap knitter does what a knitter will do by default:  go through
 "]
literal_13 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".../org/*/*.gm"]
raw_14 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and generate "]
literal_15 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".../src/*.*.lang"]
raw_16 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" for all code blocks in
 "]
literal_17 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#lang"]
raw_18 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
prose_5 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 It must do so through an interface which will let it grow up.
"]
section_6 -> { header_28 prose_29 prose_30 prose_31}
{rank=same; header_28 prose_29 prose_30 prose_31}

header_28 [label="3 : An Aside"]

prose_29 [label="prose"]

prose_30 [label="prose"]

prose_31 [label="prose"]


header_28 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" *** An Aside"]
prose_29 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   This is the last verb in Grimoire which needs to be written in pure
 Lua.  Huzzah! Typing -- all the time is tiresome and I didn't want to
 patch Sublime just for that.
"]
prose_30 -> { raw_35 literal_36 raw_37}
{rank=same; raw_35 literal_36 raw_37}

raw_35 [label="raw"]

literal_36 [label="literal"]

raw_37 [label="raw"]


raw_35 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 I do intend to design a 
 [syntax highligher for Sublime](etc/Grimoire.sublime_syntax), just
 a simple minimum-viable that will make editing the Lua inside "]
literal_36 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="grym"]
raw_37 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" 
 pleasant while I polish up femto. 
"]
prose_31 -> { raw_41}
{rank=same; raw_41}

raw_41 [label="raw"]


raw_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 "]
section_7 -> { header_43 prose_44 prose_45 codeblock_46}
{rank=same; header_43 prose_44 prose_45 codeblock_46}

header_43 [label="2 : Design"]

prose_44 [label="prose"]

prose_45 [label="prose"]

codeblock_46 [label="code block 41-45"]


header_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" ** Design"]
prose_44 -> { raw_48 literal_49 raw_50}
{rank=same; raw_48 literal_49 raw_50}

raw_48 [label="raw"]

literal_49 [label="literal"]

raw_50 [label="raw"]


raw_48 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   "]
literal_49 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="grym invert"]
raw_50 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is an isolated module.  It's a shim; if better tools 
 succeeds, we'll stop using it within the Arc in fairly short order.
"]
prose_45 -> { raw_54 literal_55 raw_56 literal_57 raw_58}
{rank=same; raw_54 literal_55 raw_56 literal_57 raw_58}

raw_54 [label="raw"]

literal_55 [label="literal"]

raw_56 [label="raw"]

literal_57 [label="literal"]

raw_58 [label="raw"]


raw_54 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 "]
literal_55 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="grym knit"]
raw_56 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", by contrast, is part of the core system.  Software tends
 to stick around, and a Grimoire is a language-as-in-human-language
 sort of project.  An advantage we intend to offer over Org is a 
 nice Unix-flavor toolkit for munging flat files from your choice of
 editor.
 
 "]
literal_57 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="knit"]
raw_58 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" methods receive a parsed document, not a string.  The Knitter 
 modules generates language specific transformers for various Nodes,
 and the Knit module uses them when called for. 
"]
codeblock_46 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local u = require \"lib/util\"

local K, k = u.inherit()"]
section_8 -> { header_65 prose_66 prose_67 prose_68 codeblock_69}
{rank=same; header_65 prose_66 prose_67 prose_68 codeblock_69}

header_65 [label="2 : knit method"]

prose_66 [label="prose"]

prose_67 [label="prose"]

prose_68 [label="prose"]

codeblock_69 [label="code block 61-88"]


header_65 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" ** knit method"]
prose_66 -> { raw_71}
{rank=same; raw_71}

raw_71 [label="raw"]


raw_71 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   This is where it all comes together.
"]
prose_67 -> { raw_73}
{rank=same; raw_73}

raw_73 [label="raw"]


raw_73 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 We're still bootstrapping.  The only language is lua, we don't know 
 what hashtags are yet, and we go in simple linear order.
 
 - knitter :  the knit module. That is, K, rather than a given k in 
              K.langs.
 - doc     :  a Doc.
"]
prose_68 -> { raw_75}
{rank=same; raw_75}

raw_75 [label="raw"]


raw_75 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - #return : the knit file as a string.

"]
codeblock_69 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function K.knit(knitter, doc)
    local phrase = \"\"
    local linum = 0
    for cb in doc:select(\"codeblock\") do
        cb:check()
        -- Pad code with blank lines to line up errors
        local pad_count = cb.line_first - linum

        local pad = (\"\\n\"):rep(pad_count)
        -- cat codeblock value
        phrase = phrase .. pad .. cb.val 

        -- update linum
        linum = cb.line_last - 1
    end

    return phrase
end

local function new(Knitter, lang)
    local knitter = setmetatable({}, K)
    knitter.lang = lang or \"lua\"
    return knitter
end

return u.export(k, new)"]

}
