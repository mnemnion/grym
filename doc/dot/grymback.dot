digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 103"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-11"]


section_1 -> { header_2 block_3 block_4 section_5}
{rank=same; header_2 block_3 block_4 section_5}

header_2 [label="1 : Grymback"]

block_3 [label="block 1-6"]

block_4 [label="block 7-11"]

section_5 [label="section: 12-103"]


block_3 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This is a standalone program to restore grym in the event that a knit
results in an unusable grym module.
"]
block_4 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The plan: A =.grym= file in the root directory will contain any
knit-modified files from the last pass.  =grym= itself will read and write
to the .grym file, maintaining a data structure in the meantime; this will
be in Lua-native table format, at first, eventually Clu(den).
"]
section_5 -> { header_8 block_9 block_10 block_11}
{rank=same; header_8 block_9 block_10 block_11}

header_8 [label="3 : includes"]

block_9 [label="block 12-13"]

block_10 [label="block 14-42"]

block_11 [label="block 43-103"]


block_9 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_10 -> { codeblock_13}
{rank=same; codeblock_13}

codeblock_13 [label="code block 14-39"]


codeblock_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"lib/status\"
local u = require \"lib/util\"
local a = require \"lib/ansi\"
s.chatty = true

local epeg = require \"peg/epeg\"

local pl_file = require \"pl.file\"
local pl_dir = require \"pl.dir\"
local pl_path = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local makepath = pl_dir.makepath
local extension = pl_path.extension
local dirname = pl_path.dirname
local basename = pl_path.basename
local read = pl_file.read
local write = pl_file.write
local delete = pl_file.delete
local isdir = pl_path.isdir

local walk = \"walk\""]
block_10 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is pure script, we shouldn't even need a function
"]
block_11 -> { codeblock_16}
{rank=same; codeblock_16}

codeblock_16 [label="code block 43-72"]


codeblock_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local pwd = \"\"

if (arg) then
  pwd = table.remove(arg, 1)
else
  os.exit(\"Must be called with a root codex directory\", 1)
end

io.write(\"pwd: \" .. pwd .. \"\\n\")

local grymback_rc = read(pwd .. \"/.grymback\")
if not grymback_rc then
  s:chat(\"No contents in grymback.  No action taken.\")
  os.exit()
else
  for _,v in ipairs(epeg.split(grymback_rc, \"\\n\")) do
    if v ~= \"\" then
      s:chat(\"Reverting \" .. a.cyan(grymback_rc))
      s:chat(\"Reading \" .. a.green(pwd .. \"/tmp\" .. v))
      local new_tmp = read(pwd .. \"/tmp\" .. v)
      if new_tmp then
        s:chat(\"  - writing\")
        write(v, read(pwd .. \"/tmp\" .. v))
      end
    end
  end
end"]
block_11 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="





























"]
section_5 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes

#!lua
local L = require \"lpeg\"

local s = require \"lib/status\"
local u = require \"lib/util\"
local a = require \"lib/ansi\"
s.chatty = true

local epeg = require \"peg/epeg\"

local pl_file = require \"pl.file\"
local pl_dir = require \"pl.dir\"
local pl_path = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local makepath = pl_dir.makepath
local extension = pl_path.extension
local dirname = pl_path.dirname
local basename = pl_path.basename
local read = pl_file.read
local write = pl_file.write
local delete = pl_file.delete
local isdir = pl_path.isdir

local walk = \"walk\"
#/lua

This is pure script, we shouldn't even need a function

#!lua

local pwd = \"\"

if (arg) then
	pwd = table.remove(arg, 1)
else
	os.exit(\"Must be called with a root codex directory\", 1)
end

io.write(\"pwd: \" .. pwd .. \"\\n\")

local grymback_rc = read(pwd .. \"/.grymback\")
if not grymback_rc then
	s:chat(\"No contents in grymback.  No action taken.\")
	os.exit()
else
	for _,v in ipairs(epeg.split(grymback_rc, \"\\n\")) do
		if v ~= \"\" then
			s:chat(\"Reverting \" .. a.cyan(grymback_rc))
			s:chat(\"Reading \" .. a.green(pwd .. \"/tmp\" .. v))
			local new_tmp = read(pwd .. \"/tmp\" .. v)
			if new_tmp then
				s:chat(\"  - writing\")
				write(v, read(pwd .. \"/tmp\" .. v))
			end
		end
	end
end
#/lua





























"]
section_1 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grymback


  This is a standalone program to restore grym in the event that a knit
results in an unusable grym module.

The plan: A =.grym= file in the root directory will contain any
knit-modified files from the last pass.  =grym= itself will read and write
to the .grym file, maintaining a data structure in the meantime; this will
be in Lua-native table format, at first, eventually Clu(den).

*"]

}
