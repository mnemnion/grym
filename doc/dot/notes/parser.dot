digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 155"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-124"]


section_1 -> { header_2 block_3 section_4 section_5 section_6 section_7}
{rank=same; header_2 block_3 section_4 section_5 section_6 section_7}

header_2 [label="1 : A Grimoire Parser"]

block_3 [label="block 1-124"]

section_4 [label="section: 3-42"]

section_5 [label="section: 43-96"]

section_6 [label="section: 102-124"]

section_7 [label="section: 125-146"]


block_3 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_4 -> { header_9 block_10 block_11 block_12 block_13 block_14 block_15 block_16 block_17 block_18 block_19 block_20}
{rank=same; header_9 block_10 block_11 block_12 block_13 block_14 block_15 block_16 block_17 block_18 block_19 block_20}

header_9 [label="2 : Introduction"]

block_10 [label="block 3-8"]

block_11 [label="block 9-13"]

block_12 [label="block 14-16"]

block_13 [label="block 17-20"]

block_14 [label="block 21-22"]

block_15 [label="block 23-24"]

block_16 [label="block 25-28"]

block_17 [label="block 29-30"]

block_18 [label="block 31-33"]

block_19 [label="block 34-38"]

block_20 [label="block 39-42"]


block_10 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I need a literate toolchain stat. I'm unwilling to write it on
Org. I've been having fun with Org but it has to go, and now is
the time.
"]
block_11 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I need this before the quipu, to write the quipu, so we're going to
forget reusable parsers and general editing structures and everything
like that for now. We're going to cut a fast parser out of Lua and
start hooking it up to things. 
"]
block_12 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Pegylator is proving remarkably useful for software I thought I was
abandoning in mid-February. But I digress.
"]
block_13 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="There are important structural similarities between Grimoire and Markdown.
More with Org, of course, but Markdown is more widely parsed. Let's see
what we can find.
"]
block_14 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Oh hey this looks good:
"]
block_15 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="[[https://github.com/jgm/lunamark][lunamark]]
"]
block_16 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In fact this looks very good. If I can trick lunamark into thinking that
Grimoire is just some exotic flavor of Markdown I can get a *lot* of 
functionality for free.
"]
block_17 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Let's try this approach and see if it flies. 
"]
block_18 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Hmm. There's a lot of useful code and approaches to lpeg to steal here.
But I'm just too well-equipped with my toolchain to want to switch horses.
"]
block_19 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The Node class is a little janky but not particularly broken and is shaping
up as my common AST format when in Lualand. If those get out of whack there will
be pain sooner or later. That's worth more than being able to use the lunamark
toolchain for export and the like. 
"]
block_20 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="At least for now. I'll try to hold on to some of the naming conventions and see
if maybe I can talk the author into adapting the module once we're the popular
kids. 
"]
section_4 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Introduction

I need a literate toolchain stat. I'm unwilling to write it on
Org. I've been having fun with Org but it has to go, and now is
the time.

I need this before the quipu, to write the quipu, so we're going to
forget reusable parsers and general editing structures and everything
like that for now. We're going to cut a fast parser out of Lua and
start hooking it up to things. 

Pegylator is proving remarkably useful for software I thought I was
abandoning in mid-February. But I digress.

There are important structural similarities between Grimoire and Markdown.
More with Org, of course, but Markdown is more widely parsed. Let's see
what we can find.

Oh hey this looks good:

[[https://github.com/jgm/lunamark][lunamark]]

In fact this looks very good. If I can trick lunamark into thinking that
Grimoire is just some exotic flavor of Markdown I can get a *lot* of 
functionality for free.

Let's try this approach and see if it flies. 

Hmm. There's a lot of useful code and approaches to lpeg to steal here.
But I'm just too well-equipped with my toolchain to want to switch horses.

The Node class is a little janky but not particularly broken and is shaping
up as my common AST format when in Lualand. If those get out of whack there will
be pain sooner or later. That's worth more than being able to use the lunamark
toolchain for export and the like. 

At least for now. I'll try to hold on to some of the naming conventions and see
if maybe I can talk the author into adapting the module once we're the popular
kids. 

*"]
section_5 -> { header_33 block_34 section_35 section_36 section_37 section_38 section_39}
{rank=same; header_33 block_34 section_35 section_36 section_37 section_38 section_39}

header_33 [label="2 : Structure"]

block_34 [label="block 43-96"]

section_35 [label="section: 47-61"]

section_36 [label="section: 62-67"]

section_37 [label="section: 81-91"]

section_38 [label="section: 92-96"]

section_39 [label="section: 97-101"]


block_34 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're going to do this in several passes. 
"]
section_35 -> { header_41 block_42 block_43 block_44 block_45}
{rank=same; header_41 block_42 block_43 block_44 block_45}

header_41 [label="3 : Chunking"]

block_42 [label="block 47-51"]

block_43 [label="block 52-55"]

block_44 [label="block 56-57"]

block_45 [label="block 58-61"]


block_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Our top-level of structure is determined by [[file:grimoire.org::*Header%20Lines][header lines]], which
cooperate to form the structure of a Grimoire document.
"]
block_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="While we're doing this, we'll chunk everything else into arrays
of lines, this will split into structure lines, blank lines,
and TBD. 
"]
block_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I believe we can get everything into blocks on this first pass.
"]
block_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="At this point, the data structure is still flat, but chunky, and
we have a separate vector of the header lines and their index
into the chunks. 
"]
section_35 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Chunking

Our top-level of structure is determined by [[file:grimoire.org::*Header%20Lines][header lines]], which
cooperate to form the structure of a Grimoire document.

While we're doing this, we'll chunk everything else into arrays
of lines, this will split into structure lines, blank lines,
and TBD. 

I believe we can get everything into blocks on this first pass.

At this point, the data structure is still flat, but chunky, and
we have a separate vector of the header lines and their index
into the chunks. 

*"]
section_36 -> { header_51 block_52 section_53}
{rank=same; header_51 block_52 section_53}

header_51 [label="3 : Ownership"]

block_52 [label="block 62-67"]

section_53 [label="section: 68-80"]


block_52 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We next determine basic ownership. This we do by counting all the stars 
in the header lines and building a tree accordingly. This is a 
recursive map of vectors containing chunks. 
"]
section_53 -> { header_55 block_56 block_57 block_58}
{rank=same; header_55 block_56 block_57 block_58}

header_55 [label="4 : Cling Rule"]

block_56 [label="block 68-73"]

block_57 [label="block 74-76"]

block_58 [label="block 77-80"]


block_56 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Various kinds of block have [[file:grimoire.org::*The%20Cling%20Rule][cling rules]] associated with them. How this
works is still somewhat opaque, no substitute for code in actually
working it out. 
"]
block_57 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We apply these rules, attaching tags to associated lists, tables and
code blocks, for example. 
"]
block_58 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I think the secret sauce of the cling rule is that it never matters if 
marks cling up or cling down, tags and names can come before, after, or
around the blocks they cling to. 
"]
section_53 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Cling Rule

Various kinds of block have [[file:grimoire.org::*The%20Cling%20Rule][cling rules]] associated with them. How this
works is still somewhat opaque, no substitute for code in actually
working it out. 

We apply these rules, attaching tags to associated lists, tables and
code blocks, for example. 

I think the secret sauce of the cling rule is that it never matters if 
marks cling up or cling down, tags and names can come before, after, or
around the blocks they cling to. 

*"]
section_36 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Ownership

We next determine basic ownership. This we do by counting all the stars 
in the header lines and building a tree accordingly. This is a 
recursive map of vectors containing chunks. 

*"]
section_37 -> { header_64 block_65 block_66 block_67}
{rank=same; header_64 block_65 block_66 block_67}

header_64 [label="3 : Block Parsing"]

block_65 [label="block 81-84"]

block_66 [label="block 85-89"]

block_67 [label="block 90-91"]


block_65 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Next we go into certain kinds of block and parse them.
"]
block_66 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This resolves the inner structure of 'structure' lines, which includes
all lists, tables, and similar. Some of these will not have been detected
yet, when this stage is done, what's left is prose, and unparsed code,
and we know which is which. 
"]
block_67 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We haven't found all code, just code blocks. 
"]
section_37 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Block Parsing

Next we go into certain kinds of block and parse them.

This resolves the inner structure of 'structure' lines, which includes
all lists, tables, and similar. Some of these will not have been detected
yet, when this stage is done, what's left is prose, and unparsed code,
and we know which is which. 

We haven't found all code, just code blocks. 

*"]
section_38 -> { header_72 block_73}
{rank=same; header_72 block_73}

header_72 [label="3 : Prose Parsing"]

block_73 [label="block 92-96"]


block_73 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We next parse these prose regions, looking for structural elements and 
handling them accordingly. 
"]
section_38 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Prose Parsing

We next parse these prose regions, looking for structural elements and 
handling them accordingly. 

*"]
section_39 -> { header_76 block_77}
{rank=same; header_76 block_77}

header_76 [label="3 : Mark Parsing"]

block_77 [label="block 97-101"]


block_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
As a final step, we parse within marks. Marks are either tags or names,
and both have a complex, TBD internal structure. 
"]
section_39 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Mark Parsing

As a final step, we parse within marks. Marks are either tags or names,
and both have a complex, TBD internal structure. 

*"]
section_5 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Structure

We're going to do this in several passes. 

*** Chunking

Our top-level of structure is determined by [[file:grimoire.org::*Header%20Lines][header lines]], which
cooperate to form the structure of a Grimoire document.

While we're doing this, we'll chunk everything else into arrays
of lines, this will split into structure lines, blank lines,
and TBD. 

I believe we can get everything into blocks on this first pass.

At this point, the data structure is still flat, but chunky, and
we have a separate vector of the header lines and their index
into the chunks. 

*** Ownership

We next determine basic ownership. This we do by counting all the stars 
in the header lines and building a tree accordingly. This is a 
recursive map of vectors containing chunks. 

**** Cling Rule

Various kinds of block have [[file:grimoire.org::*The%20Cling%20Rule][cling rules]] associated with them. How this
works is still somewhat opaque, no substitute for code in actually
working it out. 

We apply these rules, attaching tags to associated lists, tables and
code blocks, for example. 

I think the secret sauce of the cling rule is that it never matters if 
marks cling up or cling down, tags and names can come before, after, or
around the blocks they cling to. 

*** Block Parsing

Next we go into certain kinds of block and parse them.

This resolves the inner structure of 'structure' lines, which includes
all lists, tables, and similar. Some of these will not have been detected
yet, when this stage is done, what's left is prose, and unparsed code,
and we know which is which. 

We haven't found all code, just code blocks. 

*** Prose Parsing

We next parse these prose regions, looking for structural elements and 
handling them accordingly. 

*"]
section_6 -> { header_81 block_82 block_83 block_84 block_85 block_86}
{rank=same; header_81 block_82 block_83 block_84 block_85 block_86}

header_81 [label="2 : Result"]

block_82 [label="block 102-105"]

block_83 [label="block 106-110"]

block_84 [label="block 111-115"]

block_85 [label="block 116-118"]

block_86 [label="block 119-124"]


block_82 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Code is not parsed by this parser, not explicitly. 
"]
block_83 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Eventually, the document will have to be executed within an appropriate 
sandbox before it can be either tangled or woven. We'll skip that little
refinement, Lua is the runtime for that stage so it's comfortable to add 
it later. 
"]
block_84 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="What we do next depends on whether we're weaving or tangling. Weaving
is less interesting to me, at least for now; I'm hoping that if we get a 
bit of traction some wonk at Pandoc will add our biological distinctiveness
to that collective and we'll get a big boost in the right direction. 
"]
block_85 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Weaving is one of those things we can just iterate on endlesssly, and indeed
have to, document formats being what they are. 
"]
block_86 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="For simple tangling, we're interested in marks, edn blocks, and code blocks,
for now. Lists are the next data structure I'm interested in, with tables in
last place. I'm just not a grid kind of thinker. 


"]
section_6 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Result

Code is not parsed by this parser, not explicitly. 

Eventually, the document will have to be executed within an appropriate 
sandbox before it can be either tangled or woven. We'll skip that little
refinement, Lua is the runtime for that stage so it's comfortable to add 
it later. 

What we do next depends on whether we're weaving or tangling. Weaving
is less interesting to me, at least for now; I'm hoping that if we get a 
bit of traction some wonk at Pandoc will add our biological distinctiveness
to that collective and we'll get a big boost in the right direction. 

Weaving is one of those things we can just iterate on endlesssly, and indeed
have to, document formats being what they are. 

For simple tangling, we're interested in marks, edn blocks, and code blocks,
for now. Lists are the next data structure I'm interested in, with tables in
last place. I'm just not a grid kind of thinker. 



*"]
section_7 -> { header_93 block_94 section_95 section_96 section_97 section_98}
{rank=same; header_93 block_94 section_95 section_96 section_97 section_98}

header_93 [label="2 : Subsequent Actions"]

block_94 [label="block 125-146"]

section_95 [label="section: 129-132"]

section_96 [label="section: 133-136"]

section_97 [label="section: 137-146"]

section_98 [label="section: 147-155"]


block_94 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Each of these needs its own document.
"]
section_95 -> { header_100 block_101}
{rank=same; header_100 block_101}

header_100 [label="3 : Filtration"]

block_101 [label="block 129-132"]


block_101 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We normalize certain aspects, including a rigorous and unflinching programme of tab removal. 
"]
section_95 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Filtration

We normalize certain aspects, including a rigorous and unflinching programme of tab removal. 

*"]
section_96 -> { header_104 block_105}
{rank=same; header_104 block_105}

header_104 [label="3 : Tangling"]

block_105 [label="block 133-136"]


block_105 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The tangler is the first thing I intend to write. 
"]
section_96 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Tangling

The tangler is the first thing I intend to write. 

*"]
section_97 -> { header_108 block_109 block_110 block_111 block_112}
{rank=same; header_108 block_109 block_110 block_111 block_112}

header_108 [label="3 : Unraveling"]

block_109 [label="block 137-140"]

block_110 [label="block 141-142"]

block_111 [label="block 143-144"]

block_112 [label="block 145-146"]


block_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm designing the tangler specifically so that I can unravel from source. 
"]
block_110 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="How does that work? I intend to work out those details quite soon. 
"]
block_111 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Having a sense of how the structure is parsed internally is important here.
"]
block_112 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This subject has its [[file:unraveler.org::*grym%20unravel][own section]] already.
"]
section_97 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Unraveling

I'm designing the tangler specifically so that I can unravel from source. 

How does that work? I intend to work out those details quite soon. 

Having a sense of how the structure is parsed internally is important here.

This subject has its [[file:unraveler.org::*grym%20unravel][own section]] already.

*"]
section_98 -> { header_118 block_119 block_120 block_121}
{rank=same; header_118 block_119 block_120 block_121}

header_118 [label="3 : Weaving"]

block_119 [label="block 147-150"]

block_120 [label="block 151-153"]

block_121 [label="block 154-155"]


block_119 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Naturally, we need to weave. 
"]
block_120 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I don't know if this ever needs to be more customized than adding Grimoire 
format to a few canonical documentation engines. 
"]
block_121 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If we want to do fancy stuff with React and that, it does. 
"]
section_98 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Weaving

Naturally, we need to weave. 

I don't know if this ever needs to be more customized than adding Grimoire 
format to a few canonical documentation engines. 

If we want to do fancy stuff with React and that, it does. "]
section_7 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Subsequent Actions

Each of these needs its own document.

*** Filtration

We normalize certain aspects, including a rigorous and unflinching programme of tab removal. 

*** Tangling

The tangler is the first thing I intend to write. 

*** Unraveling

I'm designing the tangler specifically so that I can unravel from source. 

How does that work? I intend to work out those details quite soon. 

Having a sense of how the structure is parsed internally is important here.

This subject has its [[file:unraveler.org::*grym%20unravel][own section]] already.

*"]
section_1 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * A Grimoire Parser

** Introduction

I need a literate toolchain stat. I'm unwilling to write it on
Org. I've been having fun with Org but it has to go, and now is
the time.

I need this before the quipu, to write the quipu, so we're going to
forget reusable parsers and general editing structures and everything
like that for now. We're going to cut a fast parser out of Lua and
start hooking it up to things. 

Pegylator is proving remarkably useful for software I thought I was
abandoning in mid-February. But I digress.

There are important structural similarities between Grimoire and Markdown.
More with Org, of course, but Markdown is more widely parsed. Let's see
what we can find.

Oh hey this looks good:

[[https://github.com/jgm/lunamark][lunamark]]

In fact this looks very good. If I can trick lunamark into thinking that
Grimoire is just some exotic flavor of Markdown I can get a *lot* of 
functionality for free.

Let's try this approach and see if it flies. 

Hmm. There's a lot of useful code and approaches to lpeg to steal here.
But I'm just too well-equipped with my toolchain to want to switch horses.

The Node class is a little janky but not particularly broken and is shaping
up as my common AST format when in Lualand. If those get out of whack there will
be pain sooner or later. That's worth more than being able to use the lunamark
toolchain for export and the like. 

At least for now. I'll try to hold on to some of the naming conventions and see
if maybe I can talk the author into adapting the module once we're the popular
kids. 

** Structure

We're going to do this in several passes. 

*** Chunking

Our top-level of structure is determined by [[file:grimoire.org::*Header%20Lines][header lines]], which
cooperate to form the structure of a Grimoire document.

While we're doing this, we'll chunk everything else into arrays
of lines, this will split into structure lines, blank lines,
and TBD. 

I believe we can get everything into blocks on this first pass.

At this point, the data structure is still flat, but chunky, and
we have a separate vector of the header lines and their index
into the chunks. 

*** Ownership

We next determine basic ownership. This we do by counting all the stars 
in the header lines and building a tree accordingly. This is a 
recursive map of vectors containing chunks. 

**** Cling Rule

Various kinds of block have [[file:grimoire.org::*The%20Cling%20Rule][cling rules]] associated with them. How this
works is still somewhat opaque, no substitute for code in actually
working it out. 

We apply these rules, attaching tags to associated lists, tables and
code blocks, for example. 

I think the secret sauce of the cling rule is that it never matters if 
marks cling up or cling down, tags and names can come before, after, or
around the blocks they cling to. 

*** Block Parsing

Next we go into certain kinds of block and parse them.

This resolves the inner structure of 'structure' lines, which includes
all lists, tables, and similar. Some of these will not have been detected
yet, when this stage is done, what's left is prose, and unparsed code,
and we know which is which. 

We haven't found all code, just code blocks. 

*** Prose Parsing

We next parse these prose regions, looking for structural elements and 
handling them accordingly. 

*** Mark Parsing

As a final step, we parse within marks. Marks are either tags or names,
and both have a complex, TBD internal structure. 

** Result

Code is not parsed by this parser, not explicitly. 

Eventually, the document will have to be executed within an appropriate 
sandbox before it can be either tangled or woven. We'll skip that little
refinement, Lua is the runtime for that stage so it's comfortable to add 
it later. 

What we do next depends on whether we're weaving or tangling. Weaving
is less interesting to me, at least for now; I'm hoping that if we get a 
bit of traction some wonk at Pandoc will add our biological distinctiveness
to that collective and we'll get a big boost in the right direction. 

Weaving is one of those things we can just iterate on endlesssly, and indeed
have to, document formats being what they are. 

For simple tangling, we're interested in marks, edn blocks, and code blocks,
for now. Lists are the next data structure I'm interested in, with tables in
last place. I'm just not a grid kind of thinker. 



*"]

}
