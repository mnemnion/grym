digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 1219"]


doc_0 -> { section_1 section_2}
{rank=same; section_1 section_2}

section_1 [label="section: 1-3"]

section_2 [label="section: 34-338"]


section_1 -> { header_3 prose_4 structure_5 section_6}
{rank=same; header_3 prose_4 structure_5 section_6}

header_3 [label="0 : "]

prose_4 [label="prose"]

structure_5 [label="structure"]

section_6 [label="section: 4-33"]


header_3 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#+title: Grimoire: a metalanguage for magic spells."]
prose_4 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_5 -> { hashline_10}
{rank=same; hashline_10}

hashline_10 [label="hashline"]


hashline_10 -> { hashtag_11}
{rank=same; hashtag_11}

hashtag_11 [label="hashtag"]


hashtag_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_6 -> { header_13 prose_14 prose_15 prose_16 prose_17 prose_18 prose_19 prose_20 prose_21 prose_22}
{rank=same; header_13 prose_14 prose_15 prose_16 prose_17 prose_18 prose_19 prose_20 prose_21 prose_22}

header_13 [label="1 : Introduction"]

prose_14 [label="prose"]

prose_15 [label="prose"]

prose_16 [label="prose"]

prose_17 [label="prose"]

prose_18 [label="prose"]

prose_19 [label="prose"]

prose_20 [label="prose"]

prose_21 [label="prose"]

prose_22 [label="prose"]


header_13 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Introduction"]
prose_14 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire is a response to Babel.
"]
prose_15 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Babel is simultaneously a kludge and the most potentially powerful language in existence.
"]
prose_16 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Babel is a metalanguage. The structure of Org mode lets the user weave together code into a
living document, in a flexible, powerful way.
"]
prose_17 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The name is charmingly apt. Babel exists at the top of a tower of abstractions that is teetering
on the verge of collapse. Org-mode is an extension of outline mode, which was a simple tree
editor task list.
"]
prose_18 -> { raw_32}
{rank=same; raw_32}

raw_32 [label="raw"]


raw_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Various users bolted stuff on, because that's how emacs grows, you bolt stuff onto it and it
continues to function because it's [[http://lispers.org/][made with alien technology]].
"]
prose_19 -> { raw_34}
{rank=same; raw_34}

raw_34 [label="raw"]


raw_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The problem with Babel is more than the syntax being clunky, though that's a problem. The issue is
more profoundly that Babel is built on Org, which is built on emacs. It's a language, yes,
parsers exist for other platforms. But as a runtime, it isn't portable without a lot of effort.
"]
prose_20 -> { raw_36}
{rank=same; raw_36}

raw_36 [label="raw"]


raw_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So much so, that we get a chance to start over. It's roughly as difficult to write Grimoire as it would be to
reimplement Babel in, say, Sublime.
"]
prose_21 -> { raw_38}
{rank=same; raw_38}

raw_38 [label="raw"]


raw_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the process, we can:
"]
prose_22 -> { raw_40}
{rank=same; raw_40}

raw_40 [label="raw"]


raw_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - streamline concepts, making them more orthogonal
  - clean up the clunkiness in the grammar
  - build a toolchain that will let us write magic spells in any number of languages, amassing a powerful
    collection of same. A grimoire, if you will: a living book in which magic is both written and performed.
"]
section_2 -> { header_42 prose_43 section_44 section_45 section_46}
{rank=same; header_42 prose_43 section_44 section_45 section_46}

header_42 [label="1 : Musings on Metasyntax"]

prose_43 [label="prose"]

section_44 [label="section: 35-82"]

section_45 [label="section: 105-311"]

section_46 [label="section: 339-343"]


header_42 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Musings on Metasyntax"]
prose_43 -> { raw_48}
{rank=same; raw_48}

raw_48 [label="raw"]


raw_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_44 -> { header_50 prose_51 prose_52 section_53 section_54 section_55}
{rank=same; header_50 prose_51 prose_52 section_53 section_54 section_55}

header_50 [label="2 : Constraints"]

prose_51 [label="prose"]

prose_52 [label="prose"]

section_53 [label="section: 42-68"]

section_54 [label="section: 69-82"]

section_55 [label="section: 83-104"]


header_50 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Constraints"]
prose_51 -> { raw_57}
{rank=same; raw_57}

raw_57 [label="raw"]


raw_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

There is a difference between a metalanguage and a literate programming language. Babel is a metalanguage,
as Grimoire is intended to be.
"]
prose_52 -> { raw_59}
{rank=same; raw_59}

raw_59 [label="raw"]


raw_59 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
An effective metalanguage balances three concerns. It must be usable, readable, and parsable.
"]
section_53 -> { header_61 prose_62 prose_63 prose_64 prose_65 prose_66 prose_67 prose_68}
{rank=same; header_61 prose_62 prose_63 prose_64 prose_65 prose_66 prose_67 prose_68}

header_61 [label="3 : Usable"]

prose_62 [label="prose"]

prose_63 [label="prose"]

prose_64 [label="prose"]

prose_65 [label="prose"]

prose_66 [label="prose"]

prose_67 [label="prose"]

prose_68 [label="prose"]


header_61 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Usable"]
prose_62 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A metalanguage is used interactively, on a deeper level than REPLs.
"]
prose_63 -> { raw_72}
{rank=same; raw_72}

raw_72 [label="raw"]


raw_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is what makes working with Org so amazing. The first purpose of what became Babel
was simply editing outlines. This was outline mode, which dates back to the era when
using asterisks and =- [ ]= checkboxes in a plain ASCII text file was fairly futuristic
behavior.
"]
prose_64 -> { raw_74}
{rank=same; raw_74}

raw_74 [label="raw"]


raw_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You can't really call that a language either, though it's a syntax. More and more features
were attached until we have modern Babel. But because each feature was build as an extension
to the editing/runtime environment, Babel is fairly smooth to work with.
"]
prose_65 -> { raw_76}
{rank=same; raw_76}

raw_76 [label="raw"]


raw_76 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If you can handle Emacs. I can, some can't. A metalanguage is tightly coupled to its runtime,
because its runtime is its editing environment. Not much of a metalanguage if this isn't the
case.
"]
prose_66 -> { raw_78}
{rank=same; raw_78}

raw_78 [label="raw"]


raw_78 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is the culmination of a considerable dependency chain. We need a data structure, a
parser to work with the data structure, and an editing environment that builds on these. For
maximum enjoyment, we'll want a custom terminal that enhances the xterm protocol with a few
features, most notably graphics.
"]
prose_67 -> { raw_80}
{rank=same; raw_80}

raw_80 [label="raw"]


raw_80 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Just like I have trouble writing Lua without burning huge amounts of time planning out Clu, I
can't use Org without doing the same for Grimoire. It's all related: I need a really good parser.
"]
prose_68 -> { raw_82}
{rank=same; raw_82}

raw_82 [label="raw"]


raw_82 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
[[https://github.com/UpstandingHackers/hammer][hammer]] is the leading contender. But back to Grimoire.
"]
section_54 -> { header_84 prose_85 prose_86 prose_87}
{rank=same; header_84 prose_85 prose_86 prose_87}

header_84 [label="3 : Readable"]

prose_85 [label="prose"]

prose_86 [label="prose"]

prose_87 [label="prose"]


header_84 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Readable"]
prose_85 -> { raw_89}
{rank=same; raw_89}

raw_89 [label="raw"]


raw_89 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire is designed to be read.  It's important that the raw syntax not
 break the reader's flow.  A good metalanguage lets the user employ just
 as much magic as she's comfortable with, without imposing more.
"]
prose_86 -> { raw_91}
{rank=same; raw_91}

raw_91 [label="raw"]


raw_91 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Our syntax is  designed to support this. As such  it is deeply concerned
with matters  such as indentation  and whitespacing, which are  basic to
readability.
"]
prose_87 -> { raw_93}
{rank=same; raw_93}

raw_93 [label="raw"]


raw_93 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It will be quite possible and indeed comfortable to write pure documents
such  as blog  posts in  Grimoire form.  In that  use case  it resembles
Markdown.
"]
section_55 -> { header_95 prose_96 prose_97 prose_98 prose_99 prose_100}
{rank=same; header_95 prose_96 prose_97 prose_98 prose_99 prose_100}

header_95 [label="3 : Parsable"]

prose_96 [label="prose"]

prose_97 [label="prose"]

prose_98 [label="prose"]

prose_99 [label="prose"]

prose_100 [label="prose"]


header_95 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Parsable"]
prose_96 -> { raw_102}
{rank=same; raw_102}

raw_102 [label="raw"]


raw_102 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire  documents are  intended  to be  highly  convoluted. The  basic
editing operation  is the fold. The  Grimoire editor must be  capable of
handling documents in the tens of megabytes with a complex and preserved
folding structure.
"]
prose_97 -> { raw_104}
{rank=same; raw_104}

raw_104 [label="raw"]


raw_104 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This requires  a ground-up  editing environment  rewrite to  employ data
structures   with   correct   big-O    complexity   and   an   efficient
implementation.
"]
prose_98 -> { raw_106}
{rank=same; raw_106}

raw_106 [label="raw"]


raw_106 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This  also  requires  that  the   language  be  well-designed  for  easy
recognition of the structural elements. As this document evolves, I will
be defining a grammar in the syntax preferred by barbarian.
"]
prose_99 -> { raw_108}
{rank=same; raw_108}

raw_108 [label="raw"]


raw_108 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is  an error-free  language. There  are several  concepts which
interact to  create this, namely  structure, prose, well-  and malformed
structure, and validity.
"]
prose_100 -> { raw_110}
{rank=same; raw_110}

raw_110 [label="raw"]


raw_110 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A parser for Grimoire which doesn't  succeed without error for any utf-8
string is not valid.
"]
section_45 -> { header_112 prose_113 section_114 section_115 section_116 section_117 section_118 section_119}
{rank=same; header_112 prose_113 section_114 section_115 section_116 section_117 section_118 section_119}

header_112 [label="2 : Structure"]

prose_113 [label="prose"]

section_114 [label="section: 109-149"]

section_115 [label="section: 161-190"]

section_116 [label="section: 191-200"]

section_117 [label="section: 253-285"]

section_118 [label="section: 295-311"]

section_119 [label="section: 312-338"]


header_112 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Structure"]
prose_113 -> { raw_121}
{rank=same; raw_121}

raw_121 [label="raw"]


raw_121 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is a top-down look at Grimoire's proposed syntax.
"]
section_114 -> { header_123 prose_124 prose_125 prose_126 prose_127 prose_128 prose_129 prose_130 prose_131 prose_132 section_133}
{rank=same; header_123 prose_124 prose_125 prose_126 prose_127 prose_128 prose_129 prose_130 prose_131 prose_132 section_133}

header_123 [label="3 : Encoding"]

prose_124 [label="prose"]

prose_125 [label="prose"]

prose_126 [label="prose"]

prose_127 [label="prose"]

prose_128 [label="prose"]

prose_129 [label="prose"]

prose_130 [label="prose"]

prose_131 [label="prose"]

prose_132 [label="prose"]

section_133 [label="section: 150-160"]


header_123 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Encoding"]
prose_124 -> { raw_135}
{rank=same; raw_135}

raw_135 [label="raw"]


raw_135 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire is defined in terms of utf-8.
"]
prose_125 -> { raw_137}
{rank=same; raw_137}

raw_137 [label="raw"]


raw_137 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The core syntax is defined in terms of the reachable keys on a US keyboard.
This tradition is firmly entrenched in the mid teens, and I have no
designs on budging that at present. The miser in me likes that they're
a byte each. The lawyer in me insists that this isn't ASCII, which is a
seven-bit legacy encoding. All aspects of utf-8 are equally meaningful.
"]
prose_126 -> { raw_139}
{rank=same; raw_139}

raw_139 [label="raw"]


raw_139 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We aren't at all afraid to use Unicode characters to display aspects
of the runtime. In fact we favor this, as it marks those operations
as distinctive. Most people can't type ⦿ without effort (I can't)
and it's easy to recognize as a folded drawer once you've seen a couple.
"]
prose_127 -> { raw_141}
{rank=same; raw_141}

raw_141 [label="raw"]


raw_141 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is case sensitive and uses lower-snake-case for built-in English
phrases. There is a convention (see classes) that uses capitalization of
user words to affect semantics. This may be overridden with other rules
for languages that lack the majuscule-miniscule distinction.
"]
prose_128 -> { raw_143}
{rank=same; raw_143}

raw_143 [label="raw"]


raw_143 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I want Grimoire to have correct Unicode handling, for some value of
correct. It can't be considered 1.0 without this.
"]
prose_129 -> { raw_145}
{rank=same; raw_145}

raw_145 [label="raw"]


raw_145 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Bidirectional handling in a context that's indentation sensitive is
an example of something subtle. Grimoire uses indentation in various
ways, so here's the rule:
"]
prose_130 -> { raw_147}
{rank=same; raw_147}

raw_147 [label="raw"]


raw_147 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Any newline that has a reversed direction ends indentation. So if
you are going ltr, issue an rtl marker, and a newline, your indentation
level is zero. If you reverse direction twice in a line, you keep
your indentation level. Three times, you lose it.
"]
prose_131 -> { raw_149}
{rank=same; raw_149}

raw_149 [label="raw"]


raw_149 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'd love to get a Hebrew and/or Arabic fluent hacker on the project
early, to make sure this works correctly.
"]
prose_132 -> { raw_151}
{rank=same; raw_151}

raw_151 [label="raw"]


raw_151 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Another thing I want to get right is equivalence. If you have a
variable called \"Glück\" the compiler shouldn't complain if it's
rendered in either of the valid ways. For some sequences that's
\"any of the valid ways\". If we normalized your prose, you might
have problems later, so we don't want to solve it that way.
"]
section_133 -> { header_153 prose_154 prose_155}
{rank=same; header_153 prose_154 prose_155}

header_153 [label="4 : Internationalization"]

prose_154 [label="prose"]

prose_155 [label="prose"]


header_153 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Internationalization"]
prose_154 -> { raw_157}
{rank=same; raw_157}

raw_157 [label="raw"]


raw_157 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

All parts of Grimoire defined in English will be namespaced
as =en:/=, and loaded by default. Other languages will be added
when there is a fluent maintainer available.
"]
prose_155 -> { raw_159}
{rank=same; raw_159}

raw_159 [label="raw"]


raw_159 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Note  that  many  words  aren't  truly English.  Notably  the  names  of
programming languages are  the same in all human languages.   A tag like
=#author= can be namespaced =#fr:/auteur= and will be, but =#!python= is not
in the =en:/= namespace.
"]
section_115 -> { header_161 prose_162 prose_163 prose_164 prose_165 prose_166 prose_167 prose_168}
{rank=same; header_161 prose_162 prose_163 prose_164 prose_165 prose_166 prose_167 prose_168}

header_161 [label="3 : Prose and Structure"]

prose_162 [label="prose"]

prose_163 [label="prose"]

prose_164 [label="prose"]

prose_165 [label="prose"]

prose_166 [label="prose"]

prose_167 [label="prose"]

prose_168 [label="prose"]


header_161 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Prose and Structure"]
prose_162 -> { raw_170}
{rank=same; raw_170}

raw_170 [label="raw"]


raw_170 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The major distinction Grimoire draws is between prose and structure.
"]
prose_163 -> { raw_172}
{rank=same; raw_172}

raw_172 [label="raw"]


raw_172 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Prose is the default parsing state. It is far from unstructured from the
runtime  perspective. Although  this needn't  be embedded  in the  parse
tree,  Grimoire   understands  concepts   such  as   paragraphs,  words,
punctuation,  capital letters,  languages, and  anything else  proper to
prose.
"]
prose_164 -> { raw_174}
{rank=same; raw_174}

raw_174 [label="raw"]


raw_174 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I refer to human languages, but Grimoire understands programming languages
also. In principle, all of them, it shouldn't be harder to add them than
it is to call them from shell, though getting a runtime rigged up to
another runtime always calls for some finesse to derive a good experience.
"]
prose_165 -> { raw_176}
{rank=same; raw_176}

raw_176 [label="raw"]


raw_176 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
\"Programming languages\" is overly specific. Grimoire draws a distinction
between prose and structure. Blocks may contain either, or both.
"]
prose_166 -> { raw_178}
{rank=same; raw_178}

raw_178 [label="raw"]


raw_178 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Something that's nice about a language build on a prose/structure
relationship is that it can be error free. Anything *grym* can't build into
a structure is just prose.
"]
prose_167 -> { raw_180}
{rank=same; raw_180}

raw_180 [label="raw"]


raw_180 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Markdown has this property. Sometimes you run into crappy parsers which
build errors into Markdown, which is just obnoxious. If you [[http://daringfireball.net/projects/markdown/syntax][RTFM]],
you'll find the word \"error\" once. Helpfully explaining how Markdown
keeps you from making one.
"]
prose_168 -> { raw_182}
{rank=same; raw_182}

raw_182 [label="raw"]


raw_182 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We do what we can to make the document look the same as it is
in fact structured. Syntax highlighting handles the edge cases.
"]
section_116 -> { header_184 prose_185 prose_186 prose_187 section_188}
{rank=same; header_184 prose_185 prose_186 prose_187 section_188}

header_184 [label="3 : Ownership"]

prose_185 [label="prose"]

prose_186 [label="prose"]

prose_187 [label="prose"]

section_188 [label="section: 201-252"]


header_184 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Ownership"]
prose_185 -> { raw_190}
{rank=same; raw_190}

raw_190 [label="raw"]


raw_190 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The basic structural relationship in Grimoire is ownership.
"]
prose_186 -> { raw_192}
{rank=same; raw_192}

raw_192 [label="raw"]


raw_192 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Root elements of a heirarchy own their children, blocks own
lines that refer to that block. Indentation has a subtle but
regular interaction with ownership; it does what you expect.
"]
prose_187 -> { raw_194}
{rank=same; raw_194}

raw_194 [label="raw"]


raw_194 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Edge cases are resolved using the cling rule.
"]
section_188 -> { header_196 prose_197 prose_198 prose_199 prose_200 structure_201 structure_202 structure_203 structure_204 structure_205 prose_206 structure_207 structure_208 structure_209 prose_210}
{rank=same; header_196 prose_197 prose_198 prose_199 prose_200 structure_201 structure_202 structure_203 structure_204 structure_205 prose_206 structure_207 structure_208 structure_209 prose_210}

header_196 [label="4 : The Cling Rule"]

prose_197 [label="prose"]

prose_198 [label="prose"]

prose_199 [label="prose"]

prose_200 [label="prose"]

structure_201 [label="structure"]

structure_202 [label="structure"]

structure_203 [label="structure"]

structure_204 [label="structure"]

structure_205 [label="structure"]

prose_206 [label="prose"]

structure_207 [label="structure"]

structure_208 [label="structure"]

structure_209 [label="structure"]

prose_210 [label="prose"]


header_196 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** The Cling Rule"]
prose_197 -> { raw_212}
{rank=same; raw_212}

raw_212 [label="raw"]


raw_212 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The cling rule specifies that a group 'clings' to another group when
it is closer to that group than the other group. Ties resolve down.
"]
prose_198 -> { raw_214}
{rank=same; raw_214}

raw_214 [label="raw"]


raw_214 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This should make it intuitive to group elements that aren't grouping the
way you expect: put in whitespace until the block is visually distinguished
from the surroundings.
"]
prose_199 -> { raw_216}
{rank=same; raw_216}

raw_216 [label="raw"]


raw_216 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Cling applies between blocks which are at the same level of ownership.
Ownership has precedence over cling: all blocks underneath e.g. a header
line are owned by that line, newlines notwithstanding.
"]
prose_200 -> { raw_218}
{rank=same; raw_218}

raw_218 [label="raw"]


raw_218 -> leaf_219
leaf_219  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Note that indentation of e.g. lists invokes the cling rule within the
indentation level.

"]
structure_201 -> { hashline_220}
{rank=same; hashline_220}

hashline_220 [label="hashline"]


hashline_220 -> { hashtag_221}
{rank=same; hashtag_221}

hashtag_221 [label="hashtag"]


hashtag_221 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_202 -> { hashline_223}
{rank=same; hashline_223}

hashline_223 [label="hashline"]


hashline_223 -> { hashtag_224}
{rank=same; hashtag_224}

hashtag_224 [label="hashtag"]


hashtag_224 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_203 -> { hashline_226}
{rank=same; hashline_226}

hashline_226 [label="hashline"]


hashline_226 -> { hashtag_227}
{rank=same; hashtag_227}

hashtag_227 [label="hashtag"]


hashtag_227 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_204 -> { hashline_229}
{rank=same; hashline_229}

hashline_229 [label="hashline"]


hashline_229 -> { hashtag_230}
{rank=same; hashtag_230}

hashtag_230 [label="hashtag"]


hashtag_230 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tag"]
structure_205 -> { hashline_232}
{rank=same; hashline_232}

hashline_232 [label="hashline"]


hashline_232 -> { hashtag_233}
{rank=same; hashtag_233}

hashtag_233 [label="hashtag"]


hashtag_233 -> leaf_234
leaf_234  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_206 -> { raw_235}
{rank=same; raw_235}

raw_235 [label="raw"]


raw_235 -> leaf_236
leaf_236  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Even clings are resolved forwards:
"]
structure_207 -> { hashline_237}
{rank=same; hashline_237}

hashline_237 [label="hashline"]


hashline_237 -> { hashtag_238}
{rank=same; hashtag_238}

hashtag_238 [label="hashtag"]


hashtag_238 -> leaf_239
leaf_239  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_208 -> { hashline_240}
{rank=same; hashline_240}

hashline_240 [label="hashline"]


hashline_240 -> { hashtag_241}
{rank=same; hashtag_241}

hashtag_241 [label="hashtag"]


hashtag_241 -> leaf_242
leaf_242  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tag"]
structure_209 -> { hashline_243}
{rank=same; hashline_243}

hashline_243 [label="hashline"]


hashline_243 -> { hashtag_244}
{rank=same; hashtag_244}

hashtag_244 [label="hashtag"]


hashtag_244 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_210 -> { raw_246}
{rank=same; raw_246}

raw_246 [label="raw"]


raw_246 -> leaf_247
leaf_247  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
be considered bad style.
"]
section_117 -> { header_248 prose_249 section_250 section_251 section_252}
{rank=same; header_248 prose_249 section_250 section_251 section_252}

header_248 [label="3 : Whitespace, Lines, and Indentation."]

prose_249 [label="prose"]

section_250 [label="section: 258-279"]

section_251 [label="section: 280-285"]

section_252 [label="section: 286-294"]


header_248 -> leaf_253
leaf_253  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Whitespace, Lines, and Indentation."]
prose_249 -> { raw_254}
{rank=same; raw_254}

raw_254 [label="raw"]


raw_254 -> leaf_255
leaf_255  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire is a structured document format. There are semantics associated
with every character we encode.
"]
section_250 -> { header_256 prose_257 prose_258 prose_259 prose_260 prose_261}
{rank=same; header_256 prose_257 prose_258 prose_259 prose_260 prose_261}

header_256 [label="4 : Whitespace"]

prose_257 [label="prose"]

prose_258 [label="prose"]

prose_259 [label="prose"]

prose_260 [label="prose"]

prose_261 [label="prose"]


header_256 -> leaf_262
leaf_262  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Whitespace"]
prose_257 -> { raw_263}
{rank=same; raw_263}

raw_263 [label="raw"]


raw_263 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Whitespace is either the space or newline character. Returns are removed,
tabs resolved to two spaces by the formatter, the latter is warned against.
"]
prose_258 -> { raw_265}
{rank=same; raw_265}

raw_265 [label="raw"]


raw_265 -> leaf_266
leaf_266  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Most of the token-like categories we refer to must be surrounded by
whitespace. Newlines have semantics more often than they do not.
"]
prose_259 -> { raw_267}
{rank=same; raw_267}

raw_267 [label="raw"]


raw_267 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Unicode actually contains quite a number of whitespace characters. They are
all treated as a single ordinary space. If that space is semantically meaningful,
as in the space between =*** A Headline=, it is filtered into an ordinary space.
Otherwise it's considered prose, the only filtration prose receives is tab->space
conversion.
"]
prose_260 -> { raw_269}
{rank=same; raw_269}

raw_269 [label="raw"]


raw_269 -> leaf_270
leaf_270  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire mercilessly enforces tab-space conversion, even on your code blocks.
I will cling to this tenet as long as I can, the tab character needs to die,
the world has decided, that key is special and shouldn't insert a special
dropping that looks like n spaces.
"]
prose_261 -> { raw_271}
{rank=same; raw_271}

raw_271 [label="raw"]


raw_271 -> leaf_272
leaf_272  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
*make*? Outta my face with make. Yes, we'll have a make syntax, yes, it will
put the tabs back in.
"]
section_251 -> { header_273 prose_274}
{rank=same; header_273 prose_274}

header_273 [label="4 : Lines"]

prose_274 [label="prose"]


header_273 -> leaf_275
leaf_275  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Lines"]
prose_274 -> { raw_276}
{rank=same; raw_276}

raw_276 [label="raw"]


raw_276 -> leaf_277
leaf_277  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

When we refer to the beginning of a line, this allows for spaces before the
reference point. We call the absolute beginning of a line the first
position.
"]
section_252 -> { header_278 prose_279 prose_280 prose_281}
{rank=same; header_278 prose_279 prose_280 prose_281}

header_278 [label="4 : Indentation"]

prose_279 [label="prose"]

prose_280 [label="prose"]

prose_281 [label="prose"]


header_278 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Indentation"]
prose_279 -> { raw_283}
{rank=same; raw_283}

raw_283 [label="raw"]


raw_283 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire is an indentation-aware language. Most kinds of block can be
arcically[fn:1] ordered by means of indentation.
"]
prose_280 -> { raw_285}
{rank=same; raw_285}

raw_285 [label="raw"]


raw_285 -> leaf_286
leaf_286  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indentation follows [[http://nim-lang.org/manual.html#indentation][Nim rules]].
"]
prose_281 -> { raw_287}
{rank=same; raw_287}

raw_287 [label="raw"]


raw_287 -> leaf_288
leaf_288  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
[fn:1] There's nothing sacred about ordered subrules, and if we're making up
a new word, let's drop the silent h. Webster was a cool guy."]
section_118 -> { header_289 prose_290 prose_291 prose_292 prose_293}
{rank=same; header_289 prose_290 prose_291 prose_292 prose_293}

header_289 [label="3 : Order of Recognition"]

prose_290 [label="prose"]

prose_291 [label="prose"]

prose_292 [label="prose"]

prose_293 [label="prose"]


header_289 -> leaf_294
leaf_294  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Order of Recognition"]
prose_290 -> { raw_295}
{rank=same; raw_295}

raw_295 [label="raw"]


raw_295 -> leaf_296
leaf_296  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Starting from the neutral context, which is always at a newline, Grimoire
tries to make one of its initializing special forms. Failing that, it will
begin a prose block.
"]
prose_291 -> { raw_297}
{rank=same; raw_297}

raw_297 [label="raw"]


raw_297 -> leaf_298
leaf_298  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If there is whitespace, it affects indentation level in indicated ways.
They will not directly affect the semantics of the following form, that is,
these rules apply after any potentially block-ending newline, apart from
spaces that may be found between the newline and the character.
"]
prose_292 -> { raw_299}
{rank=same; raw_299}

raw_299 [label="raw"]


raw_299 -> leaf_300
leaf_300  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
At present,  =*=, =#=,  =|=, =-=,  , =~=,  =@=, =:=  and ={=  all create
special  contexts.  A  special  context  creates a  block  in a  context
specific way.
"]
prose_293 -> { raw_301}
{rank=same; raw_301}

raw_301 [label="raw"]


raw_301 -> leaf_302
leaf_302  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Blocks have a left associativity which can be recursive.
"]
section_119 -> { header_303 prose_304 prose_305 prose_306 prose_307 prose_308}
{rank=same; header_303 prose_304 prose_305 prose_306 prose_307 prose_308}

header_303 [label="3 : Blocks"]

prose_304 [label="prose"]

prose_305 [label="prose"]

prose_306 [label="prose"]

prose_307 [label="prose"]

prose_308 [label="prose"]


header_303 -> leaf_309
leaf_309  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Blocks"]
prose_304 -> { raw_310}
{rank=same; raw_310}

raw_310 [label="raw"]


raw_310 -> leaf_311
leaf_311  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire is oriented around blocks.
"]
prose_305 -> { raw_312}
{rank=same; raw_312}

raw_312 [label="raw"]


raw_312 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Blocks are at least one line long,  all restarts are on a new line.  Any
syntactic structure smaller than a block we call an element.
"]
prose_306 -> { raw_314}
{rank=same; raw_314}

raw_314 [label="raw"]


raw_314 -> leaf_315
leaf_315  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Some types of blocks nest.  A document is a single  block.  There may be
other semantic units such as directories, I'd think a language that uses
strict  nested heirarchy  as powerfully  as Grimoire  could dictate  the
semantics of a file system, but that's currently out of scope.
"]
prose_307 -> { raw_316}
{rank=same; raw_316}

raw_316 [label="raw"]


raw_316 -> leaf_317
leaf_317  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indentation is relevant to some  kinds of blocks. In general, whitespace
matters quite a  bit in a Grimoire  document. We keep some  of the warts
out because the tab character is  illegal, and there will be a mandatory
formatter, =grym  fmt= if  you will, that  does everything  from turning
=**bold**=  into =*bold*=  (because the  extra stars  weren't used),  to
newline stripping, and so on.  This is normally applied incrementally by
the runtime editing environment.
"]
prose_308 -> { raw_318}
{rank=same; raw_318}

raw_318 [label="raw"]


raw_318 -> leaf_319
leaf_319  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indentation is human  readable and, with some care, a  computer may come
to the  same conclusions a  human would. I'm  still wary of  Python, but
there's no good  reason, unless the headache of most  Python not working
correctly  on my  computer, for  reasons I  can't track  down that  seem
related to  there being two languages  invoked as 'python', counts  as a
good reason.
"]
section_46 -> { header_320 prose_321 section_322}
{rank=same; header_320 prose_321 section_322}

header_320 [label="2 : Syntax"]

prose_321 [label="prose"]

section_322 [label="section: 344-407"]


header_320 -> leaf_323
leaf_323  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Syntax"]
prose_321 -> { raw_324}
{rank=same; raw_324}

raw_324 [label="raw"]


raw_324 -> leaf_325
leaf_325  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Now that we've established the basic constraints, let's
start our recursive descent into the parse.
"]
section_322 -> { header_326 prose_327 prose_328 prose_329 prose_330 prose_331 prose_332 structure_333 section_334 section_335}
{rank=same; header_326 prose_327 prose_328 prose_329 prose_330 prose_331 prose_332 structure_333 section_334 section_335}

header_326 [label="3 : Headers"]

prose_327 [label="prose"]

prose_328 [label="prose"]

prose_329 [label="prose"]

prose_330 [label="prose"]

prose_331 [label="prose"]

prose_332 [label="prose"]

structure_333 [label="structure"]

section_334 [label="section: 368-368"]

section_335 [label="section: 408-419"]


header_326 -> leaf_336
leaf_336  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Headers"]
prose_327 -> { raw_337}
{rank=same; raw_337}

raw_337 [label="raw"]


raw_337 -> leaf_338
leaf_338  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Grimoire is arcically constrained by structure groups,
called headers.
"]
prose_328 -> { raw_339}
{rank=same; raw_339}

raw_339 [label="raw"]


raw_339 -> leaf_340
leaf_340  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
These start on a new line and begin with any number of  =*=. These must
be followed by a space mark to be valid. Contra Babel, you may
have a content-free header line, provided a space is found before the
newline.
"]
prose_329 -> { raw_341}
{rank=same; raw_341}

raw_341 [label="raw"]


raw_341 -> leaf_342
leaf_342  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In weaves and the like, headers represent document structure. Their
intention is structural: they support the same syntax as lists,
but the user is expected to use lists for list purposes. Putting
[TODO] in a header line should mean you have a document-specific
task to perform in that block.
"]
prose_330 -> { raw_343}
{rank=same; raw_343}

raw_343 [label="raw"]


raw_343 -> leaf_344
leaf_344  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Contra Babel, you may put spaces before the beginning of a header line.
"]
prose_331 -> { raw_345}
{rank=same; raw_345}

raw_345 [label="raw"]


raw_345 -> leaf_346
leaf_346  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The semantics of header lines are entirely determined by
the number of stars.
"]
prose_332 -> { raw_347}
{rank=same; raw_347}

raw_347 [label="raw"]


raw_347 -> leaf_348
leaf_348  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If you write
"]
structure_333 -> { hashline_349}
{rank=same; hashline_349}

hashline_349 [label="hashline"]


hashline_349 -> { hashtag_350}
{rank=same; hashtag_350}

hashtag_350 [label="hashtag"]


hashtag_350 -> leaf_351
leaf_351  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_334 -> { header_352 prose_353 section_354}
{rank=same; header_352 prose_353 section_354}

header_352 [label="1 : Top Header"]

prose_353 [label="prose"]

section_354 [label="section: 369-380"]


header_352 -> leaf_355
leaf_355  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  * Top Header"]
prose_353 -> { raw_356}
{rank=same; raw_356}

raw_356 [label="raw"]


raw_356 -> leaf_357
leaf_357  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_354 -> { header_358 structure_359 structure_360 section_361}
{rank=same; header_358 structure_359 structure_360 section_361}

header_358 [label="2 : Second Header"]

structure_359 [label="structure"]

structure_360 [label="structure"]

section_361 [label="section: 381-381"]


header_358 -> leaf_362
leaf_362  [color=Gray,shape=rectangle,fontname=Inconsolata,label="    ** Second Header"]
structure_359 -> { hashline_363}
{rank=same; hashline_363}

hashline_363 [label="hashline"]


hashline_363 -> { hashtag_364}
{rank=same; hashtag_364}

hashtag_364 [label="hashtag"]


hashtag_364 -> leaf_365
leaf_365  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_360 -> { hashline_366}
{rank=same; hashline_366}

hashline_366 [label="hashline"]


hashline_366 -> { hashtag_367}
{rank=same; hashtag_367}

hashtag_367 [label="hashtag"]


hashtag_367 -> leaf_368
leaf_368  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_361 -> { header_369 prose_370 section_371}
{rank=same; header_369 prose_370 section_371}

header_369 [label="1 : Top Header ▼"]

prose_370 [label="prose"]

section_371 [label="section: 382-731"]


header_369 -> leaf_372
leaf_372  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Top Header ▼"]
prose_370 -> { raw_373}
{rank=same; raw_373}

raw_373 [label="raw"]


raw_373 -> leaf_374
leaf_374  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_371 -> { header_375 structure_376 prose_377 prose_378 prose_379 section_380 section_381 section_382 section_383 section_384 section_385 section_386 section_387 section_388 section_389}
{rank=same; header_375 structure_376 prose_377 prose_378 prose_379 section_380 section_381 section_382 section_383 section_384 section_385 section_386 section_387 section_388 section_389}

header_375 [label="2 : Second Header ►"]

structure_376 [label="structure"]

prose_377 [label="prose"]

prose_378 [label="prose"]

prose_379 [label="prose"]

section_380 [label="section: 398-407"]

section_381 [label="section: 422-440"]

section_382 [label="section: 441-481"]

section_383 [label="section: 489-501"]

section_384 [label="section: 502-558"]

section_385 [label="section: 567-593"]

section_386 [label="section: 594-611"]

section_387 [label="section: 612-672"]

section_388 [label="section: 691-731"]

section_389 [label="section: 732-741"]


header_375 -> leaf_390
leaf_390  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   ** Second Header ►"]
structure_376 -> { hashline_391}
{rank=same; hashline_391}

hashline_391 [label="hashline"]


hashline_391 -> { hashtag_392}
{rank=same; hashtag_392}

hashtag_392 [label="hashtag"]


hashtag_392 -> leaf_393
leaf_393  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_377 -> { raw_394}
{rank=same; raw_394}

raw_394 [label="raw"]


raw_394 -> leaf_395
leaf_395  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
may contain any number of blocks.
"]
prose_378 -> { raw_396}
{rank=same; raw_396}

raw_396 [label="raw"]


raw_396 -> leaf_397
leaf_397  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
\"begins\" means first non-whitespace character. Indentation levels are tracked by
Nim rules, obviously a Grimoire document can contain no tab marks
and if any wander in they become four spaces.
"]
prose_379 -> { raw_398}
{rank=same; raw_398}

raw_398 [label="raw"]


raw_398 -> leaf_399
leaf_399  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Contra other block forms, tags may not precede a headline.
"]
section_380 -> { header_400 prose_401 prose_402 prose_403}
{rank=same; header_400 prose_401 prose_402 prose_403}

header_400 [label="4 : Header Lines"]

prose_401 [label="prose"]

prose_402 [label="prose"]

prose_403 [label="prose"]


header_400 -> leaf_404
leaf_404  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Header Lines"]
prose_401 -> { raw_405}
{rank=same; raw_405}

raw_405 [label="raw"]


raw_405 -> leaf_406
leaf_406  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Anything after a run of =*= and a space, and before a newline, is
a header line.
"]
prose_402 -> { raw_407}
{rank=same; raw_407}

raw_407 [label="raw"]


raw_407 -> leaf_408
leaf_408  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Header lines and list lines are structured identically. If I discover
a necessary exception, I'll note it.
"]
prose_403 -> { raw_409}
{rank=same; raw_409}

raw_409 [label="raw"]


raw_409 -> leaf_410
leaf_410  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That structure is discussed under [[*Lists][lists]].
"]
section_381 -> { header_411 prose_412 prose_413 structure_414 prose_415 prose_416 structure_417}
{rank=same; header_411 prose_412 prose_413 structure_414 prose_415 prose_416 structure_417}

header_411 [label="3 : Prose blocks"]

prose_412 [label="prose"]

prose_413 [label="prose"]

structure_414 [label="structure"]

prose_415 [label="prose"]

prose_416 [label="prose"]

structure_417 [label="structure"]


header_411 -> leaf_418
leaf_418  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Prose blocks"]
prose_412 -> { raw_419}
{rank=same; raw_419}

raw_419 [label="raw"]


raw_419 -> leaf_420
leaf_420  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A prose block is preceded and followed by a single newline. Extraneous
whitespace on the bare line is filtered.
"]
prose_413 -> { raw_421}
{rank=same; raw_421}

raw_421 [label="raw"]


raw_421 -> leaf_422
leaf_422  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Prose blocks may not be indented in a semantically meaningful way.
"]
structure_414 -> { hashline_423}
{rank=same; hashline_423}

hashline_423 [label="hashline"]


hashline_423 -> { hashtag_424}
{rank=same; hashtag_424}

hashtag_424 [label="hashtag"]


hashtag_424 -> leaf_425
leaf_425  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_415 -> { raw_426}
{rank=same; raw_426}

raw_426 [label="raw"]


raw_426 -> leaf_427
leaf_427  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
    prose
"]
prose_416 -> { raw_428}
{rank=same; raw_428}

raw_428 [label="raw"]


raw_428 -> leaf_429
leaf_429  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        prose
"]
structure_417 -> { hashline_430}
{rank=same; hashline_430}

hashline_430 [label="hashline"]


hashline_430 -> { hashtag_431}
{rank=same; hashtag_431}

hashtag_431 [label="hashtag"]


hashtag_431 -> leaf_432
leaf_432  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_382 -> { header_433 prose_434 prose_435 prose_436 prose_437 prose_438 prose_439 prose_440 structure_441 prose_442 prose_443 prose_444 section_445}
{rank=same; header_433 prose_434 prose_435 prose_436 prose_437 prose_438 prose_439 prose_440 structure_441 prose_442 prose_443 prose_444 section_445}

header_433 [label="3 : Prose markup"]

prose_434 [label="prose"]

prose_435 [label="prose"]

prose_436 [label="prose"]

prose_437 [label="prose"]

prose_438 [label="prose"]

prose_439 [label="prose"]

prose_440 [label="prose"]

structure_441 [label="structure"]

prose_442 [label="prose"]

prose_443 [label="prose"]

prose_444 [label="prose"]

section_445 [label="section: 482-488"]


header_433 -> leaf_446
leaf_446  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Prose markup"]
prose_434 -> { raw_447}
{rank=same; raw_447}

raw_447 [label="raw"]


raw_447 -> leaf_448
leaf_448  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Prose markup rules apply in any prose contexts, not just for prose blocks.
"]
prose_435 -> { raw_449}
{rank=same; raw_449}

raw_449 [label="raw"]


raw_449 -> leaf_450
leaf_450  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We mark =*bold*=, =/italic/=, =_underline_=, =~strikethrough~=, 
and =​=literal=​=, using the indicated marks. They must not be separated 
with whitespace from the connecting prose. Any number may be used and matched,
whitespace is allowed, so =**bold math: 4 * 5**= will highlight
correctly.
"]
prose_436 -> { raw_451}
{rank=same; raw_451}

raw_451 [label="raw"]


raw_451 -> leaf_452
leaf_452  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There is also [[*Inline%20Code][Inline Code]], which is formatted =`code`=.
"]
prose_437 -> { raw_453}
{rank=same; raw_453}

raw_453 [label="raw"]


raw_453 -> leaf_454
leaf_454  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
These all follow the prose markup rule: any number of the starting
character matches the same number of the ending character in the
document string.
"]
prose_438 -> { raw_455}
{rank=same; raw_455}

raw_455 [label="raw"]


raw_455 -> leaf_456
leaf_456  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We make subscripts mildly annoying, =sub__script= and =super^^script=, 
to avoid colliding the former with =snake_case=. That's a lot of ways 
to parse the =_= character...
"]
prose_439 -> { raw_457}
{rank=same; raw_457}

raw_457 [label="raw"]


raw_457 -> leaf_458
leaf_458  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In general, prose is more 'active'  than in Babel. There are more things
you can't say without triggering a parsed data structure.  Due to quirks
of Org  involving string  escaping, =`\\\"\\\"`=  can't be  literally quoted
without repercussions. Check  out the source if you enjoy pounding your
head in frustration at the nastiness of escaped strings.
"]
prose_440 -> { raw_459}
{rank=same; raw_459}

raw_459 [label="raw"]


raw_459 -> leaf_460
leaf_460  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Let's just use a code block:
"]
structure_441 -> { hashline_461}
{rank=same; hashline_461}

hashline_461 [label="hashline"]


hashline_461 -> { hashtag_462}
{rank=same; hashtag_462}

hashtag_462 [label="hashtag"]


hashtag_462 -> leaf_463
leaf_463  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_442 -> { raw_464}
{rank=same; raw_464}

raw_464 [label="raw"]


raw_464 -> leaf_465
leaf_465  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
one, of the \" character. This is pretty-printed in edit mode as =‟literal”=,
but such a string does *not* create escaping, we rely on semantic highlighting
to make the distinction clear.
"]
prose_443 -> { raw_466}
{rank=same; raw_466}

raw_466 [label="raw"]


raw_466 -> leaf_467
leaf_467  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Any number of \"\"\"\" collapse into one set of such balanced quites.
"]
prose_444 -> { raw_468}
{rank=same; raw_468}

raw_468 [label="raw"]


raw_468 -> leaf_469
leaf_469  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the woven documentation, no quotation marks appear, just the string.
"]
section_445 -> { header_470 prose_471}
{rank=same; header_470 prose_471}

header_470 [label="4 : Latex"]

prose_471 [label="prose"]


header_470 -> leaf_472
leaf_472  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Latex"]
prose_471 -> { raw_473}
{rank=same; raw_473}

raw_473 [label="raw"]


raw_473 -> leaf_474
leaf_474  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

For further markup purposes in a prose context, we escape to LaTeX. The
syntax is =`\\latex`=, where the backslash causes us to use LaTeX instead
of Lua. Our TeX backend is LuaTeX, giving arbitrary levels of control from
within a Grimoire-native language.
"]
section_383 -> { header_475 prose_476 prose_477 prose_478}
{rank=same; header_475 prose_476 prose_477 prose_478}

header_475 [label="3 : Comments"]

prose_476 [label="prose"]

prose_477 [label="prose"]

prose_478 [label="prose"]


header_475 -> leaf_479
leaf_479  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Comments"]
prose_476 -> { raw_480}
{rank=same; raw_480}

raw_480 [label="raw"]


raw_480 -> leaf_481
leaf_481  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

In a structure context, you may place line comments. These begin with =--=
and continue to the end of a line.
"]
prose_477 -> { raw_482}
{rank=same; raw_482}

raw_482 [label="raw"]


raw_482 -> leaf_483
leaf_483  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Commenting out a header line, or anything else, causes it to be ignored.
It does *not* result in any subdata being commented out, though it will
in the case of a headline change the ownership of the owned blocks.
"]
prose_478 -> { raw_484}
{rank=same; raw_484}

raw_484 [label="raw"]


raw_484 -> leaf_485
leaf_485  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The  tag =#comment=  in a  valid tag  content position  marks the  owned
region  of  the tagged  block  as  a  comment.  Nothing within  will  be
evaluated or exported, though it will be parsed.
"]
section_384 -> { header_486 prose_487 prose_488 prose_489 prose_490 prose_491 prose_492 prose_493 prose_494 prose_495 prose_496 prose_497 prose_498 prose_499 prose_500 prose_501 prose_502 section_503}
{rank=same; header_486 prose_487 prose_488 prose_489 prose_490 prose_491 prose_492 prose_493 prose_494 prose_495 prose_496 prose_497 prose_498 prose_499 prose_500 prose_501 prose_502 section_503}

header_486 [label="3 : Marks"]

prose_487 [label="prose"]

prose_488 [label="prose"]

prose_489 [label="prose"]

prose_490 [label="prose"]

prose_491 [label="prose"]

prose_492 [label="prose"]

prose_493 [label="prose"]

prose_494 [label="prose"]

prose_495 [label="prose"]

prose_496 [label="prose"]

prose_497 [label="prose"]

prose_498 [label="prose"]

prose_499 [label="prose"]

prose_500 [label="prose"]

prose_501 [label="prose"]

prose_502 [label="prose"]

section_503 [label="section: 559-566"]


header_486 -> leaf_504
leaf_504  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Marks"]
prose_487 -> { raw_505}
{rank=same; raw_505}

raw_505 [label="raw"]


raw_505 -> leaf_506
leaf_506  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Marks provide global semantic categories for Grimoire. They may appear
anywhere, including a prose context, whitespace is required on both sides.
"]
prose_488 -> { raw_507}
{rank=same; raw_507}

raw_507 [label="raw"]


raw_507 -> leaf_508
leaf_508  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We use  a couple kinds  of marks:  =@names= name things,  and =#tags=
categorize them. Tags are semantics, while names are nominal. 
"]
prose_489 -> { raw_509}
{rank=same; raw_509}

raw_509 [label="raw"]


raw_509 -> leaf_510
leaf_510  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Tags that  are boundaries are  paired as  =#tag= and =#/tag=,  plus some
light sugaring. Names are never bounded
"]
prose_490 -> { raw_511}
{rank=same; raw_511}

raw_511 [label="raw"]


raw_511 -> leaf_512
leaf_512  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Marks in the first position own the following line. If there is indentation
below that line, they own that too. This doesn't affect the associativity.
"]
prose_491 -> { raw_513}
{rank=same; raw_513}

raw_513 [label="raw"]


raw_513 -> leaf_514
leaf_514  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Marks may be namespaced, as =@name.subname= or =#tag.sub-tag.sub-tag=.
"]
prose_492 -> { raw_515}
{rank=same; raw_515}

raw_515 [label="raw"]


raw_515 -> leaf_516
leaf_516  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If  you  require   further  namespacing,  =@many/levels/java.class=  and
=#mojo/nation.space/station=  is your  friend. Codices (that is, projects
following the bridge conventions for organization) will use namespacing
in a consistent way. 
"]
prose_493 -> { raw_517}
{rank=same; raw_517}

raw_517 [label="raw"]


raw_517 -> leaf_518
leaf_518  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
As I continue to muse on it, I  can think of no reason why marks couldn't follow
URI syntax,  or at  least mirror  it closely.  Chaining marks  is not  valid, so
=@named@example.com= could be a valid name. 
"]
prose_494 -> { raw_519}
{rank=same; raw_519}

raw_519 [label="raw"]


raw_519 -> leaf_520
leaf_520  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This would mean we could say something like =@file://~/usr/blah=.
"]
prose_495 -> { raw_521}
{rank=same; raw_521}

raw_521 [label="raw"]


raw_521 -> leaf_522
leaf_522  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Or =#!/usr/bin/perl/=...
"]
prose_496 -> { raw_523}
{rank=same; raw_523}

raw_523 [label="raw"]


raw_523 -> leaf_524
leaf_524  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Yes. This  is a good idea.  Let's do this.  It doesn't displace [[*Links][link]]  syntax, it
enhances it. A  URI [[http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax][may not begin with  a slash]] so this is  parse-clean for tags
and names both. Tags aren't intended to  be user extensible in the narrow sense,
but uniformity is a virtue.
"]
prose_497 -> { raw_525}
{rank=same; raw_525}

raw_525 [label="raw"]


raw_525 -> leaf_526
leaf_526  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I don't know why you might want to stick a query in a tag. It's not my
place to know. We just slap a parser on that puppy and continue.
"]
prose_498 -> { raw_527}
{rank=same; raw_527}

raw_527 [label="raw"]


raw_527 -> leaf_528
leaf_528  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Implication: The hash or at should be syntax highlighted a different color
from the tag. I'd say hash and at get the same color, with categories and
symbols getting different ones.
"]
prose_499 -> { raw_529}
{rank=same; raw_529}

raw_529 [label="raw"]


raw_529 -> leaf_530
leaf_530  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Apparently, [[http://blog.nig.gl/post/48802013022/although-parentheses-are-technically-allowed-in][parentheses are allowed in URLs]], but follow the link, they
suck and you should never use them. They play badly with our calling
convention for named structures, and aren't allowed in our schema.
"]
prose_500 -> { raw_531}
{rank=same; raw_531}

raw_531 [label="raw"]


raw_531 -> leaf_532
leaf_532  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's not a real URI anyway, or it can be but it's also allowed to be a legal
fragment without the handle. In our case the assumed handle is =grimoire://=?
"]
prose_501 -> { raw_533}
{rank=same; raw_533}

raw_533 [label="raw"]


raw_533 -> leaf_534
leaf_534  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Not a real URI. But an acceptable fake one.
"]
prose_502 -> { raw_535}
{rank=same; raw_535}

raw_535 [label="raw"]


raw_535 -> leaf_536
leaf_536  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The actual rule for a mark is that it begins with =@= or =#= and is surrounded
by whitespace. Internal parsing of the mark is part of recognition, anything 
not recognized is subsequently ignored. It's still considered a mark for e.g. 
weaving purposes. 


"]
section_503 -> { header_537 prose_538 prose_539}
{rank=same; header_537 prose_538 prose_539}

header_537 [label="4 : Plural Hashtags"]

prose_538 [label="prose"]

prose_539 [label="prose"]


header_537 -> leaf_540
leaf_540  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Plural Hashtags"]
prose_538 -> { raw_541}
{rank=same; raw_541}

raw_541 [label="raw"]


raw_541 -> leaf_542
leaf_542  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

In some cases, such as =#formula= and =#formulas=, a tag may have a
singular or plural form. These are equivalent from the runtimes perspective.
"]
prose_539 -> { raw_543}
{rank=same; raw_543}

raw_543 [label="raw"]


raw_543 -> leaf_544
leaf_544  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The same concept applies to pairs such as =#export= and =#exports=, though
the linguistic distinction is not that of plurality.
"]
section_385 -> { header_545 prose_546 prose_547 prose_548 prose_549 prose_550 prose_551}
{rank=same; header_545 prose_546 prose_547 prose_548 prose_549 prose_550 prose_551}

header_545 [label="3 : Classes"]

prose_546 [label="prose"]

prose_547 [label="prose"]

prose_548 [label="prose"]

prose_549 [label="prose"]

prose_550 [label="prose"]

prose_551 [label="prose"]


header_545 -> leaf_552
leaf_552  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Classes"]
prose_546 -> { raw_553}
{rank=same; raw_553}

raw_553 [label="raw"]


raw_553 -> leaf_554
leaf_554  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Tags are for Grimoire. A category provides runtime semantics,
cooperating with structure groups to provide the API. Names
play the role of a value in languages which provide a
value-variable distinction: every name within a documents reachable
namespace must be globally unique.
"]
prose_547 -> { raw_555}
{rank=same; raw_555}

raw_555 [label="raw"]


raw_555 -> leaf_556
leaf_556  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Specifically names are globally hyperstatic: any redefinition affects
the referent from the moment the parser receives it forward. Redefinitions
are warned against and have no utility, don't do it.
"]
prose_548 -> { raw_557}
{rank=same; raw_557}

raw_557 [label="raw"]


raw_557 -> leaf_558
leaf_558  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Classes are roughly equivalent to categories/hashtags, but
for the user. They have a light semantics similar to their
function in Org.
"]
prose_549 -> { raw_559}
{rank=same; raw_559}

raw_559 [label="raw"]


raw_559 -> leaf_560
leaf_560  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A class is defined as =:Class:= or =:class:= including
=:several:Classes:chained:=.
"]
prose_550 -> { raw_561}
{rank=same; raw_561}

raw_561 [label="raw"]


raw_561 -> leaf_562
leaf_562  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A capital letter means the class inherits onto all subgroups of the block,
a miniscule means the class is associated with the indentation level it is
found within.
"]
prose_551 -> { raw_563}
{rank=same; raw_563}

raw_563 [label="raw"]


raw_563 -> leaf_564
leaf_564  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You know you're programming a computer when class and category have distinct
semantics. At least there are no objects, and only two primitive types,
structure and prose.
"]
section_386 -> { header_565 prose_566 prose_567 structure_568 prose_569 prose_570}
{rank=same; header_565 prose_566 prose_567 structure_568 prose_569 prose_570}

header_565 [label="3 : Links"]

prose_566 [label="prose"]

prose_567 [label="prose"]

structure_568 [label="structure"]

prose_569 [label="prose"]

prose_570 [label="prose"]


header_565 -> leaf_571
leaf_571  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Links"]
prose_566 -> { raw_572}
{rank=same; raw_572}

raw_572 [label="raw"]


raw_572 -> leaf_573
leaf_573  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

There's nothing at all wrong with the syntax or behavior of Babel links.
"]
prose_567 -> { raw_574}
{rank=same; raw_574}

raw_574 [label="raw"]


raw_574 -> leaf_575
leaf_575  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which look like this:
"]
structure_568 -> { hashline_576}
{rank=same; hashline_576}

hashline_576 [label="hashline"]


hashline_576 -> { hashtag_577}
{rank=same; hashtag_577}

hashtag_577 [label="hashtag"]


hashtag_577 -> leaf_578
leaf_578  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_569 -> { raw_579}
{rank=same; raw_579}

raw_579 [label="raw"]


raw_579 -> leaf_580
leaf_580  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We won't support legacy forms of footnoting, such as =[1]=. This applies
to legacy versions of table formulas and list syntax also.
"]
prose_570 -> { raw_581}
{rank=same; raw_581}

raw_581 [label="raw"]


raw_581 -> leaf_582
leaf_582  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In Grimoire  there's one way  to do things.  At least, we  avoid variant
syntax with identical semantics.
"]
section_387 -> { header_583 prose_584 prose_585 prose_586 prose_587 prose_588 structure_589 prose_590 prose_591 prose_592 prose_593 prose_594 prose_595 prose_596 prose_597 section_598}
{rank=same; header_583 prose_584 prose_585 prose_586 prose_587 prose_588 structure_589 prose_590 prose_591 prose_592 prose_593 prose_594 prose_595 prose_596 prose_597 section_598}

header_583 [label="3 : Cookies"]

prose_584 [label="prose"]

prose_585 [label="prose"]

prose_586 [label="prose"]

prose_587 [label="prose"]

prose_588 [label="prose"]

structure_589 [label="structure"]

prose_590 [label="prose"]

prose_591 [label="prose"]

prose_592 [label="prose"]

prose_593 [label="prose"]

prose_594 [label="prose"]

prose_595 [label="prose"]

prose_596 [label="prose"]

prose_597 [label="prose"]

section_598 [label="section: 673-690"]


header_583 -> leaf_599
leaf_599  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Cookies"]
prose_584 -> { raw_600}
{rank=same; raw_600}

raw_600 [label="raw"]


raw_600 -> leaf_601
leaf_601  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

List line contexts (header lines and list lines) may have cookies. A
cookie looks like =[ ]=, it must have contents and a space on both sides.
"]
prose_585 -> { raw_602}
{rank=same; raw_602}

raw_602 [label="raw"]


raw_602 -> leaf_603
leaf_603  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Cookies are valid after the symbol that defines the list line, but before
anything else. They are also valid at the end of a list line, in which
case they are preceded by a space and followed by a newline.
"]
prose_586 -> { raw_604}
{rank=same; raw_604}

raw_604 [label="raw"]


raw_604 -> leaf_605
leaf_605  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Cookies are distinctive in that they may only be applied to list lines.
Most other token-like groups, specifically tags, classes, and inline drawers,
may be embedded into all prose contexts excepting literal strings.
"]
prose_587 -> { raw_606}
{rank=same; raw_606}

raw_606 [label="raw"]


raw_606 -> leaf_607
leaf_607  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Cookies are used similarly to cookies in Org, but with consistent semantics.
A simple cookie set is \"X\" and \" \", the user cycles through them. TODO and
DONE are another option.
"]
prose_588 -> { raw_608}
{rank=same; raw_608}

raw_608 [label="raw"]


raw_608 -> leaf_609
leaf_609  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I don't want cookies to turn into lightweight tables. Still, saying to
the user \"you may have precisely two cookies a line\" is restrictive.
It's not a violation of the [[http://c2.com/cgi/wiki?TwoIsAnImpossibleNumber][\"Two is an Impossible Number\"]] principle,
because they're head and tail. I think this is ugly:
"]
structure_589 -> { hashline_610}
{rank=same; hashline_610}

hashline_610 [label="hashline"]


hashline_610 -> { hashtag_611}
{rank=same; hashtag_611}

hashtag_611 [label="hashtag"]


hashtag_611 -> leaf_612
leaf_612  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_590 -> { raw_613}
{rank=same; raw_613}

raw_613 [label="raw"]


raw_613 -> leaf_614
leaf_614  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You can stick a table in a list. I don't know if I mentioned, it's kind
of an obvious thing, I'll write a unit for it at some point.
"]
prose_591 -> { raw_615}
{rank=same; raw_615}

raw_615 [label="raw"]


raw_615 -> leaf_616
leaf_616  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Still. I can see a case for two on the left. Once you allow two, you allow
n, without excellent reason.
"]
prose_592 -> { raw_617}
{rank=same; raw_617}

raw_617 [label="raw"]


raw_617 -> leaf_618
leaf_618  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
[[*Radio%20cookies][Radio cookies]] must be the leftmost cookie on a line, only one is of course allowed.
I could allow a single-line short form multi-radio-button interface but what
is it, a fancy text slider for some value? No. Any number of ordinary cookies
can follow. Knock yourself out.
"]
prose_593 -> { raw_619}
{rank=same; raw_619}

raw_619 [label="raw"]


raw_619 -> leaf_620
leaf_620  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Anything more than a couple and one should consider a class or a table.
Handrolling data structures is perverse in a markup language, and I'm
still tempted to forbid it.
"]
prose_594 -> { raw_621}
{rank=same; raw_621}

raw_621 [label="raw"]


raw_621 -> leaf_622
leaf_622  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I don't like distinctions without difference. A cookie at the end of a
line is filled by Grimoire, not the user. This mirrors Org's use, which is
to display either a percent or a n/m marker for completion of list items.
The user seeds the cookie, in these cases with =%= or =/=, and the runtime
does the rest.
"]
prose_595 -> { raw_623}
{rank=same; raw_623}

raw_623 [label="raw"]


raw_623 -> leaf_624
leaf_624  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Adding more than one such structure to the tail list would complicate the
reference syntax, which I haven't designed, and again, it's just not necessary.
Grimoire can fill in any data structure, \"n-dimensional end cookie array\"
isn't one we have a compelling need for.
"]
prose_596 -> { raw_625}
{rank=same; raw_625}

raw_625 [label="raw"]


raw_625 -> leaf_626
leaf_626  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Cookies could interact badly with link syntax. I don't think a [bare box]
qualifies as a link in Org, clearly it doesn't, we can follow that notion
and disallow \"[]\" as a filling for cookies.
"]
prose_597 -> { raw_627}
{rank=same; raw_627}

raw_627 [label="raw"]


raw_627 -> leaf_628
leaf_628  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I also think they should be allowed in table cells, which have their own
context which is mostly handwaved right now but is prose++.
"]
section_598 -> { header_629 prose_630 prose_631 prose_632 prose_633}
{rank=same; header_629 prose_630 prose_631 prose_632 prose_633}

header_629 [label="4 : Radio cookies"]

prose_630 [label="prose"]

prose_631 [label="prose"]

prose_632 [label="prose"]

prose_633 [label="prose"]


header_629 -> leaf_634
leaf_634  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Radio cookies"]
prose_630 -> { raw_635}
{rank=same; raw_635}

raw_635 [label="raw"]


raw_635 -> leaf_636
leaf_636  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We have one 'weird cookie'. A radio cookie, which looks like =( )=,
must be present at the head position of list line contexts. All
list lines at the same level of indentation must have one, if one does.
"]
prose_631 -> { raw_637}
{rank=same; raw_637}

raw_637 [label="raw"]


raw_637 -> leaf_638
leaf_638  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Only one is selected at any given time. These would be awkward to add
into tables, to little gain.
"]
prose_632 -> { raw_639}
{rank=same; raw_639}

raw_639 [label="raw"]


raw_639 -> leaf_640
leaf_640  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This comes perilously close to pushing us into the realm of error.
The formatter adds buttons to an entire subtree if one member has it,
and if more than one is ticked off, it warns if possible or removes
all but the first mark encountered. If none are present the first
option is selected.
"]
prose_633 -> { raw_641}
{rank=same; raw_641}

raw_641 [label="raw"]


raw_641 -> leaf_642
leaf_642  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The runtime will not normally build an invalid radio list, but
Grimoire must import plain text.
"]
section_388 -> { header_643 prose_644 structure_645 prose_646 prose_647 prose_648 structure_649 prose_650 prose_651 prose_652}
{rank=same; header_643 prose_644 structure_645 prose_646 prose_647 prose_648 structure_649 prose_650 prose_651 prose_652}

header_643 [label="3 : Drawers"]

prose_644 [label="prose"]

structure_645 [label="structure"]

prose_646 [label="prose"]

prose_647 [label="prose"]

prose_648 [label="prose"]

structure_649 [label="structure"]

prose_650 [label="prose"]

prose_651 [label="prose"]

prose_652 [label="prose"]


header_643 -> leaf_653
leaf_653  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Drawers"]
prose_644 -> { raw_654}
{rank=same; raw_654}

raw_654 [label="raw"]


raw_654 -> leaf_655
leaf_655  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A drawer is a block that's hidden by default. The computer sees it,
the user sees ⦿, or a similar rune.
"]
structure_645 -> { hashline_656}
{rank=same; hashline_656}

hashline_656 [label="hashline"]


hashline_656 -> { hashtag_657}
{rank=same; hashtag_657}

hashtag_657 [label="hashtag"]


hashtag_657 -> leaf_658
leaf_658  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_646 -> { raw_659}
{rank=same; raw_659}

raw_659 [label="raw"]


raw_659 -> leaf_660
leaf_660  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
without opening it. Deleting into an ordinary fold marker opens the fold,
deleting towards a drawer marker skips past it.
"]
prose_647 -> { raw_661}
{rank=same; raw_661}

raw_661 [label="raw"]


raw_661 -> leaf_662
leaf_662  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
=a-drawer=  is  a type,  not  a  name, something  like  =weave=  or =tangle=  in
practice. This may or  may not be supported with a =#weave=  tag. 
"]
prose_648 -> { raw_663}
{rank=same; raw_663}

raw_663 [label="raw"]


raw_663 -> leaf_664
leaf_664  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm not entirely sure how to interact names with drawers, perhaps like this:
"]
structure_649 -> { hashline_665}
{rank=same; hashline_665}

hashline_665 [label="hashline"]


hashline_665 -> { hashtag_666}
{rank=same; hashtag_666}

hashtag_666 [label="hashtag"]


hashtag_666 -> leaf_667
leaf_667  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_650 -> { raw_668}
{rank=same; raw_668}

raw_668 [label="raw"]


raw_668 -> leaf_669
leaf_669  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
should keep it closed unless it's  open, those are the only additional semantics
associated.
"]
prose_651 -> { raw_670}
{rank=same; raw_670}

raw_670 [label="raw"]


raw_670 -> leaf_671
leaf_671  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This lets master wizards embed unobtrusive magic into documents for apprentice
wizards to spell with.
"]
prose_652 -> { raw_672 link_673 raw_674}
{rank=same; raw_672 link_673 raw_674}

raw_672 [label="raw"]

link_673 [label="link: "]

raw_674 [label="raw"]


raw_672 -> leaf_675
leaf_675  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
An inline drawer looks like =:"]
link_673 -> leaf_676
leaf_676  [color=Gray,shape=rectangle,fontname=Inconsolata,label="[[some contents]]"]
raw_674 -> leaf_677
leaf_677  [color=Gray,shape=rectangle,fontname=Inconsolata,label=":=.  As usual when we say \"inline\" it
can be as long as you want. Being anonymous, because untagged, the only semantics
of such a drawer are to hide the contents in source mode. 
"]
section_389 -> { header_678 prose_679 prose_680 prose_681 structure_682 section_683}
{rank=same; header_678 prose_679 prose_680 prose_681 structure_682 section_683}

header_678 [label="3 : Runes"]

prose_679 [label="prose"]

prose_680 [label="prose"]

prose_681 [label="prose"]

structure_682 [label="structure"]

section_683 [label="section: 742-742"]


header_678 -> leaf_684
leaf_684  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Runes"]
prose_679 -> { raw_685}
{rank=same; raw_685}

raw_685 [label="raw"]


raw_685 -> leaf_686
leaf_686  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

After drawers is as good a place to put runes as any.
"]
prose_680 -> { raw_687}
{rank=same; raw_687}

raw_687 [label="raw"]


raw_687 -> leaf_688
leaf_688  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Runes are characters drawn from the pictographic zones of Unicode,
which describe semantic activity within a document.
"]
prose_681 -> { raw_689}
{rank=same; raw_689}

raw_689 [label="raw"]


raw_689 -> leaf_690
leaf_690  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Contra Org, when we have something like the aformentioned:
"]
structure_682 -> { hashline_691}
{rank=same; hashline_691}

hashline_691 [label="hashline"]


hashline_691 -> { hashtag_692}
{rank=same; hashtag_692}

hashtag_692 [label="hashtag"]


hashtag_692 -> leaf_693
leaf_693  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_683 -> { header_694 prose_695 section_696}
{rank=same; header_694 prose_695 section_696}

header_694 [label="1 : Top Header ▼"]

prose_695 [label="prose"]

section_696 [label="section: 743-924"]


header_694 -> leaf_697
leaf_697  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Top Header ▼"]
prose_695 -> { raw_698}
{rank=same; raw_698}

raw_698 [label="raw"]


raw_698 -> leaf_699
leaf_699  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_696 -> { header_700 structure_701 prose_702 prose_703 prose_704 prose_705 prose_706 prose_707 prose_708 section_709 section_710 section_711 section_712 section_713}
{rank=same; header_700 structure_701 prose_702 prose_703 prose_704 prose_705 prose_706 prose_707 prose_708 section_709 section_710 section_711 section_712 section_713}

header_700 [label="2 : Second Header ►"]

structure_701 [label="structure"]

prose_702 [label="prose"]

prose_703 [label="prose"]

prose_704 [label="prose"]

prose_705 [label="prose"]

prose_706 [label="prose"]

prose_707 [label="prose"]

prose_708 [label="prose"]

section_709 [label="section: 772-822"]

section_710 [label="section: 823-843"]

section_711 [label="section: 844-910"]

section_712 [label="section: 911-924"]

section_713 [label="section: 925-963"]


header_700 -> leaf_714
leaf_714  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   ** Second Header ►"]
structure_701 -> { hashline_715}
{rank=same; hashline_715}

hashline_715 [label="hashline"]


hashline_715 -> { hashtag_716}
{rank=same; hashtag_716}

hashtag_716 [label="hashtag"]


hashtag_716 -> leaf_717
leaf_717  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_702 -> { raw_718}
{rank=same; raw_718}

raw_718 [label="raw"]


raw_718 -> leaf_719
leaf_719  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
any transformation we may take. If you load up last Wednesday's
version of something, it will be in last Wednesday's fold state.
"]
prose_703 -> { raw_720}
{rank=same; raw_720}

raw_720 [label="raw"]


raw_720 -> leaf_721
leaf_721  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This lets us have richer folding semantics, like \"don't unfold when
cycling\". It lets us have richer drawer semantics, and so on.
"]
prose_704 -> { raw_722}
{rank=same; raw_722}

raw_722 [label="raw"]


raw_722 -> leaf_723
leaf_723  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We will reserve a number of characters for this purpose, at least
"]
prose_705 -> { raw_724}
{rank=same; raw_724}

raw_724 [label="raw"]


raw_724 -> leaf_725
leaf_725  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
| ▼ |  ► | ⦿ |
    |
"]
prose_706 -> { raw_726}
{rank=same; raw_726}

raw_726 [label="raw"]


raw_726 -> leaf_727
leaf_727  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's legal to delete runes, like anything else. It's also legal to
insert them manually. Neither of these paradigms is typical;
deleting into a rune may or may not cause it to disappear in
normal edit mode.
"]
prose_707 -> { raw_728}
{rank=same; raw_728}

raw_728 [label="raw"]


raw_728 -> leaf_729
leaf_729  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Runes, like absolutely everything in Grimoire, are prose if encountered
in a context where they aren't valid structure.
"]
prose_708 -> { raw_730}
{rank=same; raw_730}

raw_730 [label="raw"]


raw_730 -> leaf_731
leaf_731  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We will most likely reuse runes inside cookies, though it's just as valid
and quite typical to use normal letters or words.
"]
section_709 -> { header_732 prose_733 prose_734 structure_735 prose_736 prose_737 structure_738 structure_739}
{rank=same; header_732 prose_733 prose_734 structure_735 prose_736 prose_737 structure_738 structure_739}

header_732 [label="3 : Lists"]

prose_733 [label="prose"]

prose_734 [label="prose"]

structure_735 [label="structure"]

prose_736 [label="prose"]

prose_737 [label="prose"]

structure_738 [label="structure"]

structure_739 [label="structure"]


header_732 -> leaf_740
leaf_740  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Lists"]
prose_733 -> { raw_741}
{rank=same; raw_741}

raw_741 [label="raw"]


raw_741 -> leaf_742
leaf_742  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Something that irks me about Org is basically historic. It was a TODO
list first, and became a heiarchical document editor later. As a result,
the functions that let you tag, track, and so on, are in the wrong place;
an Org file has to choose whether or not it's a task list or a document,
which doesn't fit the metalanguage paradigm cleanly.
"]
prose_734 -> { raw_743}
{rank=same; raw_743}

raw_743 [label="raw"]


raw_743 -> leaf_744
leaf_744  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A list looks like this:
"]
structure_735 -> { hashline_745}
{rank=same; hashline_745}

hashline_745 [label="hashline"]


hashline_745 -> { hashtag_746}
{rank=same; hashtag_746}

hashtag_746 [label="hashtag"]


hashtag_746 -> leaf_747
leaf_747  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_736 -> { raw_748}
{rank=same; raw_748}

raw_748 [label="raw"]


raw_748 -> leaf_749
leaf_749  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
and we have radio buttons.
"]
prose_737 -> { raw_750}
{rank=same; raw_750}

raw_750 [label="raw"]


raw_750 -> leaf_751
leaf_751  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We also have whitespace lists:
"]
structure_738 -> { hashline_752}
{rank=same; hashline_752}

hashline_752 [label="hashline"]


hashline_752 -> { hashtag_753}
{rank=same; hashtag_753}

hashtag_753 [label="hashtag"]


hashtag_753 -> leaf_754
leaf_754  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_739 -> { hashline_755}
{rank=same; hashline_755}

hashline_755 [label="hashline"]


hashline_755 -> { hashtag_756}
{rank=same; hashtag_756}

hashtag_756 [label="hashtag"]


hashtag_756 -> leaf_757
leaf_757  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_710 -> { header_758 prose_759 prose_760 prose_761 prose_762 prose_763}
{rank=same; header_758 prose_759 prose_760 prose_761 prose_762 prose_763}

header_758 [label="3 : Embedded Data"]

prose_759 [label="prose"]

prose_760 [label="prose"]

prose_761 [label="prose"]

prose_762 [label="prose"]

prose_763 [label="prose"]


header_758 -> leaf_764
leaf_764  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Embedded Data"]
prose_759 -> { raw_765}
{rank=same; raw_765}

raw_765 [label="raw"]


raw_765 -> leaf_766
leaf_766  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Anything found in prose between ={= and =}= is EDN. Note that the
outermost pair of curlies denotes a boundary. ={ foo }= is the symbol
foo, ={ foo bar }= is the symbol *foo* and the symbol *bar*, ={{foo bar}}= is
a map with key *foo* and value *bar*.
"]
prose_760 -> { raw_767}
{rank=same; raw_767}

raw_767 [label="raw"]


raw_767 -> leaf_768
leaf_768  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To quote the [[https://github.com/edn-format/edn][spec]], \"There is no enclosing element at the top level\". The
braces mark the boundaries of the data region.
"]
prose_761 -> { raw_769}
{rank=same; raw_769}

raw_769 [label="raw"]


raw_769 -> leaf_770
leaf_770  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There is a mapping between lists and EDN, the basics of which will be clear
to the astute reader. The non-basics are unclear to the author as well.
"]
prose_762 -> { raw_771}
{rank=same; raw_771}

raw_771 [label="raw"]


raw_771 -> leaf_772
leaf_772  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Unresolved: may data be inlined into prose? What would that even mean?
slap some colors on it in the document? If we want to provide a 'this is
code but not for interpretation' mark, we will, it won't be EDN specific.
Inlining colorized code is not high on my todo list.
"]
prose_763 -> { raw_773}
{rank=same; raw_773}

raw_773 [label="raw"]


raw_773 -> leaf_774
leaf_774  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I don't think you can. Embeds are down here with lists and
tables in 'things you can't inline', for now.
"]
section_711 -> { header_775 prose_776 prose_777 prose_778 prose_779 structure_780 structure_781 structure_782 structure_783 prose_784 prose_785 structure_786 structure_787 structure_788 prose_789 prose_790 prose_791}
{rank=same; header_775 prose_776 prose_777 prose_778 prose_779 structure_780 structure_781 structure_782 structure_783 prose_784 prose_785 structure_786 structure_787 structure_788 prose_789 prose_790 prose_791}

header_775 [label="3 : Tables"]

prose_776 [label="prose"]

prose_777 [label="prose"]

prose_778 [label="prose"]

prose_779 [label="prose"]

structure_780 [label="structure"]

structure_781 [label="structure"]

structure_782 [label="structure"]

structure_783 [label="structure"]

prose_784 [label="prose"]

prose_785 [label="prose"]

structure_786 [label="structure"]

structure_787 [label="structure"]

structure_788 [label="structure"]

prose_789 [label="prose"]

prose_790 [label="prose"]

prose_791 [label="prose"]


header_775 -> leaf_792
leaf_792  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Tables"]
prose_776 -> { raw_793}
{rank=same; raw_793}

raw_793 [label="raw"]


raw_793 -> leaf_794
leaf_794  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The way tables work in Babel is fine and needs little polish. Any modest
improvements we make will be in the face of considerable experience.
"]
prose_777 -> { raw_795}
{rank=same; raw_795}

raw_795 [label="raw"]


raw_795 -> leaf_796
leaf_796  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
For example, I expect there's a way to make multiple literal rows serve
as a single row in existing Org, but I don't know what it is. I'll be
playing around a lot in the coming weeks, I hope.
"]
prose_778 -> { raw_797}
{rank=same; raw_797}

raw_797 [label="raw"]


raw_797 -> leaf_798
leaf_798  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Composability being an overarching goal, we can embed anything in a table
that we would put elsewhere.
"]
prose_779 -> { raw_799}
{rank=same; raw_799}

raw_799 [label="raw"]


raw_799 -> leaf_800
leaf_800  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Looks something like this:
"]
structure_780 -> { hashline_801}
{rank=same; hashline_801}

hashline_801 [label="hashline"]


hashline_801 -> { hashtag_802}
{rank=same; hashtag_802}

hashtag_802 [label="hashtag"]


hashtag_802 -> leaf_803
leaf_803  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_781 -> { hashline_804}
{rank=same; hashline_804}

hashline_804 [label="hashline"]


hashline_804 -> { hashtag_805}
{rank=same; hashtag_805}

hashtag_805 [label="hashtag"]


hashtag_805 -> leaf_806
leaf_806  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_782 -> { hashline_807}
{rank=same; hashline_807}

hashline_807 [label="hashline"]


hashline_807 -> { hashtag_808}
{rank=same; hashtag_808}

hashtag_808 [label="hashtag"]


hashtag_808 -> leaf_809
leaf_809  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_783 -> { hashline_810}
{rank=same; hashline_810}

hashline_810 [label="hashline"]


hashline_810 -> { hashtag_811}
{rank=same; hashtag_811}

hashtag_811 [label="hashtag"]


hashtag_811 -> leaf_812
leaf_812  [color=Gray,shape=rectangle,fontname=Inconsolata,label="formulas"]
prose_784 -> { raw_813}
{rank=same; raw_813}

raw_813 [label="raw"]


raw_813 -> leaf_814
leaf_814  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A subtle point of parsing I'm not sure is correct is =#formulas -=
or =- #formulas=. I feel like by normal associativity the latter
attaches the tag to the list, then nothing to the tag,
since the rule is a tag preceded only by whitespace owns the line
after it and indentations below it. The tag doesn't affect the indentation level
of the =-=, which could be confusing but won't be.
"]
prose_785 -> { raw_815}
{rank=same; raw_815}

raw_815 [label="raw"]


raw_815 -> leaf_816
leaf_816  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We should be able to tag tables like this:
"]
structure_786 -> { hashline_817}
{rank=same; hashline_817}

hashline_817 [label="hashline"]


hashline_817 -> { hashtag_818}
{rank=same; hashtag_818}

hashtag_818 [label="hashtag"]


hashtag_818 -> leaf_819
leaf_819  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_787 -> { hashline_820}
{rank=same; hashline_820}

hashline_820 [label="hashline"]


hashline_820 -> { hashtag_821}
{rank=same; hashtag_821}

hashtag_821 [label="hashtag"]


hashtag_821 -> leaf_822
leaf_822  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_788 -> { hashline_823}
{rank=same; hashline_823}

hashline_823 [label="hashline"]


hashline_823 -> { hashtag_824}
{rank=same; hashtag_824}

hashtag_824 [label="hashtag"]


hashtag_824 -> leaf_825
leaf_825  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_789 -> { raw_826}
{rank=same; raw_826}

raw_826 [label="raw"]


raw_826 -> leaf_827
leaf_827  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Totally okay in this context, doesn't trigger Nim rules because the table
associates to the tag anyway.
"]
prose_790 -> { raw_828}
{rank=same; raw_828}

raw_828 [label="raw"]


raw_828 -> leaf_829
leaf_829  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This gives us a nice left gutter which I propose we can use in various ways.
"]
prose_791 -> { raw_830}
{rank=same; raw_830}

raw_830 [label="raw"]


raw_830 -> leaf_831
leaf_831  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This section can get much longer. Generalizing how tables work is incredibly
powerful. My dream is to embed APL into Grimoire. Give me an excuse to
finally learn it!
"]
section_712 -> { header_832 prose_833 prose_834 prose_835 prose_836 prose_837}
{rank=same; header_832 prose_833 prose_834 prose_835 prose_836 prose_837}

header_832 [label="3 : Clocks"]

prose_833 [label="prose"]

prose_834 [label="prose"]

prose_835 [label="prose"]

prose_836 [label="prose"]

prose_837 [label="prose"]


header_832 -> leaf_838
leaf_838  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Clocks"]
prose_833 -> { raw_839}
{rank=same; raw_839}

raw_839 [label="raw"]


raw_839 -> leaf_840
leaf_840  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

I think timestamps are just a drawer you put a timestamp in.
"]
prose_834 -> { raw_841}
{rank=same; raw_841}

raw_841 [label="raw"]


raw_841 -> leaf_842
leaf_842  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That drawer can collapse and look like ⏱.
"]
prose_835 -> { raw_843}
{rank=same; raw_843}

raw_843 [label="raw"]


raw_843 -> leaf_844
leaf_844  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Or we can collapse it into something from the set containing 🕞.
"]
prose_836 -> { raw_845}
{rank=same; raw_845}

raw_845 [label="raw"]


raw_845 -> leaf_846
leaf_846  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which normal Emacs doesn't display. I really need to go Japanese soon.
"]
prose_837 -> { raw_847}
{rank=same; raw_847}

raw_847 [label="raw"]


raw_847 -> leaf_848
leaf_848  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
But it would be just adorable to have a little clock representing the timestamp.
Emoji are quirky but the set contains useful icons, and it's Unicode.
Grimoire supports Unicode.
"]
section_713 -> { header_849 prose_850 prose_851 prose_852 prose_853 section_854 section_855}
{rank=same; header_849 prose_850 prose_851 prose_852 prose_853 section_854 section_855}

header_849 [label="3 : Code"]

prose_850 [label="prose"]

prose_851 [label="prose"]

prose_852 [label="prose"]

prose_853 [label="prose"]

section_854 [label="section: 946-963"]

section_855 [label="section: 964-1084"]


header_849 -> leaf_856
leaf_856  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Code"]
prose_850 -> { raw_857}
{rank=same; raw_857}

raw_857 [label="raw"]


raw_857 -> leaf_858
leaf_858  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The place where it all comes together.
"]
prose_851 -> { raw_859}
{rank=same; raw_859}

raw_859 [label="raw"]


raw_859 -> leaf_860
leaf_860  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire has a servant language, Lua by default, but this
is of course configurable. Eventually we'll write Clu,
it's a race to see which project is finished first but they
have common dependencies, surprise, surprise.
"]
prose_852 -> { raw_861}
{rank=same; raw_861}

raw_861 [label="raw"]


raw_861 -> leaf_862
leaf_862  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Code and data are yin and yang in Grimoire. Code embedded in
documents is executed in various ways and times; comments within
code blocks are themselves in Grimoire data format, and so on.
"]
prose_853 -> { raw_863}
{rank=same; raw_863}

raw_863 [label="raw"]


raw_863 -> leaf_864
leaf_864  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Given a single language Grimoire text, we can perform a mechanical
figure-ground reversal, such that data blocks become comments and
code blocks become live. We have many more sophisticated weave and
tangle operations, but this is a designed-in property that will prove
handy: sometimes you want to take code, org it up, and then flip it
into a literate context. Upgrade path for existing codebases.

"]
section_854 -> { header_865 prose_866 structure_867 prose_868 prose_869}
{rank=same; header_865 prose_866 structure_867 prose_868 prose_869}

header_865 [label="4 : Inline Code"]

prose_866 [label="prose"]

structure_867 [label="structure"]

prose_868 [label="prose"]

prose_869 [label="prose"]


header_865 -> leaf_870
leaf_870  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Inline Code"]
prose_866 -> { raw_871}
{rank=same; raw_871}

raw_871 [label="raw"]


raw_871 -> leaf_872
leaf_872  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Inline code is written =`4 + 5`=. It executes in something similar to
:function mode in Babel, the call is as though it were wrapped in a function
call that looks like:
"]
structure_867 -> { hashline_873}
{rank=same; hashline_873}

hashline_873 [label="hashline"]


hashline_873 -> { hashtag_874}
{rank=same; hashtag_874}

hashtag_874 [label="hashtag"]


hashtag_874 -> leaf_875
leaf_875  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_868 -> { raw_876}
{rank=same; raw_876}

raw_876 [label="raw"]


raw_876 -> leaf_877
leaf_877  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
maintaining state between calls.
"]
prose_869 -> { raw_878}
{rank=same; raw_878}

raw_878 [label="raw"]


raw_878 -> leaf_879
leaf_879  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Anything named exists as a data structure in the helper language. This makes it easy to
refer to a block that contains a self-reference, so these are stored in a cycle-safe way.
"]
section_855 -> { header_880 prose_881 prose_882 structure_883 structure_884 prose_885 structure_886 structure_887 prose_888 codeblock_889 structure_890 prose_891 prose_892 prose_893 codeblock_894 codeblock_895 codeblock_896 structure_897 structure_898 codeblock_899 structure_900 structure_901 prose_902 prose_903 prose_904 prose_905 structure_906 prose_907 prose_908 prose_909 codeblock_910 section_911}
{rank=same; header_880 prose_881 prose_882 structure_883 structure_884 prose_885 structure_886 structure_887 prose_888 codeblock_889 structure_890 prose_891 prose_892 prose_893 codeblock_894 codeblock_895 codeblock_896 structure_897 structure_898 codeblock_899 structure_900 structure_901 prose_902 prose_903 prose_904 prose_905 structure_906 prose_907 prose_908 prose_909 codeblock_910 section_911}

header_880 [label="4 : Code Blocks"]

prose_881 [label="prose"]

prose_882 [label="prose"]

structure_883 [label="structure"]

structure_884 [label="structure"]

prose_885 [label="prose"]

structure_886 [label="structure"]

structure_887 [label="structure"]

prose_888 [label="prose"]

codeblock_889 [label="code block 993-995"]

structure_890 [label="structure"]

prose_891 [label="prose"]

prose_892 [label="prose"]

prose_893 [label="prose"]

codeblock_894 [label="code block 1009-1011"]

codeblock_895 [label="code block 1017-1019"]

codeblock_896 [label="code block 1023-1025"]

structure_897 [label="structure"]

structure_898 [label="structure"]

codeblock_899 [label="code block 1033-1035"]

structure_900 [label="structure"]

structure_901 [label="structure"]

prose_902 [label="prose"]

prose_903 [label="prose"]

prose_904 [label="prose"]

prose_905 [label="prose"]

structure_906 [label="structure"]

prose_907 [label="prose"]

prose_908 [label="prose"]

prose_909 [label="prose"]

codeblock_910 [label="code block 1078-1080"]

section_911 [label="section: 1085-1155"]


header_880 -> leaf_912
leaf_912  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Code Blocks"]
prose_881 -> { raw_913}
{rank=same; raw_913}

raw_913 [label="raw"]


raw_913 -> leaf_914
leaf_914  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The =`inline`= syntax works like the rest, you may use any number of backticks to enclose a form.
"]
prose_882 -> { raw_915}
{rank=same; raw_915}

raw_915 [label="raw"]


raw_915 -> leaf_916
leaf_916  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Something like:
"]
structure_883 -> { hashline_917}
{rank=same; hashline_917}

hashline_917 [label="hashline"]


hashline_917 -> { hashtag_918}
{rank=same; hashtag_918}

hashtag_918 [label="hashtag"]


hashtag_918 -> leaf_919
leaf_919  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_884 -> { hashline_920}
{rank=same; hashline_920}

hashline_920 [label="hashline"]


hashline_920 -> { hashtag_921}
{rank=same; hashtag_921}

hashtag_921 [label="hashtag"]


hashtag_921 -> leaf_922
leaf_922  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_885 -> { raw_923}
{rank=same; raw_923}

raw_923 [label="raw"]


raw_923 -> leaf_924
leaf_924  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
it is evaluated when referenced. This:
"]
structure_886 -> { hashline_925}
{rank=same; hashline_925}

hashline_925 [label="hashline"]


hashline_925 -> { hashtag_926}
{rank=same; hashtag_926}

hashtag_926 [label="hashtag"]


hashtag_926 -> leaf_927
leaf_927  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_887 -> { hashline_928}
{rank=same; hashline_928}

hashline_928 [label="hashline"]


hashline_928 -> { hashtag_929}
{rank=same; hashtag_929}

hashtag_929 [label="hashtag"]


hashtag_929 -> leaf_930
leaf_930  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_888 -> { raw_931}
{rank=same; raw_931}

raw_931 [label="raw"]


raw_931 -> leaf_932
leaf_932  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Separated code blocks use special tags:
"]
codeblock_889 -> leaf_933
leaf_933  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
structure_890 -> { hashline_934}
{rank=same; hashline_934}

hashline_934 [label="hashline"]


hashline_934 -> { hashtag_935}
{rank=same; hashtag_935}

hashtag_935 [label="hashtag"]


hashtag_935 -> leaf_936
leaf_936  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_891 -> { raw_937}
{rank=same; raw_937}

raw_937 [label="raw"]


raw_937 -> leaf_938
leaf_938  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
nesting apply. As indeed they might in a Grimoire code block.
"]
prose_892 -> { raw_939}
{rank=same; raw_939}

raw_939 [label="raw"]


raw_939 -> leaf_940
leaf_940  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We need a good runtime. Playing the Inception game
with Grimoire should be an amusing headache, not a dog-slow
system killer.
"]
prose_893 -> { raw_941}
{rank=same; raw_941}

raw_941 [label="raw"]


raw_941 -> leaf_942
leaf_942  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
They may be named like anything else:
"]
codeblock_894 -> leaf_943
leaf_943  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
codeblock_895 -> leaf_944
leaf_944  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
codeblock_896 -> leaf_945
leaf_945  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return 4 + 5"]
structure_897 -> { hashline_946}
{rank=same; hashline_946}

hashline_946 [label="hashline"]


hashline_946 -> { hashtag_947}
{rank=same; hashtag_947}

hashtag_947 [label="hashtag"]


hashtag_947 -> leaf_948
leaf_948  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_898 -> { handleline_949}
{rank=same; handleline_949}

handleline_949 [label="handleline"]


handleline_949 -> { handle_950}
{rank=same; handle_950}

handle_950 [label="handle"]


handle_950 -> leaf_951
leaf_951  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nine"]
codeblock_899 -> leaf_952
leaf_952  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return 4 + 5"]
structure_900 -> { hashline_953}
{rank=same; hashline_953}

hashline_953 [label="hashline"]


hashline_953 -> { hashtag_954}
{rank=same; hashtag_954}

hashtag_954 [label="hashtag"]


hashtag_954 -> leaf_955
leaf_955  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_901 -> { hashline_956}
{rank=same; hashline_956}

hashline_956 [label="hashline"]


hashline_956 -> { hashtag_957}
{rank=same; hashtag_957}

hashtag_957 [label="hashtag"]


hashtag_957 -> leaf_958
leaf_958  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_902 -> { raw_959}
{rank=same; raw_959}

raw_959 [label="raw"]


raw_959 -> leaf_960
leaf_960  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
marks an anonymous result. =#@nine->= is the automatically generated tag for
the return value of the block named =@nine=, adding =@nine()= to a prose block will
add the number 9 to the weave at that location. *bridge* will either display the result,
the call, or both, configurably, when editing the source, with syntax-highlighting to 
enforce the distinction. 
"]
prose_903 -> { raw_961}
{rank=same; raw_961}

raw_961 [label="raw"]


raw_961 -> leaf_962
leaf_962  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Code blocks may be indented as any other blocks, with the associated owership
rules. Code blocks so indented have a logical start equal to their level of
indentation, which is to say the program being called will not see indentation
that is proper to the Grimoire document.
"]
prose_904 -> { raw_963}
{rank=same; raw_963}

raw_963 [label="raw"]


raw_963 -> leaf_964
leaf_964  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Code blocks may be placed inside lists, as tables may be, but may not be
explicitly placed inside tables.
"]
prose_905 -> { raw_965}
{rank=same; raw_965}

raw_965 [label="raw"]


raw_965 -> leaf_966
leaf_966  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You may insert the result of a named code block in the data context
by simply saying =@a-named-block()=. If there are variables, you may pass
them, =@a-named-block(23, true)= or if you wish, by name:
"]
structure_906 -> { hashline_967}
{rank=same; hashline_967}

hashline_967 [label="hashline"]


hashline_967 -> { hashtag_968}
{rank=same; hashtag_968}

hashtag_968 [label="hashtag"]


hashtag_968 -> leaf_969
leaf_969  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prose_907 -> { raw_970}
{rank=same; raw_970}

raw_970 [label="raw"]


raw_970 -> leaf_971
leaf_971  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Within a formula applied to a table, it is valid to use the description
syntax for a variable to supply an argument to a function.
"]
prose_908 -> { raw_972}
{rank=same; raw_972}

raw_972 [label="raw"]


raw_972 -> leaf_973
leaf_973  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There will be further syntax involved in building up the line that
begins a code block. It's considered good form to assign complex
code block headers into distinct tags, and use those, rather than
being explicit and repeating yourself or hiding file-local defaults
in drawers.
"]
prose_909 -> { raw_974}
{rank=same; raw_974}

raw_974 [label="raw"]


raw_974 -> leaf_975
leaf_975  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So we prefer something like
"]
codeblock_910 -> leaf_976
leaf_976  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
section_911 -> { header_977 prose_978 section_979 section_980}
{rank=same; header_977 prose_978 section_979 section_980}

header_977 [label="1 : Runtime"]

prose_978 [label="prose"]

section_979 [label="section: 1089-1123"]

section_980 [label="section: 1156-1200"]


header_977 -> leaf_981
leaf_981  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Runtime"]
prose_978 -> { raw_982}
{rank=same; raw_982}

raw_982 [label="raw"]


raw_982 -> leaf_983
leaf_983  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Here, we begin to explore the interactions Grimoire is capable of.
"]
section_979 -> { header_984 prose_985 prose_986 prose_987 prose_988 prose_989 prose_990 prose_991 prose_992 section_993}
{rank=same; header_984 prose_985 prose_986 prose_987 prose_988 prose_989 prose_990 prose_991 prose_992 section_993}

header_984 [label="2 : Literate or Live?"]

prose_985 [label="prose"]

prose_986 [label="prose"]

prose_987 [label="prose"]

prose_988 [label="prose"]

prose_989 [label="prose"]

prose_990 [label="prose"]

prose_991 [label="prose"]

prose_992 [label="prose"]

section_993 [label="section: 1124-1155"]


header_984 -> leaf_994
leaf_994  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Literate or Live?"]
prose_985 -> { raw_995}
{rank=same; raw_995}

raw_995 [label="raw"]


raw_995 -> leaf_996
leaf_996  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Babel is descended from the tradition of [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]], and
Grimoire inherits this from Babel.
"]
prose_986 -> { raw_997}
{rank=same; raw_997}

raw_997 [label="raw"]


raw_997 -> leaf_998
leaf_998  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is capable of producing code and documentation in the
classic literate style. This is not the aim of Grimoire: it is
a metalanguage, for working with prose, data, and code in an
integrated fashion.
"]
prose_987 -> { raw_999}
{rank=same; raw_999}

raw_999 [label="raw"]


raw_999 -> leaf_1000
leaf_1000  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
What a compiler is to a REPL, literate programming is to living
documents.
"]
prose_988 -> { raw_1001}
{rank=same; raw_1001}

raw_1001 [label="raw"]


raw_1001 -> leaf_1002
leaf_1002  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In a literate programming context, we have source, which integrates
code and documentation. The source is then woven into documentation,
and tangled into code. Both are compiled, one is printed, one is run.
"]
prose_989 -> { raw_1003}
{rank=same; raw_1003}

raw_1003 [label="raw"]


raw_1003 -> leaf_1004
leaf_1004  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The word 'printed' sounds somewhat archaic, no? The number of tools
Donald Knuth had to write just to write the tools he wanted to write,
and tool the writings he wanted to tool, is simply staggering.
"]
prose_990 -> { raw_1005}
{rank=same; raw_1005}

raw_1005 [label="raw"]


raw_1005 -> leaf_1006
leaf_1006  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Traces of that legacy remain in Grimoire. Like Babel, we allow for
LaTeX embedding, with the sugar =`\\latex`=. Starting Lua code with
a backslash is illegal, starting Clu code with a backslash is also
illegal.
"]
prose_991 -> { raw_1007}
{rank=same; raw_1007}

raw_1007 [label="raw"]


raw_1007 -> leaf_1008
leaf_1008  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
For a Grimoire document to be printed, realistically, in today's world,
it will be translated to LaTeX, hence to PDF, sent off to a print
on demand company, and drop shipped. Some documents may in fact
make this journey, because why not? We aren't oriented around it.
"]
prose_992 -> { raw_1009}
{rank=same; raw_1009}

raw_1009 [label="raw"]


raw_1009 -> leaf_1010
leaf_1010  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The basic flow in a Grimoire context is one of excursion and return.
We have tangling and weaving, but also unraveling, where actions taken
within the weave or tangle are integrated back into the source document.
"]
section_993 -> { header_1011 prose_1012 prose_1013 prose_1014 prose_1015 prose_1016 prose_1017}
{rank=same; header_1011 prose_1012 prose_1013 prose_1014 prose_1015 prose_1016 prose_1017}

header_1011 [label="3 : Unraveling the Mystery"]

prose_1012 [label="prose"]

prose_1013 [label="prose"]

prose_1014 [label="prose"]

prose_1015 [label="prose"]

prose_1016 [label="prose"]

prose_1017 [label="prose"]


header_1011 -> leaf_1018
leaf_1018  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Unraveling the Mystery"]
prose_1012 -> { raw_1019}
{rank=same; raw_1019}

raw_1019 [label="raw"]


raw_1019 -> leaf_1020
leaf_1020  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

What's unraveling? When I picture Donald Knuth writing literate code,
I picture him with a notebook, writing free-flowing algorithms in a
fashion he refined his entire career. I imagine him carefully transcribing
into Web, running the compiler, going for a stroll around the Stanford
campus, and examining the changes upon his return.
"]
prose_1013 -> { raw_1021}
{rank=same; raw_1021}

raw_1021 [label="raw"]


raw_1021 -> leaf_1022
leaf_1022  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
On the days, and they did happen, when his program was in a state of error,
I picture him returning to his notebook first. While thinking. Perhaps
playing the organ for an hour or two, to relax. He would then correct the
notebook, then the code, then the program, which would be correct now,
most of the time.
"]
prose_1014 -> { raw_1023}
{rank=same; raw_1023}

raw_1023 [label="raw"]


raw_1023 -> leaf_1024
leaf_1024  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm making that all up. But I'd wager I'm not far off the mark. We
don't work like that and most of us can't.
"]
prose_1015 -> { raw_1025}
{rank=same; raw_1025}

raw_1025 [label="raw"]


raw_1025 -> leaf_1026
leaf_1026  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A tangle is named that because the mapping between it and the source
can be non-trivial. It's quite possible to make it undecidable what to
do with edits to the tangle. it's also possible to move edits from the tangle
back into the source, in most cases, if we structure things well.
"]
prose_1016 -> { raw_1027}
{rank=same; raw_1027}

raw_1027 [label="raw"]


raw_1027 -> leaf_1028
leaf_1028  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Donald Knuth was unable to print a book that would alter his code. I'm
sure he'd have been delighted to have the ability. Our weaves can easily
be living documents, through in-browser and server side empowerment.
Those changes, too, should make it back into the source.
"]
prose_1017 -> { raw_1029}
{rank=same; raw_1029}

raw_1029 [label="raw"]


raw_1029 -> leaf_1030
leaf_1030  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Ultimately I imagine many people will prefer to edit and run their
Grimoire documents entirely from a weave that provides a bit of the
ol' WYSIWYG to the experience. Well and good for them, I have my own
view of Heaven, and it isn't Heaven if we don't all fit.
"]
section_980 -> { header_1031 prose_1032 prose_1033 prose_1034 prose_1035 section_1036 section_1037}
{rank=same; header_1031 prose_1032 prose_1033 prose_1034 prose_1035 section_1036 section_1037}

header_1031 [label="2 : Source, Tangle and Weave"]

prose_1032 [label="prose"]

prose_1033 [label="prose"]

prose_1034 [label="prose"]

prose_1035 [label="prose"]

section_1036 [label="section: 1173-1200"]

section_1037 [label="section: 1201-1219"]


header_1031 -> leaf_1038
leaf_1038  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Source, Tangle and Weave"]
prose_1032 -> { raw_1039}
{rank=same; raw_1039}

raw_1039 [label="raw"]


raw_1039 -> leaf_1040
leaf_1040  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These classic concepts from literate programming are central to
the Grimoire paradigm.
"]
prose_1033 -> { raw_1041}
{rank=same; raw_1041}

raw_1041 [label="raw"]


raw_1041 -> leaf_1042
leaf_1042  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In Grimoire, something like a PDF is not a true weave. It is a product;
much like an image or data derived from a simulation, it is regenerated
when necessary but has no further connection to the Grimoire environment.
"]
prose_1034 -> { raw_1043}
{rank=same; raw_1043}

raw_1043 [label="raw"]


raw_1043 -> leaf_1044
leaf_1044  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Our first section discusses the format of Grimoire source code. Like Babel,
unlike Web and descendants, it is self-tangling. Grimoire will be tightly
integrated and purpose-built for this task, operating at a REPL+ level.
"]
prose_1035 -> { raw_1045}
{rank=same; raw_1045}

raw_1045 [label="raw"]


raw_1045 -> leaf_1046
leaf_1046  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We still wish to use it to compile programs written in appropriate languages.
These languages needn't be educated in the ways of Grimoire, imposing this
requirement would be so onerous as to block adoption.
"]
section_1036 -> { header_1047 prose_1048 prose_1049 prose_1050 prose_1051 prose_1052}
{rank=same; header_1047 prose_1048 prose_1049 prose_1050 prose_1051 prose_1052}

header_1047 [label="3 : Unraveling the Tangle"]

prose_1048 [label="prose"]

prose_1049 [label="prose"]

prose_1050 [label="prose"]

prose_1051 [label="prose"]

prose_1052 [label="prose"]


header_1047 -> leaf_1053
leaf_1053  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Unraveling the Tangle"]
prose_1048 -> { raw_1054}
{rank=same; raw_1054}

raw_1054 [label="raw"]


raw_1054 -> leaf_1055
leaf_1055  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Babel offers limited facilities for working within source blocks. What it
doesn't offer is the critical 'unravel' operation, which takes changes to
the tangle and integrates them back into the weave.
"]
prose_1049 -> { raw_1056}
{rank=same; raw_1056}

raw_1056 [label="raw"]


raw_1056 -> leaf_1057
leaf_1057  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is a partially-solved problem, with Babel able to put comment tags into
the source which allow Emacs to jump back into your actual source from
errors in the tangle.
"]
prose_1050 -> { raw_1058}
{rank=same; raw_1058}

raw_1058 [label="raw"]


raw_1058 -> leaf_1059
leaf_1059  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is just not good enough. For any number of reasons, we need to be able
to unravel. I'll cite one: Converting existing codebases over to literacy.
The first step is to recreate the existing program on a source-line-identical
level. The entire existing developer base is familiar with the program already
and isn't going to want to start editing a bunch of Grimoire. They can most
likely be induced to accept readable metadata, and that's it.
"]
prose_1051 -> { raw_1060}
{rank=same; raw_1060}

raw_1060 [label="raw"]


raw_1060 -> leaf_1061
leaf_1061  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That's all we need. Code is in one of three categories: either it is a single
literal copy from source, it's one of several copies from source, or
it's generated code that's dependent on information in the source.
"]
prose_1052 -> { raw_1062}
{rank=same; raw_1062}

raw_1062 [label="raw"]


raw_1062 -> leaf_1063
leaf_1063  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We incorporate all changes to the former automatically when we unravel.
Changes to a single version of multiple copies prompts user interaction: do
you want to embed the change as its own source block, propagate it to each
instance, or decline the merge? Changes to generated code are simply
forbidden. If one is doing generation on the code base, working from
the weave is the more comfortable approach.
"]
section_1037 -> { header_1064 prose_1065 prose_1066 prose_1067 prose_1068}
{rank=same; header_1064 prose_1065 prose_1066 prose_1067 prose_1068}

header_1064 [label="3 : Backweaving"]

prose_1065 [label="prose"]

prose_1066 [label="prose"]

prose_1067 [label="prose"]

prose_1068 [label="prose"]


header_1064 -> leaf_1069
leaf_1069  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Backweaving"]
prose_1065 -> { raw_1070}
{rank=same; raw_1070}

raw_1070 [label="raw"]


raw_1070 -> leaf_1071
leaf_1071  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

An analogous operation is backweaving.
"]
prose_1066 -> { raw_1072}
{rank=same; raw_1072}

raw_1072 [label="raw"]


raw_1072 -> leaf_1073
leaf_1073  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A weave in Grimoire is an HTML/CSS/JS document. In other words, a program.
The weave is much closer akin to the source than any tangle. Any Grimoire
program can have a weave view, though it isn't necessary; many will have
no tangle at all, containing the functionality within Grimoire.
"]
prose_1067 -> { raw_1074}
{rank=same; raw_1074}

raw_1074 [label="raw"]


raw_1074 -> leaf_1075
leaf_1075  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The weave may therefore be manipulated, and we need some way to reflect
those changes back into the source. This can't be automated in a general
way. What we're left with is an EDN protocol for exchanging information
to update the weave in cooperation with some server logic and git.
"]
prose_1068 -> { raw_1076}
{rank=same; raw_1076}

raw_1076 [label="raw"]


raw_1076 -> leaf_1077
leaf_1077  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So, could you write the server logic for a site as a literate program,
push it to a server that tangles and weaves it, and use the source
and Grimoire/bridge as the sysadmin view? I bet you could, it might
even be fairly popular.
"]
section_335 -> { header_1078 prose_1079 prose_1080 prose_1081 section_1082}
{rank=same; header_1078 prose_1079 prose_1080 prose_1081 section_1082}

header_1078 [label="4 : Zero-header tag"]

prose_1079 [label="prose"]

prose_1080 [label="prose"]

prose_1081 [label="prose"]

section_1082 [label="section: 420-421"]


header_1078 -> leaf_1083
leaf_1083  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Zero-header tag"]
prose_1079 -> { raw_1084}
{rank=same; raw_1084}

raw_1084 [label="raw"]


raw_1084 -> leaf_1085
leaf_1085  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The special [[*Tags][tag]] =#*=, which is only meaningful at the top of a document,
 indicates a 'zero header'. This lets you use the one-star level as a
series within a single document.
"]
prose_1080 -> { raw_1086}
{rank=same; raw_1086}

raw_1086 [label="raw"]


raw_1086 -> leaf_1087
leaf_1087  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The related tag =#meta*= must be followed by a space and any number of
stars. This indicates a meta-level for the entire under-tree, that
exists somewhere else. Further semantics may be provided.
"]
prose_1081 -> { raw_1088}
{rank=same; raw_1088}

raw_1088 [label="raw"]


raw_1088 -> leaf_1089
leaf_1089  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This section belongs in some further API section.
"]
section_1082 -> { header_1090 prose_1091}
{rank=same; header_1090 prose_1091}

header_1090 [label="5 : TODO Move to API Section"]

prose_1091 [label="prose"]


header_1090 -> leaf_1092
leaf_1092  [color=Gray,shape=rectangle,fontname=Inconsolata,label="***** TODO Move to API Section"]
prose_1091 -> { raw_1093}
{rank=same; raw_1093}

raw_1093 [label="raw"]


raw_1093 -> leaf_1094
leaf_1094  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]

}
