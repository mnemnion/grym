digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 1219"]


doc_0 -> { section_1 section_2}
{rank=same; section_1 section_2}

section_1 [label="section: 1-3"]

section_2 [label="section: 34-338"]


section_1 -> { header_3 block_4 block_5 section_6}
{rank=same; header_3 block_4 block_5 section_6}

header_3 [label="0 : "]

block_4 [label="block 1-1"]

block_5 [label="block 2-3"]

section_6 [label="section: 4-33"]


block_4 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_5 -> { structure_8 structure_9}
{rank=same; structure_8 structure_9}

structure_8 [label="structure"]

structure_9 [label="structure"]


structure_8 -> { hashline_10}
{rank=same; hashline_10}

hashline_10 [label="hashline"]


hashline_10 -> { hashtag_11}
{rank=same; hashtag_11}

hashtag_11 [label="hashtag"]


hashtag_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_9 -> { hashline_13}
{rank=same; hashline_13}

hashline_13 [label="hashline"]


hashline_13 -> { hashtag_14}
{rank=same; hashtag_14}

hashtag_14 [label="hashtag"]


hashtag_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_5 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_6 -> { header_17 block_18 block_19 block_20 block_21 block_22 block_23 block_24 block_25 block_26}
{rank=same; header_17 block_18 block_19 block_20 block_21 block_22 block_23 block_24 block_25 block_26}

header_17 [label="1 : Introduction"]

block_18 [label="block 4-7"]

block_19 [label="block 8-9"]

block_20 [label="block 10-12"]

block_21 [label="block 13-16"]

block_22 [label="block 17-19"]

block_23 [label="block 20-23"]

block_24 [label="block 24-26"]

block_25 [label="block 27-28"]

block_26 [label="block 29-33"]


block_18 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is a response to Babel.
"]
block_19 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Babel is simultaneously a kludge and the most potentially powerful language in existence.
"]
block_20 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Babel is a metalanguage. The structure of Org mode lets the user weave together code into a
living document, in a flexible, powerful way.
"]
block_21 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The name is charmingly apt. Babel exists at the top of a tower of abstractions that is teetering
on the verge of collapse. Org-mode is an extension of outline mode, which was a simple tree
editor task list.
"]
block_22 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Various users bolted stuff on, because that's how emacs grows, you bolt stuff onto it and it
continues to function because it's [[http://lispers.org/][made with alien technology]].
"]
block_23 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The problem with Babel is more than the syntax being clunky, though that's a problem. The issue is
more profoundly that Babel is built on Org, which is built on emacs. It's a language, yes,
parsers exist for other platforms. But as a runtime, it isn't portable without a lot of effort.
"]
block_24 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="So much so, that we get a chance to start over. It's roughly as difficult to write Grimoire as it would be to
reimplement Babel in, say, Sublime.
"]
block_25 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In the process, we can:
"]
block_26 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  - streamline concepts, making them more orthogonal
  - clean up the clunkiness in the grammar
  - build a toolchain that will let us write magic spells in any number of languages, amassing a powerful
    collection of same. A grimoire, if you will: a living book in which magic is both written and performed.
"]
section_6 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Introduction

Grimoire is a response to Babel.

Babel is simultaneously a kludge and the most potentially powerful language in existence.

Babel is a metalanguage. The structure of Org mode lets the user weave together code into a
living document, in a flexible, powerful way.

The name is charmingly apt. Babel exists at the top of a tower of abstractions that is teetering
on the verge of collapse. Org-mode is an extension of outline mode, which was a simple tree
editor task list.

Various users bolted stuff on, because that's how emacs grows, you bolt stuff onto it and it
continues to function because it's [[http://lispers.org/][made with alien technology]].

The problem with Babel is more than the syntax being clunky, though that's a problem. The issue is
more profoundly that Babel is built on Org, which is built on emacs. It's a language, yes,
parsers exist for other platforms. But as a runtime, it isn't portable without a lot of effort.

So much so, that we get a chance to start over. It's roughly as difficult to write Grimoire as it would be to
reimplement Babel in, say, Sublime.

In the process, we can:

  - streamline concepts, making them more orthogonal
  - clean up the clunkiness in the grammar
  - build a toolchain that will let us write magic spells in any number of languages, amassing a powerful
    collection of same. A grimoire, if you will: a living book in which magic is both written and performed.

*"]
section_1 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#+title: Grimoire: a metalanguage for magic spells.
#+options: H:4

*"]
section_2 -> { header_38 block_39 section_40 section_41 section_42}
{rank=same; header_38 block_39 section_40 section_41 section_42}

header_38 [label="1 : Musings on Metasyntax"]

block_39 [label="block 34-338"]

section_40 [label="section: 35-82"]

section_41 [label="section: 105-311"]

section_42 [label="section: 339-343"]


block_39 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_40 -> { header_44 block_45 block_46 section_47 section_48 section_49}
{rank=same; header_44 block_45 block_46 section_47 section_48 section_49}

header_44 [label="2 : Constraints"]

block_45 [label="block 35-39"]

block_46 [label="block 40-82"]

section_47 [label="section: 42-68"]

section_48 [label="section: 69-82"]

section_49 [label="section: 83-104"]


block_45 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There is a difference between a metalanguage and a literate programming language. Babel is a metalanguage,
as Grimoire is intended to be.
"]
block_46 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="An effective metalanguage balances three concerns. It must be usable, readable, and parsable.
"]
section_47 -> { header_52 block_53 block_54 block_55 block_56 block_57 block_58 block_59}
{rank=same; header_52 block_53 block_54 block_55 block_56 block_57 block_58 block_59}

header_52 [label="3 : Usable"]

block_53 [label="block 42-45"]

block_54 [label="block 46-50"]

block_55 [label="block 51-54"]

block_56 [label="block 55-58"]

block_57 [label="block 59-63"]

block_58 [label="block 64-66"]

block_59 [label="block 67-68"]


block_53 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A metalanguage is used interactively, on a deeper level than REPLs.
"]
block_54 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This is what makes working with Org so amazing. The first purpose of what became Babel
was simply editing outlines. This was outline mode, which dates back to the era when
using asterisks and =- [ ]= checkboxes in a plain ASCII text file was fairly futuristic
behavior.
"]
block_55 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="You can't really call that a language either, though it's a syntax. More and more features
were attached until we have modern Babel. But because each feature was build as an extension
to the editing/runtime environment, Babel is fairly smooth to work with.
"]
block_56 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If you can handle Emacs. I can, some can't. A metalanguage is tightly coupled to its runtime,
because its runtime is its editing environment. Not much of a metalanguage if this isn't the
case.
"]
block_57 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Grimoire is the culmination of a considerable dependency chain. We need a data structure, a
parser to work with the data structure, and an editing environment that builds on these. For
maximum enjoyment, we'll want a custom terminal that enhances the xterm protocol with a few
features, most notably graphics.
"]
block_58 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Just like I have trouble writing Lua without burning huge amounts of time planning out Clu, I
can't use Org without doing the same for Grimoire. It's all related: I need a really good parser.
"]
block_59 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="[[https://github.com/UpstandingHackers/hammer][hammer]] is the leading contender. But back to Grimoire.
"]
section_47 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Usable

A metalanguage is used interactively, on a deeper level than REPLs.

This is what makes working with Org so amazing. The first purpose of what became Babel
was simply editing outlines. This was outline mode, which dates back to the era when
using asterisks and =- [ ]= checkboxes in a plain ASCII text file was fairly futuristic
behavior.

You can't really call that a language either, though it's a syntax. More and more features
were attached until we have modern Babel. But because each feature was build as an extension
to the editing/runtime environment, Babel is fairly smooth to work with.

If you can handle Emacs. I can, some can't. A metalanguage is tightly coupled to its runtime,
because its runtime is its editing environment. Not much of a metalanguage if this isn't the
case.

Grimoire is the culmination of a considerable dependency chain. We need a data structure, a
parser to work with the data structure, and an editing environment that builds on these. For
maximum enjoyment, we'll want a custom terminal that enhances the xterm protocol with a few
features, most notably graphics.

Just like I have trouble writing Lua without burning huge amounts of time planning out Clu, I
can't use Org without doing the same for Grimoire. It's all related: I need a really good parser.

[[https://github.com/UpstandingHackers/hammer][hammer]] is the leading contender. But back to Grimoire.

*"]
section_48 -> { header_68 block_69 block_70 block_71}
{rank=same; header_68 block_69 block_70 block_71}

header_68 [label="3 : Readable"]

block_69 [label="block 69-74"]

block_70 [label="block 75-78"]

block_71 [label="block 79-82"]


block_69 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is designed to be read.  It's important that the raw syntax not
 break the reader's flow.  A good metalanguage lets the user employ just
 as much magic as she's comfortable with, without imposing more.
"]
block_70 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Our syntax is  designed to support this. As such  it is deeply concerned
with matters  such as indentation  and whitespacing, which are  basic to
readability.
"]
block_71 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="It will be quite possible and indeed comfortable to write pure documents
such  as blog  posts in  Grimoire form.  In that  use case  it resembles
Markdown.
"]
section_48 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Readable

Grimoire is designed to be read.  It's important that the raw syntax not
 break the reader's flow.  A good metalanguage lets the user employ just
 as much magic as she's comfortable with, without imposing more.

Our syntax is  designed to support this. As such  it is deeply concerned
with matters  such as indentation  and whitespacing, which are  basic to
readability.

It will be quite possible and indeed comfortable to write pure documents
such  as blog  posts in  Grimoire form.  In that  use case  it resembles
Markdown.

*"]
section_49 -> { header_76 block_77 block_78 block_79 block_80 block_81}
{rank=same; header_76 block_77 block_78 block_79 block_80 block_81}

header_76 [label="3 : Parsable"]

block_77 [label="block 83-89"]

block_78 [label="block 90-93"]

block_79 [label="block 94-97"]

block_80 [label="block 98-101"]

block_81 [label="block 102-104"]


block_77 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire  documents are  intended  to be  highly  convoluted. The  basic
editing operation  is the fold. The  Grimoire editor must be  capable of
handling documents in the tens of megabytes with a complex and preserved
folding structure.
"]
block_78 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This requires  a ground-up  editing environment  rewrite to  employ data
structures   with   correct   big-O    complexity   and   an   efficient
implementation.
"]
block_79 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This  also  requires  that  the   language  be  well-designed  for  easy
recognition of the structural elements. As this document evolves, I will
be defining a grammar in the syntax preferred by barbarian.
"]
block_80 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Grimoire is  an error-free  language. There  are several  concepts which
interact to  create this, namely  structure, prose, well-  and malformed
structure, and validity.
"]
block_81 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="A parser for Grimoire which doesn't  succeed without error for any utf-8
string is not valid.
"]
section_49 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Parsable

Grimoire  documents are  intended  to be  highly  convoluted. The  basic
editing operation  is the fold. The  Grimoire editor must be  capable of
handling documents in the tens of megabytes with a complex and preserved
folding structure.

This requires  a ground-up  editing environment  rewrite to  employ data
structures   with   correct   big-O    complexity   and   an   efficient
implementation.

This  also  requires  that  the   language  be  well-designed  for  easy
recognition of the structural elements. As this document evolves, I will
be defining a grammar in the syntax preferred by barbarian.

Grimoire is  an error-free  language. There  are several  concepts which
interact to  create this, namely  structure, prose, well-  and malformed
structure, and validity.

A parser for Grimoire which doesn't  succeed without error for any utf-8
string is not valid.

*"]
section_40 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Constraints

There is a difference between a metalanguage and a literate programming language. Babel is a metalanguage,
as Grimoire is intended to be.

An effective metalanguage balances three concerns. It must be usable, readable, and parsable.

*** Usable

A metalanguage is used interactively, on a deeper level than REPLs.

This is what makes working with Org so amazing. The first purpose of what became Babel
was simply editing outlines. This was outline mode, which dates back to the era when
using asterisks and =- [ ]= checkboxes in a plain ASCII text file was fairly futuristic
behavior.

You can't really call that a language either, though it's a syntax. More and more features
were attached until we have modern Babel. But because each feature was build as an extension
to the editing/runtime environment, Babel is fairly smooth to work with.

If you can handle Emacs. I can, some can't. A metalanguage is tightly coupled to its runtime,
because its runtime is its editing environment. Not much of a metalanguage if this isn't the
case.

Grimoire is the culmination of a considerable dependency chain. We need a data structure, a
parser to work with the data structure, and an editing environment that builds on these. For
maximum enjoyment, we'll want a custom terminal that enhances the xterm protocol with a few
features, most notably graphics.

Just like I have trouble writing Lua without burning huge amounts of time planning out Clu, I
can't use Org without doing the same for Grimoire. It's all related: I need a really good parser.

[[https://github.com/UpstandingHackers/hammer][hammer]] is the leading contender. But back to Grimoire.

*** Readable

Grimoire is designed to be read.  It's important that the raw syntax not
 break the reader's flow.  A good metalanguage lets the user employ just
 as much magic as she's comfortable with, without imposing more.

Our syntax is  designed to support this. As such  it is deeply concerned
with matters  such as indentation  and whitespacing, which are  basic to
readability.

It will be quite possible and indeed comfortable to write pure documents
such  as blog  posts in  Grimoire form.  In that  use case  it resembles
Markdown.

*"]
section_41 -> { header_89 block_90 section_91 section_92 section_93 section_94 section_95 section_96}
{rank=same; header_89 block_90 section_91 section_92 section_93 section_94 section_95 section_96}

header_89 [label="2 : Structure"]

block_90 [label="block 105-311"]

section_91 [label="section: 109-149"]

section_92 [label="section: 161-190"]

section_93 [label="section: 191-200"]

section_94 [label="section: 253-285"]

section_95 [label="section: 295-311"]

section_96 [label="section: 312-338"]


block_90 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is a top-down look at Grimoire's proposed syntax.
"]
section_91 -> { header_98 block_99 block_100 block_101 block_102 block_103 block_104 block_105 block_106 block_107 section_108}
{rank=same; header_98 block_99 block_100 block_101 block_102 block_103 block_104 block_105 block_106 block_107 section_108}

header_98 [label="3 : Encoding"]

block_99 [label="block 109-112"]

block_100 [label="block 113-118"]

block_101 [label="block 119-123"]

block_102 [label="block 124-128"]

block_103 [label="block 129-131"]

block_104 [label="block 132-135"]

block_105 [label="block 136-140"]

block_106 [label="block 141-143"]

block_107 [label="block 144-149"]

section_108 [label="section: 150-160"]


block_99 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is defined in terms of utf-8.
"]
block_100 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The core syntax is defined in terms of the reachable keys on a US keyboard.
This tradition is firmly entrenched in the mid teens, and I have no
designs on budging that at present. The miser in me likes that they're
a byte each. The lawyer in me insists that this isn't ASCII, which is a
seven-bit legacy encoding. All aspects of utf-8 are equally meaningful.
"]
block_101 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We aren't at all afraid to use Unicode characters to display aspects
of the runtime. In fact we favor this, as it marks those operations
as distinctive. Most people can't type ⦿ without effort (I can't)
and it's easy to recognize as a folded drawer once you've seen a couple.
"]
block_102 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Grimoire is case sensitive and uses lower-snake-case for built-in English
phrases. There is a convention (see classes) that uses capitalization of
user words to affect semantics. This may be overridden with other rules
for languages that lack the majuscule-miniscule distinction.
"]
block_103 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I want Grimoire to have correct Unicode handling, for some value of
correct. It can't be considered 1.0 without this.
"]
block_104 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Bidirectional handling in a context that's indentation sensitive is
an example of something subtle. Grimoire uses indentation in various
ways, so here's the rule:
"]
block_105 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Any newline that has a reversed direction ends indentation. So if
you are going ltr, issue an rtl marker, and a newline, your indentation
level is zero. If you reverse direction twice in a line, you keep
your indentation level. Three times, you lose it.
"]
block_106 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I'd love to get a Hebrew and/or Arabic fluent hacker on the project
early, to make sure this works correctly.
"]
block_107 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Another thing I want to get right is equivalence. If you have a
variable called \"Glück\" the compiler shouldn't complain if it's
rendered in either of the valid ways. For some sequences that's
\"any of the valid ways\". If we normalized your prose, you might
have problems later, so we don't want to solve it that way.
"]
section_108 -> { header_118 block_119 block_120}
{rank=same; header_118 block_119 block_120}

header_118 [label="4 : Internationalization"]

block_119 [label="block 150-155"]

block_120 [label="block 156-160"]


block_119 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
All parts of Grimoire defined in English will be namespaced
as =en:/=, and loaded by default. Other languages will be added
when there is a fluent maintainer available.
"]
block_120 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Note  that  many  words  aren't  truly English.  Notably  the  names  of
programming languages are  the same in all human languages.   A tag like
=#author= can be namespaced =#fr:/auteur= and will be, but =#!python= is not
in the =en:/= namespace.
"]
section_108 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Internationalization

All parts of Grimoire defined in English will be namespaced
as =en:/=, and loaded by default. Other languages will be added
when there is a fluent maintainer available.

Note  that  many  words  aren't  truly English.  Notably  the  names  of
programming languages are  the same in all human languages.   A tag like
=#author= can be namespaced =#fr:/auteur= and will be, but =#!python= is not
in the =en:/= namespace.

*"]
section_91 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Encoding

Grimoire is defined in terms of utf-8.

The core syntax is defined in terms of the reachable keys on a US keyboard.
This tradition is firmly entrenched in the mid teens, and I have no
designs on budging that at present. The miser in me likes that they're
a byte each. The lawyer in me insists that this isn't ASCII, which is a
seven-bit legacy encoding. All aspects of utf-8 are equally meaningful.

We aren't at all afraid to use Unicode characters to display aspects
of the runtime. In fact we favor this, as it marks those operations
as distinctive. Most people can't type ⦿ without effort (I can't)
and it's easy to recognize as a folded drawer once you've seen a couple.

Grimoire is case sensitive and uses lower-snake-case for built-in English
phrases. There is a convention (see classes) that uses capitalization of
user words to affect semantics. This may be overridden with other rules
for languages that lack the majuscule-miniscule distinction.

I want Grimoire to have correct Unicode handling, for some value of
correct. It can't be considered 1.0 without this.

Bidirectional handling in a context that's indentation sensitive is
an example of something subtle. Grimoire uses indentation in various
ways, so here's the rule:

Any newline that has a reversed direction ends indentation. So if
you are going ltr, issue an rtl marker, and a newline, your indentation
level is zero. If you reverse direction twice in a line, you keep
your indentation level. Three times, you lose it.

I'd love to get a Hebrew and/or Arabic fluent hacker on the project
early, to make sure this works correctly.

Another thing I want to get right is equivalence. If you have a
variable called \"Glück\" the compiler shouldn't complain if it's
rendered in either of the valid ways. For some sequences that's
\"any of the valid ways\". If we normalized your prose, you might
have problems later, so we don't want to solve it that way.

*"]
section_92 -> { header_125 block_126 block_127 block_128 block_129 block_130 block_131 block_132}
{rank=same; header_125 block_126 block_127 block_128 block_129 block_130 block_131 block_132}

header_125 [label="3 : Prose and Structure"]

block_126 [label="block 161-164"]

block_127 [label="block 165-170"]

block_128 [label="block 171-175"]

block_129 [label="block 176-178"]

block_130 [label="block 179-182"]

block_131 [label="block 183-187"]

block_132 [label="block 188-190"]


block_126 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The major distinction Grimoire draws is between prose and structure.
"]
block_127 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Prose is the default parsing state. It is far from unstructured from the
runtime  perspective. Although  this needn't  be embedded  in the  parse
tree,  Grimoire   understands  concepts   such  as   paragraphs,  words,
punctuation,  capital letters,  languages, and  anything else  proper to
prose.
"]
block_128 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I refer to human languages, but Grimoire understands programming languages
also. In principle, all of them, it shouldn't be harder to add them than
it is to call them from shell, though getting a runtime rigged up to
another runtime always calls for some finesse to derive a good experience.
"]
block_129 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\"Programming languages\" is overly specific. Grimoire draws a distinction
between prose and structure. Blocks may contain either, or both.
"]
block_130 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Something that's nice about a language build on a prose/structure
relationship is that it can be error free. Anything *grym* can't build into
a structure is just prose.
"]
block_131 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Markdown has this property. Sometimes you run into crappy parsers which
build errors into Markdown, which is just obnoxious. If you [[http://daringfireball.net/projects/markdown/syntax][RTFM]],
you'll find the word \"error\" once. Helpfully explaining how Markdown
keeps you from making one.
"]
block_132 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We do what we can to make the document look the same as it is
in fact structured. Syntax highlighting handles the edge cases.
"]
section_92 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Prose and Structure

The major distinction Grimoire draws is between prose and structure.

Prose is the default parsing state. It is far from unstructured from the
runtime  perspective. Although  this needn't  be embedded  in the  parse
tree,  Grimoire   understands  concepts   such  as   paragraphs,  words,
punctuation,  capital letters,  languages, and  anything else  proper to
prose.

I refer to human languages, but Grimoire understands programming languages
also. In principle, all of them, it shouldn't be harder to add them than
it is to call them from shell, though getting a runtime rigged up to
another runtime always calls for some finesse to derive a good experience.

\"Programming languages\" is overly specific. Grimoire draws a distinction
between prose and structure. Blocks may contain either, or both.

Something that's nice about a language build on a prose/structure
relationship is that it can be error free. Anything *grym* can't build into
a structure is just prose.

Markdown has this property. Sometimes you run into crappy parsers which
build errors into Markdown, which is just obnoxious. If you [[http://daringfireball.net/projects/markdown/syntax][RTFM]],
you'll find the word \"error\" once. Helpfully explaining how Markdown
keeps you from making one.

We do what we can to make the document look the same as it is
in fact structured. Syntax highlighting handles the edge cases.

*"]
section_93 -> { header_141 block_142 block_143 block_144 section_145}
{rank=same; header_141 block_142 block_143 block_144 section_145}

header_141 [label="3 : Ownership"]

block_142 [label="block 191-194"]

block_143 [label="block 195-198"]

block_144 [label="block 199-200"]

section_145 [label="section: 201-252"]


block_142 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The basic structural relationship in Grimoire is ownership.
"]
block_143 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Root elements of a heirarchy own their children, blocks own
lines that refer to that block. Indentation has a subtle but
regular interaction with ownership; it does what you expect.
"]
block_144 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Edge cases are resolved using the cling rule.
"]
section_145 -> { header_149 block_150 block_151 block_152 block_153 block_154 block_155 block_156 block_157 block_158 block_159 block_160 block_161 block_162 block_163}
{rank=same; header_149 block_150 block_151 block_152 block_153 block_154 block_155 block_156 block_157 block_158 block_159 block_160 block_161 block_162 block_163}

header_149 [label="4 : The Cling Rule"]

block_150 [label="block 201-205"]

block_151 [label="block 206-209"]

block_152 [label="block 210-213"]

block_153 [label="block 214-217"]

block_154 [label="block 218-224"]

block_155 [label="block 225-228"]

block_156 [label="block 229-232"]

block_157 [label="block 233-235"]

block_158 [label="block 236-239"]

block_159 [label="block 240-241"]

block_160 [label="block 242-244"]

block_161 [label="block 245-247"]

block_162 [label="block 248-250"]

block_163 [label="block 251-252"]


block_150 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The cling rule specifies that a group 'clings' to another group when
it is closer to that group than the other group. Ties resolve down.
"]
block_151 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This should make it intuitive to group elements that aren't grouping the
way you expect: put in whitespace until the block is visually distinguished
from the surroundings.
"]
block_152 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Cling applies between blocks which are at the same level of ownership.
Ownership has precedence over cling: all blocks underneath e.g. a header
line are owned by that line, newlines notwithstanding.
"]
block_153 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Note that indentation of e.g. lists invokes the cling rule within the
indentation level.

"]
block_154 -> { structure_168 structure_169}
{rank=same; structure_168 structure_169}

structure_168 [label="structure"]

structure_169 [label="structure"]


structure_168 -> { hashline_170}
{rank=same; hashline_170}

hashline_170 [label="hashline"]


hashline_170 -> { hashtag_171}
{rank=same; hashtag_171}

hashtag_171 [label="hashtag"]


hashtag_171 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_169 -> { hashline_173}
{rank=same; hashline_173}

hashline_173 [label="hashline"]


hashline_173 -> { hashtag_174}
{rank=same; hashtag_174}

hashtag_174 [label="hashtag"]


hashtag_174 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tag"]
block_154 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label="| x | y | z |



someprose on a block"]
block_155 -> { structure_177}
{rank=same; structure_177}

structure_177 [label="structure"]


structure_177 -> { hashline_178}
{rank=same; hashline_178}

hashline_178 [label="hashline"]


hashline_178 -> { hashtag_179}
{rank=same; hashtag_179}

hashtag_179 [label="hashtag"]


hashtag_179 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_155 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Tags the table, but
"]
block_156 -> { structure_182}
{rank=same; structure_182}

structure_182 [label="structure"]


structure_182 -> { hashline_183}
{rank=same; hashline_183}

hashline_183 [label="hashline"]


hashline_183 -> { hashtag_184}
{rank=same; hashtag_184}

hashtag_184 [label="hashtag"]


hashtag_184 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_156 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label="| x | y | z |

"]
block_157 -> { structure_187}
{rank=same; structure_187}

structure_187 [label="structure"]


structure_187 -> { hashline_188}
{rank=same; hashline_188}

hashline_188 [label="hashline"]


hashline_188 -> { hashtag_189}
{rank=same; hashtag_189}

hashtag_189 [label="hashtag"]


hashtag_189 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tag"]
block_157 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
someprose on a block"]
block_158 -> { structure_192}
{rank=same; structure_192}

structure_192 [label="structure"]


structure_192 -> { hashline_193}
{rank=same; hashline_193}

hashline_193 [label="hashline"]


hashline_193 -> { hashtag_194}
{rank=same; hashtag_194}

hashtag_194 [label="hashtag"]


hashtag_194 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_158 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Tags the block.
"]
block_159 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Even clings are resolved forwards:
"]
block_160 -> { structure_198}
{rank=same; structure_198}

structure_198 [label="structure"]


structure_198 -> { hashline_199}
{rank=same; hashline_199}

hashline_199 [label="hashline"]


hashline_199 -> { hashtag_200}
{rank=same; hashtag_200}

hashtag_200 [label="hashtag"]


hashtag_200 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_160 -> leaf_202
leaf_202  [color=Gray,shape=rectangle,fontname=Inconsolata,label="| x | y | z |
"]
block_161 -> { structure_203}
{rank=same; structure_203}

structure_203 [label="structure"]


structure_203 -> { hashline_204}
{rank=same; hashline_204}

hashline_204 [label="hashline"]


hashline_204 -> { hashtag_205}
{rank=same; hashtag_205}

hashtag_205 [label="hashtag"]


hashtag_205 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tag"]
block_161 -> leaf_207
leaf_207  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
someprose on a block"]
block_162 -> { structure_208}
{rank=same; structure_208}

structure_208 [label="structure"]


structure_208 -> { hashline_209}
{rank=same; hashline_209}

hashline_209 [label="hashline"]


hashline_209 -> { hashtag_210}
{rank=same; hashtag_210}

hashtag_210 [label="hashtag"]


hashtag_210 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_162 -> leaf_212
leaf_212  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Tags  the prose  block. The first and last examples should"]
block_163 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="be considered bad style.
"]
section_145 -> leaf_214
leaf_214  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** The Cling Rule

The cling rule specifies that a group 'clings' to another group when
it is closer to that group than the other group. Ties resolve down.

This should make it intuitive to group elements that aren't grouping the
way you expect: put in whitespace until the block is visually distinguished
from the surroundings.

Cling applies between blocks which are at the same level of ownership.
Ownership has precedence over cling: all blocks underneath e.g. a header
line are owned by that line, newlines notwithstanding.

Note that indentation of e.g. lists invokes the cling rule within the
indentation level.


#+begin_example
| x | y | z |

#tag


someprose on a block
#+end_example

Tags the table, but

#+begin_example
| x | y | z |


#tag

someprose on a block
#+end_example

Tags the block.

Even clings are resolved forwards:

#+begin_example
| x | y | z |

#tag

someprose on a block
#+end_example

Tags  the prose  block. The first and last examples should
be considered bad style.

*"]
section_93 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Ownership

The basic structural relationship in Grimoire is ownership.

Root elements of a heirarchy own their children, blocks own
lines that refer to that block. Indentation has a subtle but
regular interaction with ownership; it does what you expect.

Edge cases are resolved using the cling rule.

*"]
section_94 -> { header_216 block_217 section_218 section_219 section_220}
{rank=same; header_216 block_217 section_218 section_219 section_220}

header_216 [label="3 : Whitespace, Lines, and Indentation."]

block_217 [label="block 253-285"]

section_218 [label="section: 258-279"]

section_219 [label="section: 280-285"]

section_220 [label="section: 286-294"]


block_217 -> leaf_221
leaf_221  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is a structured document format. There are semantics associated
with every character we encode.
"]
section_218 -> { header_222 block_223 block_224 block_225 block_226 block_227}
{rank=same; header_222 block_223 block_224 block_225 block_226 block_227}

header_222 [label="4 : Whitespace"]

block_223 [label="block 258-262"]

block_224 [label="block 263-265"]

block_225 [label="block 266-271"]

block_226 [label="block 272-276"]

block_227 [label="block 277-279"]


block_223 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Whitespace is either the space or newline character. Returns are removed,
tabs resolved to two spaces by the formatter, the latter is warned against.
"]
block_224 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Most of the token-like categories we refer to must be surrounded by
whitespace. Newlines have semantics more often than they do not.
"]
block_225 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Unicode actually contains quite a number of whitespace characters. They are
all treated as a single ordinary space. If that space is semantically meaningful,
as in the space between =*** A Headline=, it is filtered into an ordinary space.
Otherwise it's considered prose, the only filtration prose receives is tab->space
conversion.
"]
block_226 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Grimoire mercilessly enforces tab-space conversion, even on your code blocks.
I will cling to this tenet as long as I can, the tab character needs to die,
the world has decided, that key is special and shouldn't insert a special
dropping that looks like n spaces.
"]
block_227 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*make*? Outta my face with make. Yes, we'll have a make syntax, yes, it will
put the tabs back in.
"]
section_218 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Whitespace

Whitespace is either the space or newline character. Returns are removed,
tabs resolved to two spaces by the formatter, the latter is warned against.

Most of the token-like categories we refer to must be surrounded by
whitespace. Newlines have semantics more often than they do not.

Unicode actually contains quite a number of whitespace characters. They are
all treated as a single ordinary space. If that space is semantically meaningful,
as in the space between =*** A Headline=, it is filtered into an ordinary space.
Otherwise it's considered prose, the only filtration prose receives is tab->space
conversion.

Grimoire mercilessly enforces tab-space conversion, even on your code blocks.
I will cling to this tenet as long as I can, the tab character needs to die,
the world has decided, that key is special and shouldn't insert a special
dropping that looks like n spaces.

*make*? Outta my face with make. Yes, we'll have a make syntax, yes, it will
put the tabs back in.

*"]
section_219 -> { header_234 block_235}
{rank=same; header_234 block_235}

header_234 [label="4 : Lines"]

block_235 [label="block 280-285"]


block_235 -> leaf_236
leaf_236  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
When we refer to the beginning of a line, this allows for spaces before the
reference point. We call the absolute beginning of a line the first
position.
"]
section_219 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Lines

When we refer to the beginning of a line, this allows for spaces before the
reference point. We call the absolute beginning of a line the first
position.

*"]
section_220 -> { header_238 block_239 block_240 block_241}
{rank=same; header_238 block_239 block_240 block_241}

header_238 [label="4 : Indentation"]

block_239 [label="block 286-290"]

block_240 [label="block 291-292"]

block_241 [label="block 293-294"]


block_239 -> leaf_242
leaf_242  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is an indentation-aware language. Most kinds of block can be
arcically[fn:1] ordered by means of indentation.
"]
block_240 -> leaf_243
leaf_243  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Indentation follows [[http://nim-lang.org/manual.html#indentation][Nim rules]].
"]
block_241 -> leaf_244
leaf_244  [color=Gray,shape=rectangle,fontname=Inconsolata,label="[fn:1] There's nothing sacred about ordered subrules, and if we're making up
a new word, let's drop the silent h. Webster was a cool guy."]
section_220 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Indentation

Grimoire is an indentation-aware language. Most kinds of block can be
arcically[fn:1] ordered by means of indentation.

Indentation follows [[http://nim-lang.org/manual.html#indentation][Nim rules]].

[fn:1] There's nothing sacred about ordered subrules, and if we're making up
a new word, let's drop the silent h. Webster was a cool guy.
*"]
section_94 -> leaf_246
leaf_246  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Whitespace, Lines, and Indentation.

Grimoire is a structured document format. There are semantics associated
with every character we encode.

**** Whitespace

Whitespace is either the space or newline character. Returns are removed,
tabs resolved to two spaces by the formatter, the latter is warned against.

Most of the token-like categories we refer to must be surrounded by
whitespace. Newlines have semantics more often than they do not.

Unicode actually contains quite a number of whitespace characters. They are
all treated as a single ordinary space. If that space is semantically meaningful,
as in the space between =*** A Headline=, it is filtered into an ordinary space.
Otherwise it's considered prose, the only filtration prose receives is tab->space
conversion.

Grimoire mercilessly enforces tab-space conversion, even on your code blocks.
I will cling to this tenet as long as I can, the tab character needs to die,
the world has decided, that key is special and shouldn't insert a special
dropping that looks like n spaces.

*make*? Outta my face with make. Yes, we'll have a make syntax, yes, it will
put the tabs back in.

**** Lines

When we refer to the beginning of a line, this allows for spaces before the
reference point. We call the absolute beginning of a line the first
position.

*"]
section_95 -> { header_247 block_248 block_249 block_250 block_251}
{rank=same; header_247 block_248 block_249 block_250 block_251}

header_247 [label="3 : Order of Recognition"]

block_248 [label="block 295-300"]

block_249 [label="block 301-305"]

block_250 [label="block 306-309"]

block_251 [label="block 310-311"]


block_248 -> leaf_252
leaf_252  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Starting from the neutral context, which is always at a newline, Grimoire
tries to make one of its initializing special forms. Failing that, it will
begin a prose block.
"]
block_249 -> leaf_253
leaf_253  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If there is whitespace, it affects indentation level in indicated ways.
They will not directly affect the semantics of the following form, that is,
these rules apply after any potentially block-ending newline, apart from
spaces that may be found between the newline and the character.
"]
block_250 -> leaf_254
leaf_254  [color=Gray,shape=rectangle,fontname=Inconsolata,label="At present,  =*=, =#=,  =|=, =-=,  , =~=,  =@=, =:=  and ={=  all create
special  contexts.  A  special  context  creates a  block  in a  context
specific way.
"]
block_251 -> leaf_255
leaf_255  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Blocks have a left associativity which can be recursive.
"]
section_95 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Order of Recognition

Starting from the neutral context, which is always at a newline, Grimoire
tries to make one of its initializing special forms. Failing that, it will
begin a prose block.

If there is whitespace, it affects indentation level in indicated ways.
They will not directly affect the semantics of the following form, that is,
these rules apply after any potentially block-ending newline, apart from
spaces that may be found between the newline and the character.

At present,  =*=, =#=,  =|=, =-=,  , =~=,  =@=, =:=  and ={=  all create
special  contexts.  A  special  context  creates a  block  in a  context
specific way.

Blocks have a left associativity which can be recursive.

*"]
section_96 -> { header_257 block_258 block_259 block_260 block_261 block_262}
{rank=same; header_257 block_258 block_259 block_260 block_261 block_262}

header_257 [label="3 : Blocks"]

block_258 [label="block 312-315"]

block_259 [label="block 316-318"]

block_260 [label="block 319-323"]

block_261 [label="block 324-331"]

block_262 [label="block 332-338"]


block_258 -> leaf_263
leaf_263  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is oriented around blocks.
"]
block_259 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Blocks are at least one line long,  all restarts are on a new line.  Any
syntactic structure smaller than a block we call an element.
"]
block_260 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Some types of blocks nest.  A document is a single  block.  There may be
other semantic units such as directories, I'd think a language that uses
strict  nested heirarchy  as powerfully  as Grimoire  could dictate  the
semantics of a file system, but that's currently out of scope.
"]
block_261 -> leaf_266
leaf_266  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Indentation is relevant to some  kinds of blocks. In general, whitespace
matters quite a  bit in a Grimoire  document. We keep some  of the warts
out because the tab character is  illegal, and there will be a mandatory
formatter, =grym  fmt= if  you will, that  does everything  from turning
=**bold**=  into =*bold*=  (because the  extra stars  weren't used),  to
newline stripping, and so on.  This is normally applied incrementally by
the runtime editing environment.
"]
block_262 -> leaf_267
leaf_267  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Indentation is human  readable and, with some care, a  computer may come
to the  same conclusions a  human would. I'm  still wary of  Python, but
there's no good  reason, unless the headache of most  Python not working
correctly  on my  computer, for  reasons I  can't track  down that  seem
related to  there being two languages  invoked as 'python', counts  as a
good reason.
"]
section_96 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Blocks

Grimoire is oriented around blocks.

Blocks are at least one line long,  all restarts are on a new line.  Any
syntactic structure smaller than a block we call an element.

Some types of blocks nest.  A document is a single  block.  There may be
other semantic units such as directories, I'd think a language that uses
strict  nested heirarchy  as powerfully  as Grimoire  could dictate  the
semantics of a file system, but that's currently out of scope.

Indentation is relevant to some  kinds of blocks. In general, whitespace
matters quite a  bit in a Grimoire  document. We keep some  of the warts
out because the tab character is  illegal, and there will be a mandatory
formatter, =grym  fmt= if  you will, that  does everything  from turning
=**bold**=  into =*bold*=  (because the  extra stars  weren't used),  to
newline stripping, and so on.  This is normally applied incrementally by
the runtime editing environment.

Indentation is human  readable and, with some care, a  computer may come
to the  same conclusions a  human would. I'm  still wary of  Python, but
there's no good  reason, unless the headache of most  Python not working
correctly  on my  computer, for  reasons I  can't track  down that  seem
related to  there being two languages  invoked as 'python', counts  as a
good reason.

*"]
section_41 -> leaf_269
leaf_269  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Structure

This is a top-down look at Grimoire's proposed syntax.

*** Encoding

Grimoire is defined in terms of utf-8.

The core syntax is defined in terms of the reachable keys on a US keyboard.
This tradition is firmly entrenched in the mid teens, and I have no
designs on budging that at present. The miser in me likes that they're
a byte each. The lawyer in me insists that this isn't ASCII, which is a
seven-bit legacy encoding. All aspects of utf-8 are equally meaningful.

We aren't at all afraid to use Unicode characters to display aspects
of the runtime. In fact we favor this, as it marks those operations
as distinctive. Most people can't type ⦿ without effort (I can't)
and it's easy to recognize as a folded drawer once you've seen a couple.

Grimoire is case sensitive and uses lower-snake-case for built-in English
phrases. There is a convention (see classes) that uses capitalization of
user words to affect semantics. This may be overridden with other rules
for languages that lack the majuscule-miniscule distinction.

I want Grimoire to have correct Unicode handling, for some value of
correct. It can't be considered 1.0 without this.

Bidirectional handling in a context that's indentation sensitive is
an example of something subtle. Grimoire uses indentation in various
ways, so here's the rule:

Any newline that has a reversed direction ends indentation. So if
you are going ltr, issue an rtl marker, and a newline, your indentation
level is zero. If you reverse direction twice in a line, you keep
your indentation level. Three times, you lose it.

I'd love to get a Hebrew and/or Arabic fluent hacker on the project
early, to make sure this works correctly.

Another thing I want to get right is equivalence. If you have a
variable called \"Glück\" the compiler shouldn't complain if it's
rendered in either of the valid ways. For some sequences that's
\"any of the valid ways\". If we normalized your prose, you might
have problems later, so we don't want to solve it that way.

**** Internationalization

All parts of Grimoire defined in English will be namespaced
as =en:/=, and loaded by default. Other languages will be added
when there is a fluent maintainer available.

Note  that  many  words  aren't  truly English.  Notably  the  names  of
programming languages are  the same in all human languages.   A tag like
=#author= can be namespaced =#fr:/auteur= and will be, but =#!python= is not
in the =en:/= namespace.

*** Prose and Structure

The major distinction Grimoire draws is between prose and structure.

Prose is the default parsing state. It is far from unstructured from the
runtime  perspective. Although  this needn't  be embedded  in the  parse
tree,  Grimoire   understands  concepts   such  as   paragraphs,  words,
punctuation,  capital letters,  languages, and  anything else  proper to
prose.

I refer to human languages, but Grimoire understands programming languages
also. In principle, all of them, it shouldn't be harder to add them than
it is to call them from shell, though getting a runtime rigged up to
another runtime always calls for some finesse to derive a good experience.

\"Programming languages\" is overly specific. Grimoire draws a distinction
between prose and structure. Blocks may contain either, or both.

Something that's nice about a language build on a prose/structure
relationship is that it can be error free. Anything *grym* can't build into
a structure is just prose.

Markdown has this property. Sometimes you run into crappy parsers which
build errors into Markdown, which is just obnoxious. If you [[http://daringfireball.net/projects/markdown/syntax][RTFM]],
you'll find the word \"error\" once. Helpfully explaining how Markdown
keeps you from making one.

We do what we can to make the document look the same as it is
in fact structured. Syntax highlighting handles the edge cases.

*** Ownership

The basic structural relationship in Grimoire is ownership.

Root elements of a heirarchy own their children, blocks own
lines that refer to that block. Indentation has a subtle but
regular interaction with ownership; it does what you expect.

Edge cases are resolved using the cling rule.

**** The Cling Rule

The cling rule specifies that a group 'clings' to another group when
it is closer to that group than the other group. Ties resolve down.

This should make it intuitive to group elements that aren't grouping the
way you expect: put in whitespace until the block is visually distinguished
from the surroundings.

Cling applies between blocks which are at the same level of ownership.
Ownership has precedence over cling: all blocks underneath e.g. a header
line are owned by that line, newlines notwithstanding.

Note that indentation of e.g. lists invokes the cling rule within the
indentation level.


#+begin_example
| x | y | z |

#tag


someprose on a block
#+end_example

Tags the table, but

#+begin_example
| x | y | z |


#tag

someprose on a block
#+end_example

Tags the block.

Even clings are resolved forwards:

#+begin_example
| x | y | z |

#tag

someprose on a block
#+end_example

Tags  the prose  block. The first and last examples should
be considered bad style.

*** Whitespace, Lines, and Indentation.

Grimoire is a structured document format. There are semantics associated
with every character we encode.

**** Whitespace

Whitespace is either the space or newline character. Returns are removed,
tabs resolved to two spaces by the formatter, the latter is warned against.

Most of the token-like categories we refer to must be surrounded by
whitespace. Newlines have semantics more often than they do not.

Unicode actually contains quite a number of whitespace characters. They are
all treated as a single ordinary space. If that space is semantically meaningful,
as in the space between =*** A Headline=, it is filtered into an ordinary space.
Otherwise it's considered prose, the only filtration prose receives is tab->space
conversion.

Grimoire mercilessly enforces tab-space conversion, even on your code blocks.
I will cling to this tenet as long as I can, the tab character needs to die,
the world has decided, that key is special and shouldn't insert a special
dropping that looks like n spaces.

*make*? Outta my face with make. Yes, we'll have a make syntax, yes, it will
put the tabs back in.

**** Lines

When we refer to the beginning of a line, this allows for spaces before the
reference point. We call the absolute beginning of a line the first
position.

**** Indentation

Grimoire is an indentation-aware language. Most kinds of block can be
arcically[fn:1] ordered by means of indentation.

Indentation follows [[http://nim-lang.org/manual.html#indentation][Nim rules]].

[fn:1] There's nothing sacred about ordered subrules, and if we're making up
a new word, let's drop the silent h. Webster was a cool guy.
*** Order of Recognition

Starting from the neutral context, which is always at a newline, Grimoire
tries to make one of its initializing special forms. Failing that, it will
begin a prose block.

If there is whitespace, it affects indentation level in indicated ways.
They will not directly affect the semantics of the following form, that is,
these rules apply after any potentially block-ending newline, apart from
spaces that may be found between the newline and the character.

At present,  =*=, =#=,  =|=, =-=,  , =~=,  =@=, =:=  and ={=  all create
special  contexts.  A  special  context  creates a  block  in a  context
specific way.

Blocks have a left associativity which can be recursive.

*"]
section_42 -> { header_270 block_271 section_272}
{rank=same; header_270 block_271 section_272}

header_270 [label="2 : Syntax"]

block_271 [label="block 339-343"]

section_272 [label="section: 344-407"]


block_271 -> leaf_273
leaf_273  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Now that we've established the basic constraints, let's
start our recursive descent into the parse.
"]
section_272 -> { header_274 block_275 block_276 block_277 block_278 block_279 block_280 block_281 section_282 section_283}
{rank=same; header_274 block_275 block_276 block_277 block_278 block_279 block_280 block_281 section_282 section_283}

header_274 [label="3 : Headers"]

block_275 [label="block 344-348"]

block_276 [label="block 349-353"]

block_277 [label="block 354-359"]

block_278 [label="block 360-361"]

block_279 [label="block 362-364"]

block_280 [label="block 365-366"]

block_281 [label="block 367-407"]

section_282 [label="section: 368-368"]

section_283 [label="section: 408-419"]


block_275 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Grimoire is arcically constrained by structure groups,
called headers.
"]
block_276 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label="These start on a new line and begin with any number of  =*=. These must
be followed by a space mark to be valid. Contra Babel, you may
have a content-free header line, provided a space is found before the
newline.
"]
block_277 -> leaf_286
leaf_286  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In weaves and the like, headers represent document structure. Their
intention is structural: they support the same syntax as lists,
but the user is expected to use lists for list purposes. Putting
[TODO] in a header line should mean you have a document-specific
task to perform in that block.
"]
block_278 -> leaf_287
leaf_287  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Contra Babel, you may put spaces before the beginning of a header line.
"]
block_279 -> leaf_288
leaf_288  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The semantics of header lines are entirely determined by
the number of stars.
"]
block_280 -> leaf_289
leaf_289  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If you write
"]
block_281 -> { structure_290}
{rank=same; structure_290}

structure_290 [label="structure"]


structure_290 -> { hashline_291}
{rank=same; hashline_291}

hashline_291 [label="hashline"]


hashline_291 -> { hashtag_292}
{rank=same; hashtag_292}

hashtag_292 [label="hashtag"]


hashtag_292 -> leaf_293
leaf_293  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_281 -> leaf_294
leaf_294  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_282 -> { header_295 block_296 section_297}
{rank=same; header_295 block_296 section_297}

header_295 [label="1 : Top Header"]

block_296 [label="block 368-368"]

section_297 [label="section: 369-380"]


block_296 -> leaf_298
leaf_298  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_297 -> { header_299 block_300 block_301 section_302}
{rank=same; header_299 block_300 block_301 section_302}

header_299 [label="2 : Second Header"]

block_300 [label="block 369-379"]

block_301 [label="block 380-380"]

section_302 [label="section: 381-381"]


block_300 -> { structure_303}
{rank=same; structure_303}

structure_303 [label="structure"]


structure_303 -> { hashline_304}
{rank=same; hashline_304}

hashline_304 [label="hashline"]


hashline_304 -> { hashtag_305}
{rank=same; hashtag_305}

hashtag_305 [label="hashtag"]


hashtag_305 -> leaf_306
leaf_306  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_300 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The rest of the header lines are reformatted with the same
degree of indentation. Note that you still must use the
requisite number of asterisks, this is a syntax sugar giving
a more natural look to collapsed header structures. Prose blocks
needn't be indented to match.

Collapsed headers look like this:
"]
block_301 -> { structure_308}
{rank=same; structure_308}

structure_308 [label="structure"]


structure_308 -> { hashline_309}
{rank=same; hashline_309}

hashline_309 [label="hashline"]


hashline_309 -> { hashtag_310}
{rank=same; hashtag_310}

hashtag_310 [label="hashtag"]


hashtag_310 -> leaf_311
leaf_311  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_301 -> leaf_312
leaf_312  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_302 -> { header_313 block_314 section_315}
{rank=same; header_313 block_314 section_315}

header_313 [label="1 : Top Header ▼"]

block_314 [label="block 381-381"]

section_315 [label="section: 382-731"]


block_314 -> leaf_316
leaf_316  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_315 -> { header_317 block_318 block_319 block_320 block_321 section_322 section_323 section_324 section_325 section_326 section_327 section_328 section_329 section_330 section_331}
{rank=same; header_317 block_318 block_319 block_320 block_321 section_322 section_323 section_324 section_325 section_326 section_327 section_328 section_329 section_330 section_331}

header_317 [label="2 : Second Header ►"]

block_318 [label="block 382-389"]

block_319 [label="block 390-391"]

block_320 [label="block 392-395"]

block_321 [label="block 396-731"]

section_322 [label="section: 398-407"]

section_323 [label="section: 422-440"]

section_324 [label="section: 441-481"]

section_325 [label="section: 489-501"]

section_326 [label="section: 502-558"]

section_327 [label="section: 567-593"]

section_328 [label="section: 594-611"]

section_329 [label="section: 612-672"]

section_330 [label="section: 691-731"]

section_331 [label="section: 732-741"]


block_318 -> { structure_332}
{rank=same; structure_332}

structure_332 [label="structure"]


structure_332 -> { hashline_333}
{rank=same; hashline_333}

hashline_333 [label="hashline"]


hashline_333 -> { hashtag_334}
{rank=same; hashtag_334}

hashtag_334 [label="hashtag"]


hashtag_334 -> leaf_335
leaf_335  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_318 -> leaf_336
leaf_336  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This indicates that the top header is partially unfolded
and that the second header is completely folded. Deleting
into the mark unfolds.

Within sections, ordinary prose rules apply. A section"]
block_319 -> leaf_337
leaf_337  [color=Gray,shape=rectangle,fontname=Inconsolata,label="may contain any number of blocks.
"]
block_320 -> leaf_338
leaf_338  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\"begins\" means first non-whitespace character. Indentation levels are tracked by
Nim rules, obviously a Grimoire document can contain no tab marks
and if any wander in they become four spaces.
"]
block_321 -> leaf_339
leaf_339  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Contra other block forms, tags may not precede a headline.
"]
section_322 -> { header_340 block_341 block_342 block_343}
{rank=same; header_340 block_341 block_342 block_343}

header_340 [label="4 : Header Lines"]

block_341 [label="block 398-402"]

block_342 [label="block 403-405"]

block_343 [label="block 406-407"]


block_341 -> leaf_344
leaf_344  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Anything after a run of =*= and a space, and before a newline, is
a header line.
"]
block_342 -> leaf_345
leaf_345  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Header lines and list lines are structured identically. If I discover
a necessary exception, I'll note it.
"]
block_343 -> leaf_346
leaf_346  [color=Gray,shape=rectangle,fontname=Inconsolata,label="That structure is discussed under [[*Lists][lists]].
"]
section_322 -> leaf_347
leaf_347  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Header Lines

Anything after a run of =*= and a space, and before a newline, is
a header line.

Header lines and list lines are structured identically. If I discover
a necessary exception, I'll note it.

That structure is discussed under [[*Lists][lists]].

*"]
section_323 -> { header_348 block_349 block_350 block_351 block_352 block_353 block_354}
{rank=same; header_348 block_349 block_350 block_351 block_352 block_353 block_354}

header_348 [label="3 : Prose blocks"]

block_349 [label="block 422-426"]

block_350 [label="block 427-428"]

block_351 [label="block 429-432"]

block_352 [label="block 433-434"]

block_353 [label="block 435-436"]

block_354 [label="block 437-440"]


block_349 -> leaf_355
leaf_355  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A prose block is preceded and followed by a single newline. Extraneous
whitespace on the bare line is filtered.
"]
block_350 -> leaf_356
leaf_356  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Prose blocks may not be indented in a semantically meaningful way.
"]
block_351 -> { structure_357}
{rank=same; structure_357}

structure_357 [label="structure"]


structure_357 -> { hashline_358}
{rank=same; hashline_358}

hashline_358 [label="hashline"]


hashline_358 -> { hashtag_359}
{rank=same; hashtag_359}

hashtag_359 [label="hashtag"]


hashtag_359 -> leaf_360
leaf_360  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_351 -> leaf_361
leaf_361  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
prose
"]
block_352 -> leaf_362
leaf_362  [color=Gray,shape=rectangle,fontname=Inconsolata,label="    prose
"]
block_353 -> leaf_363
leaf_363  [color=Gray,shape=rectangle,fontname=Inconsolata,label="        prose
"]
block_354 -> { structure_364}
{rank=same; structure_364}

structure_364 [label="structure"]


structure_364 -> { hashline_365}
{rank=same; hashline_365}

hashline_365 [label="hashline"]


hashline_365 -> { hashtag_366}
{rank=same; hashtag_366}

hashtag_366 [label="hashtag"]


hashtag_366 -> leaf_367
leaf_367  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_354 -> leaf_368
leaf_368  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
is not nested, nor will formatter correct it.
"]
section_323 -> leaf_369
leaf_369  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Prose blocks

A prose block is preceded and followed by a single newline. Extraneous
whitespace on the bare line is filtered.

Prose blocks may not be indented in a semantically meaningful way.

#+begin_example

prose

    prose

        prose

#+end_example

is not nested, nor will formatter correct it.

*"]
section_324 -> { header_370 block_371 block_372 block_373 block_374 block_375 block_376 block_377 block_378 block_379 block_380 block_381 section_382}
{rank=same; header_370 block_371 block_372 block_373 block_374 block_375 block_376 block_377 block_378 block_379 block_380 block_381 section_382}

header_370 [label="3 : Prose markup"]

block_371 [label="block 441-444"]

block_372 [label="block 445-450"]

block_373 [label="block 451-452"]

block_374 [label="block 453-456"]

block_375 [label="block 457-460"]

block_376 [label="block 461-466"]

block_377 [label="block 467-468"]

block_378 [label="block 469-473"]

block_379 [label="block 474-477"]

block_380 [label="block 478-479"]

block_381 [label="block 480-481"]

section_382 [label="section: 482-488"]


block_371 -> leaf_383
leaf_383  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Prose markup rules apply in any prose contexts, not just for prose blocks.
"]
block_372 -> leaf_384
leaf_384  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We mark =*bold*=, =/italic/=, =_underline_=, =~strikethrough~=, 
and =​=literal=​=, using the indicated marks. They must not be separated 
with whitespace from the connecting prose. Any number may be used and matched,
whitespace is allowed, so =**bold math: 4 * 5**= will highlight
correctly.
"]
block_373 -> leaf_385
leaf_385  [color=Gray,shape=rectangle,fontname=Inconsolata,label="There is also [[*Inline%20Code][Inline Code]], which is formatted =`code`=.
"]
block_374 -> leaf_386
leaf_386  [color=Gray,shape=rectangle,fontname=Inconsolata,label="These all follow the prose markup rule: any number of the starting
character matches the same number of the ending character in the
document string.
"]
block_375 -> leaf_387
leaf_387  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We make subscripts mildly annoying, =sub__script= and =super^^script=, 
to avoid colliding the former with =snake_case=. That's a lot of ways 
to parse the =_= character...
"]
block_376 -> leaf_388
leaf_388  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In general, prose is more 'active'  than in Babel. There are more things
you can't say without triggering a parsed data structure.  Due to quirks
of Org  involving string  escaping, =`\\\"\\\"`=  can't be  literally quoted
without repercussions. Check  out the source if you enjoy pounding your
head in frustration at the nastiness of escaped strings.
"]
block_377 -> leaf_389
leaf_389  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Let's just use a code block:
"]
block_378 -> { structure_390 structure_391}
{rank=same; structure_390 structure_391}

structure_390 [label="structure"]

structure_391 [label="structure"]


structure_390 -> { hashline_392}
{rank=same; hashline_392}

hashline_392 [label="hashline"]


hashline_392 -> { hashtag_393}
{rank=same; hashtag_393}

hashtag_393 [label="hashtag"]


hashtag_393 -> leaf_394
leaf_394  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_391 -> { hashline_395}
{rank=same; hashline_395}

hashline_395 [label="hashline"]


hashline_395 -> { hashtag_396}
{rank=same; hashtag_396}

hashtag_396 [label="hashtag"]


hashtag_396 -> leaf_397
leaf_397  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_378 -> leaf_398
leaf_398  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\"\"literal string *containing* @some #things:of-various-sorts { that would be parsed }\"\"

So literal strings start with a minimum of two, rather than a minimum of"]
block_379 -> leaf_399
leaf_399  [color=Gray,shape=rectangle,fontname=Inconsolata,label="one, of the \" character. This is pretty-printed in edit mode as =‟literal”=,
but such a string does *not* create escaping, we rely on semantic highlighting
to make the distinction clear.
"]
block_380 -> leaf_400
leaf_400  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Any number of \"\"\"\" collapse into one set of such balanced quites.
"]
block_381 -> leaf_401
leaf_401  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In the woven documentation, no quotation marks appear, just the string.
"]
section_382 -> { header_402 block_403}
{rank=same; header_402 block_403}

header_402 [label="4 : Latex"]

block_403 [label="block 482-488"]


block_403 -> leaf_404
leaf_404  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
For further markup purposes in a prose context, we escape to LaTeX. The
syntax is =`\\latex`=, where the backslash causes us to use LaTeX instead
of Lua. Our TeX backend is LuaTeX, giving arbitrary levels of control from
within a Grimoire-native language.
"]
section_382 -> leaf_405
leaf_405  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Latex

For further markup purposes in a prose context, we escape to LaTeX. The
syntax is =`\\latex`=, where the backslash causes us to use LaTeX instead
of Lua. Our TeX backend is LuaTeX, giving arbitrary levels of control from
within a Grimoire-native language.

*"]
section_324 -> leaf_406
leaf_406  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Prose markup

Prose markup rules apply in any prose contexts, not just for prose blocks.

We mark =*bold*=, =/italic/=, =_underline_=, =~strikethrough~=, 
and =​=literal=​=, using the indicated marks. They must not be separated 
with whitespace from the connecting prose. Any number may be used and matched,
whitespace is allowed, so =**bold math: 4 * 5**= will highlight
correctly.

There is also [[*Inline%20Code][Inline Code]], which is formatted =`code`=.

These all follow the prose markup rule: any number of the starting
character matches the same number of the ending character in the
document string.

We make subscripts mildly annoying, =sub__script= and =super^^script=, 
to avoid colliding the former with =snake_case=. That's a lot of ways 
to parse the =_= character...

In general, prose is more 'active'  than in Babel. There are more things
you can't say without triggering a parsed data structure.  Due to quirks
of Org  involving string  escaping, =`\\\"\\\"`=  can't be  literally quoted
without repercussions. Check  out the source if you enjoy pounding your
head in frustration at the nastiness of escaped strings.

Let's just use a code block:

#+BEGIN_EXAMPLE
\"\"literal string *containing* @some #things:of-various-sorts { that would be parsed }\"\"
#+END_EXAMPLE

So literal strings start with a minimum of two, rather than a minimum of
one, of the \" character. This is pretty-printed in edit mode as =‟literal”=,
but such a string does *not* create escaping, we rely on semantic highlighting
to make the distinction clear.

Any number of \"\"\"\" collapse into one set of such balanced quites.

In the woven documentation, no quotation marks appear, just the string.

*"]
section_325 -> { header_407 block_408 block_409 block_410}
{rank=same; header_407 block_408 block_409 block_410}

header_407 [label="3 : Comments"]

block_408 [label="block 489-493"]

block_409 [label="block 494-497"]

block_410 [label="block 498-501"]


block_408 -> leaf_411
leaf_411  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In a structure context, you may place line comments. These begin with =--=
and continue to the end of a line.
"]
block_409 -> leaf_412
leaf_412  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Commenting out a header line, or anything else, causes it to be ignored.
It does *not* result in any subdata being commented out, though it will
in the case of a headline change the ownership of the owned blocks.
"]
block_410 -> leaf_413
leaf_413  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The  tag =#comment=  in a  valid tag  content position  marks the  owned
region  of  the tagged  block  as  a  comment.  Nothing within  will  be
evaluated or exported, though it will be parsed.
"]
section_325 -> leaf_414
leaf_414  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Comments

In a structure context, you may place line comments. These begin with =--=
and continue to the end of a line.

Commenting out a header line, or anything else, causes it to be ignored.
It does *not* result in any subdata being commented out, though it will
in the case of a headline change the ownership of the owned blocks.

The  tag =#comment=  in a  valid tag  content position  marks the  owned
region  of  the tagged  block  as  a  comment.  Nothing within  will  be
evaluated or exported, though it will be parsed.

*"]
section_326 -> { header_415 block_416 block_417 block_418 block_419 block_420 block_421 block_422 block_423 block_424 block_425 block_426 block_427 block_428 block_429 block_430 block_431 section_432}
{rank=same; header_415 block_416 block_417 block_418 block_419 block_420 block_421 block_422 block_423 block_424 block_425 block_426 block_427 block_428 block_429 block_430 block_431 section_432}

header_415 [label="3 : Marks"]

block_416 [label="block 502-506"]

block_417 [label="block 507-509"]

block_418 [label="block 510-512"]

block_419 [label="block 513-515"]

block_420 [label="block 516-517"]

block_421 [label="block 518-522"]

block_422 [label="block 523-526"]

block_423 [label="block 527-528"]

block_424 [label="block 529-530"]

block_425 [label="block 531-535"]

block_426 [label="block 536-538"]

block_427 [label="block 539-542"]

block_428 [label="block 543-546"]

block_429 [label="block 547-549"]

block_430 [label="block 550-551"]

block_431 [label="block 552-558"]

section_432 [label="section: 559-566"]


block_416 -> leaf_433
leaf_433  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Marks provide global semantic categories for Grimoire. They may appear
anywhere, including a prose context, whitespace is required on both sides.
"]
block_417 -> leaf_434
leaf_434  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We use  a couple kinds  of marks:  =@names= name things,  and =#tags=
categorize them. Tags are semantics, while names are nominal. 
"]
block_418 -> leaf_435
leaf_435  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Tags that  are boundaries are  paired as  =#tag= and =#/tag=,  plus some
light sugaring. Names are never bounded
"]
block_419 -> leaf_436
leaf_436  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Marks in the first position own the following line. If there is indentation
below that line, they own that too. This doesn't affect the associativity.
"]
block_420 -> leaf_437
leaf_437  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Marks may be namespaced, as =@name.subname= or =#tag.sub-tag.sub-tag=.
"]
block_421 -> leaf_438
leaf_438  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If  you  require   further  namespacing,  =@many/levels/java.class=  and
=#mojo/nation.space/station=  is your  friend. Codices (that is, projects
following the bridge conventions for organization) will use namespacing
in a consistent way. 
"]
block_422 -> leaf_439
leaf_439  [color=Gray,shape=rectangle,fontname=Inconsolata,label="As I continue to muse on it, I  can think of no reason why marks couldn't follow
URI syntax,  or at  least mirror  it closely.  Chaining marks  is not  valid, so
=@named@example.com= could be a valid name. 
"]
block_423 -> leaf_440
leaf_440  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This would mean we could say something like =@file://~/usr/blah=.
"]
block_424 -> leaf_441
leaf_441  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Or =#!/usr/bin/perl/=...
"]
block_425 -> leaf_442
leaf_442  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Yes. This  is a good idea.  Let's do this.  It doesn't displace [[*Links][link]]  syntax, it
enhances it. A  URI [[http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax][may not begin with  a slash]] so this is  parse-clean for tags
and names both. Tags aren't intended to  be user extensible in the narrow sense,
but uniformity is a virtue.
"]
block_426 -> leaf_443
leaf_443  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I don't know why you might want to stick a query in a tag. It's not my
place to know. We just slap a parser on that puppy and continue.
"]
block_427 -> leaf_444
leaf_444  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Implication: The hash or at should be syntax highlighted a different color
from the tag. I'd say hash and at get the same color, with categories and
symbols getting different ones.
"]
block_428 -> leaf_445
leaf_445  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Apparently, [[http://blog.nig.gl/post/48802013022/although-parentheses-are-technically-allowed-in][parentheses are allowed in URLs]], but follow the link, they
suck and you should never use them. They play badly with our calling
convention for named structures, and aren't allowed in our schema.
"]
block_429 -> leaf_446
leaf_446  [color=Gray,shape=rectangle,fontname=Inconsolata,label="It's not a real URI anyway, or it can be but it's also allowed to be a legal
fragment without the handle. In our case the assumed handle is =grimoire://=?
"]
block_430 -> leaf_447
leaf_447  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Not a real URI. But an acceptable fake one.
"]
block_431 -> leaf_448
leaf_448  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The actual rule for a mark is that it begins with =@= or =#= and is surrounded
by whitespace. Internal parsing of the mark is part of recognition, anything 
not recognized is subsequently ignored. It's still considered a mark for e.g. 
weaving purposes. 


"]
section_432 -> { header_449 block_450 block_451}
{rank=same; header_449 block_450 block_451}

header_449 [label="4 : Plural Hashtags"]

block_450 [label="block 559-563"]

block_451 [label="block 564-566"]


block_450 -> leaf_452
leaf_452  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In some cases, such as =#formula= and =#formulas=, a tag may have a
singular or plural form. These are equivalent from the runtimes perspective.
"]
block_451 -> leaf_453
leaf_453  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The same concept applies to pairs such as =#export= and =#exports=, though
the linguistic distinction is not that of plurality.
"]
section_432 -> leaf_454
leaf_454  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Plural Hashtags

In some cases, such as =#formula= and =#formulas=, a tag may have a
singular or plural form. These are equivalent from the runtimes perspective.

The same concept applies to pairs such as =#export= and =#exports=, though
the linguistic distinction is not that of plurality.

*"]
section_326 -> leaf_455
leaf_455  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Marks

Marks provide global semantic categories for Grimoire. They may appear
anywhere, including a prose context, whitespace is required on both sides.

We use  a couple kinds  of marks:  =@names= name things,  and =#tags=
categorize them. Tags are semantics, while names are nominal. 

Tags that  are boundaries are  paired as  =#tag= and =#/tag=,  plus some
light sugaring. Names are never bounded

Marks in the first position own the following line. If there is indentation
below that line, they own that too. This doesn't affect the associativity.

Marks may be namespaced, as =@name.subname= or =#tag.sub-tag.sub-tag=.

If  you  require   further  namespacing,  =@many/levels/java.class=  and
=#mojo/nation.space/station=  is your  friend. Codices (that is, projects
following the bridge conventions for organization) will use namespacing
in a consistent way. 

As I continue to muse on it, I  can think of no reason why marks couldn't follow
URI syntax,  or at  least mirror  it closely.  Chaining marks  is not  valid, so
=@named@example.com= could be a valid name. 

This would mean we could say something like =@file://~/usr/blah=.

Or =#!/usr/bin/perl/=...

Yes. This  is a good idea.  Let's do this.  It doesn't displace [[*Links][link]]  syntax, it
enhances it. A  URI [[http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax][may not begin with  a slash]] so this is  parse-clean for tags
and names both. Tags aren't intended to  be user extensible in the narrow sense,
but uniformity is a virtue.

I don't know why you might want to stick a query in a tag. It's not my
place to know. We just slap a parser on that puppy and continue.

Implication: The hash or at should be syntax highlighted a different color
from the tag. I'd say hash and at get the same color, with categories and
symbols getting different ones.

Apparently, [[http://blog.nig.gl/post/48802013022/although-parentheses-are-technically-allowed-in][parentheses are allowed in URLs]], but follow the link, they
suck and you should never use them. They play badly with our calling
convention for named structures, and aren't allowed in our schema.

It's not a real URI anyway, or it can be but it's also allowed to be a legal
fragment without the handle. In our case the assumed handle is =grimoire://=?

Not a real URI. But an acceptable fake one.

The actual rule for a mark is that it begins with =@= or =#= and is surrounded
by whitespace. Internal parsing of the mark is part of recognition, anything 
not recognized is subsequently ignored. It's still considered a mark for e.g. 
weaving purposes. 



*"]
section_327 -> { header_456 block_457 block_458 block_459 block_460 block_461 block_462}
{rank=same; header_456 block_457 block_458 block_459 block_460 block_461 block_462}

header_456 [label="3 : Classes"]

block_457 [label="block 567-574"]

block_458 [label="block 575-578"]

block_459 [label="block 579-582"]

block_460 [label="block 583-585"]

block_461 [label="block 586-589"]

block_462 [label="block 590-593"]


block_457 -> leaf_463
leaf_463  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Tags are for Grimoire. A category provides runtime semantics,
cooperating with structure groups to provide the API. Names
play the role of a value in languages which provide a
value-variable distinction: every name within a documents reachable
namespace must be globally unique.
"]
block_458 -> leaf_464
leaf_464  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Specifically names are globally hyperstatic: any redefinition affects
the referent from the moment the parser receives it forward. Redefinitions
are warned against and have no utility, don't do it.
"]
block_459 -> leaf_465
leaf_465  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Classes are roughly equivalent to categories/hashtags, but
for the user. They have a light semantics similar to their
function in Org.
"]
block_460 -> leaf_466
leaf_466  [color=Gray,shape=rectangle,fontname=Inconsolata,label="A class is defined as =:Class:= or =:class:= including
=:several:Classes:chained:=.
"]
block_461 -> leaf_467
leaf_467  [color=Gray,shape=rectangle,fontname=Inconsolata,label="A capital letter means the class inherits onto all subgroups of the block,
a miniscule means the class is associated with the indentation level it is
found within.
"]
block_462 -> leaf_468
leaf_468  [color=Gray,shape=rectangle,fontname=Inconsolata,label="You know you're programming a computer when class and category have distinct
semantics. At least there are no objects, and only two primitive types,
structure and prose.
"]
section_327 -> leaf_469
leaf_469  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Classes

Tags are for Grimoire. A category provides runtime semantics,
cooperating with structure groups to provide the API. Names
play the role of a value in languages which provide a
value-variable distinction: every name within a documents reachable
namespace must be globally unique.

Specifically names are globally hyperstatic: any redefinition affects
the referent from the moment the parser receives it forward. Redefinitions
are warned against and have no utility, don't do it.

Classes are roughly equivalent to categories/hashtags, but
for the user. They have a light semantics similar to their
function in Org.

A class is defined as =:Class:= or =:class:= including
=:several:Classes:chained:=.

A capital letter means the class inherits onto all subgroups of the block,
a miniscule means the class is associated with the indentation level it is
found within.

You know you're programming a computer when class and category have distinct
semantics. At least there are no objects, and only two primitive types,
structure and prose.

*"]
section_328 -> { header_470 block_471 block_472 block_473 block_474 block_475}
{rank=same; header_470 block_471 block_472 block_473 block_474 block_475}

header_470 [label="3 : Links"]

block_471 [label="block 594-597"]

block_472 [label="block 598-599"]

block_473 [label="block 600-605"]

block_474 [label="block 606-608"]

block_475 [label="block 609-611"]


block_471 -> leaf_476
leaf_476  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There's nothing at all wrong with the syntax or behavior of Babel links.
"]
block_472 -> leaf_477
leaf_477  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Which look like this:
"]
block_473 -> { structure_478 structure_479}
{rank=same; structure_478 structure_479}

structure_478 [label="structure"]

structure_479 [label="structure"]


structure_478 -> { hashline_480}
{rank=same; hashline_480}

hashline_480 [label="hashline"]


hashline_480 -> { hashtag_481}
{rank=same; hashtag_481}

hashtag_481 [label="hashtag"]


hashtag_481 -> leaf_482
leaf_482  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_479 -> { hashline_483}
{rank=same; hashline_483}

hashline_483 [label="hashline"]


hashline_483 -> { hashtag_484}
{rank=same; hashtag_484}

hashtag_484 [label="hashtag"]


hashtag_484 -> leaf_485
leaf_485  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_473 -> leaf_486
leaf_486  [color=Gray,shape=rectangle,fontname=Inconsolata,label="[[http://example.com][Hello Example]]

With various wrinkles, all supported.
"]
block_474 -> leaf_487
leaf_487  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We won't support legacy forms of footnoting, such as =[1]=. This applies
to legacy versions of table formulas and list syntax also.
"]
block_475 -> leaf_488
leaf_488  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In Grimoire  there's one way  to do things.  At least, we  avoid variant
syntax with identical semantics.
"]
section_328 -> leaf_489
leaf_489  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Links

There's nothing at all wrong with the syntax or behavior of Babel links.

Which look like this:

#+begin_example
[[http://example.com][Hello Example]]
#+end_example

With various wrinkles, all supported.

We won't support legacy forms of footnoting, such as =[1]=. This applies
to legacy versions of table formulas and list syntax also.

In Grimoire  there's one way  to do things.  At least, we  avoid variant
syntax with identical semantics.

*"]
section_329 -> { header_490 block_491 block_492 block_493 block_494 block_495 block_496 block_497 block_498 block_499 block_500 block_501 block_502 block_503 block_504 section_505}
{rank=same; header_490 block_491 block_492 block_493 block_494 block_495 block_496 block_497 block_498 block_499 block_500 block_501 block_502 block_503 block_504 section_505}

header_490 [label="3 : Cookies"]

block_491 [label="block 612-616"]

block_492 [label="block 617-620"]

block_493 [label="block 621-624"]

block_494 [label="block 625-628"]

block_495 [label="block 629-633"]

block_496 [label="block 634-639"]

block_497 [label="block 640-642"]

block_498 [label="block 643-645"]

block_499 [label="block 646-650"]

block_500 [label="block 651-654"]

block_501 [label="block 655-660"]

block_502 [label="block 661-665"]

block_503 [label="block 666-669"]

block_504 [label="block 670-672"]

section_505 [label="section: 673-690"]


block_491 -> leaf_506
leaf_506  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
List line contexts (header lines and list lines) may have cookies. A
cookie looks like =[ ]=, it must have contents and a space on both sides.
"]
block_492 -> leaf_507
leaf_507  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Cookies are valid after the symbol that defines the list line, but before
anything else. They are also valid at the end of a list line, in which
case they are preceded by a space and followed by a newline.
"]
block_493 -> leaf_508
leaf_508  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Cookies are distinctive in that they may only be applied to list lines.
Most other token-like groups, specifically tags, classes, and inline drawers,
may be embedded into all prose contexts excepting literal strings.
"]
block_494 -> leaf_509
leaf_509  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Cookies are used similarly to cookies in Org, but with consistent semantics.
A simple cookie set is \"X\" and \" \", the user cycles through them. TODO and
DONE are another option.
"]
block_495 -> leaf_510
leaf_510  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I don't want cookies to turn into lightweight tables. Still, saying to
the user \"you may have precisely two cookies a line\" is restrictive.
It's not a violation of the [[http://c2.com/cgi/wiki?TwoIsAnImpossibleNumber][\"Two is an Impossible Number\"]] principle,
because they're head and tail. I think this is ugly:
"]
block_496 -> { structure_511 structure_512}
{rank=same; structure_511 structure_512}

structure_511 [label="structure"]

structure_512 [label="structure"]


structure_511 -> { hashline_513}
{rank=same; hashline_513}

hashline_513 [label="hashline"]


hashline_513 -> { hashtag_514}
{rank=same; hashtag_514}

hashtag_514 [label="hashtag"]


hashtag_514 -> leaf_515
leaf_515  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_512 -> { hashline_516}
{rank=same; hashline_516}

hashline_516 [label="hashline"]


hashline_516 -> { hashtag_517}
{rank=same; hashtag_517}

hashtag_517 [label="hashtag"]


hashtag_517 -> leaf_518
leaf_518  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_496 -> leaf_519
leaf_519  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - [ ] [ ] [ ] Oh god boxes [ ] [ ] [ ]

And whatever you're trying to model there should be a table.
"]
block_497 -> leaf_520
leaf_520  [color=Gray,shape=rectangle,fontname=Inconsolata,label="You can stick a table in a list. I don't know if I mentioned, it's kind
of an obvious thing, I'll write a unit for it at some point.
"]
block_498 -> leaf_521
leaf_521  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Still. I can see a case for two on the left. Once you allow two, you allow
n, without excellent reason.
"]
block_499 -> leaf_522
leaf_522  [color=Gray,shape=rectangle,fontname=Inconsolata,label="[[*Radio%20cookies][Radio cookies]] must be the leftmost cookie on a line, only one is of course allowed.
I could allow a single-line short form multi-radio-button interface but what
is it, a fancy text slider for some value? No. Any number of ordinary cookies
can follow. Knock yourself out.
"]
block_500 -> leaf_523
leaf_523  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Anything more than a couple and one should consider a class or a table.
Handrolling data structures is perverse in a markup language, and I'm
still tempted to forbid it.
"]
block_501 -> leaf_524
leaf_524  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I don't like distinctions without difference. A cookie at the end of a
line is filled by Grimoire, not the user. This mirrors Org's use, which is
to display either a percent or a n/m marker for completion of list items.
The user seeds the cookie, in these cases with =%= or =/=, and the runtime
does the rest.
"]
block_502 -> leaf_525
leaf_525  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Adding more than one such structure to the tail list would complicate the
reference syntax, which I haven't designed, and again, it's just not necessary.
Grimoire can fill in any data structure, \"n-dimensional end cookie array\"
isn't one we have a compelling need for.
"]
block_503 -> leaf_526
leaf_526  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Cookies could interact badly with link syntax. I don't think a [bare box]
qualifies as a link in Org, clearly it doesn't, we can follow that notion
and disallow \"[]\" as a filling for cookies.
"]
block_504 -> leaf_527
leaf_527  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I also think they should be allowed in table cells, which have their own
context which is mostly handwaved right now but is prose++.
"]
section_505 -> { header_528 block_529 block_530 block_531 block_532}
{rank=same; header_528 block_529 block_530 block_531 block_532}

header_528 [label="4 : Radio cookies"]

block_529 [label="block 673-678"]

block_530 [label="block 679-681"]

block_531 [label="block 682-687"]

block_532 [label="block 688-690"]


block_529 -> leaf_533
leaf_533  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We have one 'weird cookie'. A radio cookie, which looks like =( )=,
must be present at the head position of list line contexts. All
list lines at the same level of indentation must have one, if one does.
"]
block_530 -> leaf_534
leaf_534  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Only one is selected at any given time. These would be awkward to add
into tables, to little gain.
"]
block_531 -> leaf_535
leaf_535  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This comes perilously close to pushing us into the realm of error.
The formatter adds buttons to an entire subtree if one member has it,
and if more than one is ticked off, it warns if possible or removes
all but the first mark encountered. If none are present the first
option is selected.
"]
block_532 -> leaf_536
leaf_536  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The runtime will not normally build an invalid radio list, but
Grimoire must import plain text.
"]
section_505 -> leaf_537
leaf_537  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Radio cookies

We have one 'weird cookie'. A radio cookie, which looks like =( )=,
must be present at the head position of list line contexts. All
list lines at the same level of indentation must have one, if one does.

Only one is selected at any given time. These would be awkward to add
into tables, to little gain.

This comes perilously close to pushing us into the realm of error.
The formatter adds buttons to an entire subtree if one member has it,
and if more than one is ticked off, it warns if possible or removes
all but the first mark encountered. If none are present the first
option is selected.

The runtime will not normally build an invalid radio list, but
Grimoire must import plain text.

*"]
section_329 -> leaf_538
leaf_538  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Cookies

List line contexts (header lines and list lines) may have cookies. A
cookie looks like =[ ]=, it must have contents and a space on both sides.

Cookies are valid after the symbol that defines the list line, but before
anything else. They are also valid at the end of a list line, in which
case they are preceded by a space and followed by a newline.

Cookies are distinctive in that they may only be applied to list lines.
Most other token-like groups, specifically tags, classes, and inline drawers,
may be embedded into all prose contexts excepting literal strings.

Cookies are used similarly to cookies in Org, but with consistent semantics.
A simple cookie set is \"X\" and \" \", the user cycles through them. TODO and
DONE are another option.

I don't want cookies to turn into lightweight tables. Still, saying to
the user \"you may have precisely two cookies a line\" is restrictive.
It's not a violation of the [[http://c2.com/cgi/wiki?TwoIsAnImpossibleNumber][\"Two is an Impossible Number\"]] principle,
because they're head and tail. I think this is ugly:

#+begin_example
 - [ ] [ ] [ ] Oh god boxes [ ] [ ] [ ]
#+end_example

And whatever you're trying to model there should be a table.

You can stick a table in a list. I don't know if I mentioned, it's kind
of an obvious thing, I'll write a unit for it at some point.

Still. I can see a case for two on the left. Once you allow two, you allow
n, without excellent reason.

[[*Radio%20cookies][Radio cookies]] must be the leftmost cookie on a line, only one is of course allowed.
I could allow a single-line short form multi-radio-button interface but what
is it, a fancy text slider for some value? No. Any number of ordinary cookies
can follow. Knock yourself out.

Anything more than a couple and one should consider a class or a table.
Handrolling data structures is perverse in a markup language, and I'm
still tempted to forbid it.

I don't like distinctions without difference. A cookie at the end of a
line is filled by Grimoire, not the user. This mirrors Org's use, which is
to display either a percent or a n/m marker for completion of list items.
The user seeds the cookie, in these cases with =%= or =/=, and the runtime
does the rest.

Adding more than one such structure to the tail list would complicate the
reference syntax, which I haven't designed, and again, it's just not necessary.
Grimoire can fill in any data structure, \"n-dimensional end cookie array\"
isn't one we have a compelling need for.

Cookies could interact badly with link syntax. I don't think a [bare box]
qualifies as a link in Org, clearly it doesn't, we can follow that notion
and disallow \"[]\" as a filling for cookies.

I also think they should be allowed in table cells, which have their own
context which is mostly handwaved right now but is prose++.

*"]
section_330 -> { header_539 block_540 block_541 block_542 block_543 block_544 block_545 block_546 block_547 block_548}
{rank=same; header_539 block_540 block_541 block_542 block_543 block_544 block_545 block_546 block_547 block_548}

header_539 [label="3 : Drawers"]

block_540 [label="block 691-695"]

block_541 [label="block 696-702"]

block_542 [label="block 703-705"]

block_543 [label="block 706-708"]

block_544 [label="block 709-710"]

block_545 [label="block 711-721"]

block_546 [label="block 722-724"]

block_547 [label="block 725-727"]

block_548 [label="block 728-731"]


block_540 -> leaf_549
leaf_549  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A drawer is a block that's hidden by default. The computer sees it,
the user sees ⦿, or a similar rune.
"]
block_541 -> { structure_550 structure_551}
{rank=same; structure_550 structure_551}

structure_550 [label="structure"]

structure_551 [label="structure"]


structure_550 -> { hashline_552}
{rank=same; hashline_552}

hashline_552 [label="hashline"]


hashline_552 -> { hashtag_553}
{rank=same; hashtag_553}

hashtag_553 [label="hashtag"]


hashtag_553 -> leaf_554
leaf_554  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_551 -> { hashline_555}
{rank=same; hashline_555}

hashline_555 [label="hashline"]


hashline_555 -> { hashtag_556}
{rank=same; hashtag_556}

hashtag_556 [label="hashtag"]


hashtag_556 -> leaf_557
leaf_557  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_541 -> leaf_558
leaf_558  [color=Gray,shape=rectangle,fontname=Inconsolata,label=":[a-drawer]:
contents
:/[a-drawer]:

This closes to a single Unicode character, such as ⦿, which can't be deleted"]
block_542 -> leaf_559
leaf_559  [color=Gray,shape=rectangle,fontname=Inconsolata,label="without opening it. Deleting into an ordinary fold marker opens the fold,
deleting towards a drawer marker skips past it.
"]
block_543 -> leaf_560
leaf_560  [color=Gray,shape=rectangle,fontname=Inconsolata,label="=a-drawer=  is  a type,  not  a  name, something  like  =weave=  or =tangle=  in
practice. This may or  may not be supported with a =#weave=  tag. 
"]
block_544 -> leaf_561
leaf_561  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I'm not entirely sure how to interact names with drawers, perhaps like this:
"]
block_545 -> { structure_562 structure_563 structure_564}
{rank=same; structure_562 structure_563 structure_564}

structure_562 [label="structure"]

structure_563 [label="structure"]

structure_564 [label="structure"]


structure_562 -> { hashline_565}
{rank=same; hashline_565}

hashline_565 [label="hashline"]


hashline_565 -> { hashtag_566}
{rank=same; hashtag_566}

hashtag_566 [label="hashtag"]


hashtag_566 -> leaf_567
leaf_567  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_563 -> { handleline_568}
{rank=same; handleline_568}

handleline_568 [label="handleline"]


handleline_568 -> { handle_569}
{rank=same; handle_569}

handle_569 [label="handle"]


handle_569 -> leaf_570
leaf_570  [color=Gray,shape=rectangle,fontname=Inconsolata,label="drawer-name"]
structure_564 -> { hashline_571}
{rank=same; hashline_571}

hashline_571 [label="hashline"]


hashline_571 -> { hashtag_572}
{rank=same; hashtag_572}

hashtag_572 [label="hashtag"]


hashtag_572 -> leaf_573
leaf_573  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_545 -> leaf_574
leaf_574  [color=Gray,shape=rectangle,fontname=Inconsolata,label=":[a-drawer]:
- some contents
  - in list form
  - etc.
[:/a-drawer]:


Under the  hood, a  drawer is just  a chunked  block owned by  a tag.  An editor"]
block_546 -> leaf_575
leaf_575  [color=Gray,shape=rectangle,fontname=Inconsolata,label="should keep it closed unless it's  open, those are the only additional semantics
associated.
"]
block_547 -> leaf_576
leaf_576  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This lets master wizards embed unobtrusive magic into documents for apprentice
wizards to spell with.
"]
block_548 -> leaf_577
leaf_577  [color=Gray,shape=rectangle,fontname=Inconsolata,label="An inline drawer looks like =:[[some contents]]:=.  As usual when we say \"inline\" it
can be as long as you want. Being anonymous, because untagged, the only semantics
of such a drawer are to hide the contents in source mode. 
"]
section_330 -> leaf_578
leaf_578  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Drawers

A drawer is a block that's hidden by default. The computer sees it,
the user sees ⦿, or a similar rune.

#+BEGIN_EXAMPLE
:[a-drawer]:
contents
:/[a-drawer]:
#+END_EXAMPLE

This closes to a single Unicode character, such as ⦿, which can't be deleted
without opening it. Deleting into an ordinary fold marker opens the fold,
deleting towards a drawer marker skips past it.

=a-drawer=  is  a type,  not  a  name, something  like  =weave=  or =tangle=  in
practice. This may or  may not be supported with a =#weave=  tag. 

I'm not entirely sure how to interact names with drawers, perhaps like this:

#+begin_example
:[a-drawer]:
@drawer-name
- some contents
  - in list form
  - etc.
[:/a-drawer]:
#+end_example


Under the  hood, a  drawer is just  a chunked  block owned by  a tag.  An editor
should keep it closed unless it's  open, those are the only additional semantics
associated.

This lets master wizards embed unobtrusive magic into documents for apprentice
wizards to spell with.

An inline drawer looks like =:[[some contents]]:=.  As usual when we say \"inline\" it
can be as long as you want. Being anonymous, because untagged, the only semantics
of such a drawer are to hide the contents in source mode. 

*"]
section_331 -> { header_579 block_580 block_581 block_582 block_583 section_584}
{rank=same; header_579 block_580 block_581 block_582 block_583 section_584}

header_579 [label="3 : Runes"]

block_580 [label="block 732-735"]

block_581 [label="block 736-738"]

block_582 [label="block 739-740"]

block_583 [label="block 741-741"]

section_584 [label="section: 742-742"]


block_580 -> leaf_585
leaf_585  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
After drawers is as good a place to put runes as any.
"]
block_581 -> leaf_586
leaf_586  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Runes are characters drawn from the pictographic zones of Unicode,
which describe semantic activity within a document.
"]
block_582 -> leaf_587
leaf_587  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Contra Org, when we have something like the aformentioned:
"]
block_583 -> { structure_588}
{rank=same; structure_588}

structure_588 [label="structure"]


structure_588 -> { hashline_589}
{rank=same; hashline_589}

hashline_589 [label="hashline"]


hashline_589 -> { hashtag_590}
{rank=same; hashtag_590}

hashtag_590 [label="hashtag"]


hashtag_590 -> leaf_591
leaf_591  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_583 -> leaf_592
leaf_592  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_584 -> { header_593 block_594 section_595}
{rank=same; header_593 block_594 section_595}

header_593 [label="1 : Top Header ▼"]

block_594 [label="block 742-742"]

section_595 [label="section: 743-924"]


block_594 -> leaf_596
leaf_596  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_595 -> { header_597 block_598 block_599 block_600 block_601 block_602 block_603 block_604 block_605 section_606 section_607 section_608 section_609 section_610}
{rank=same; header_597 block_598 block_599 block_600 block_601 block_602 block_603 block_604 block_605 section_606 section_607 section_608 section_609 section_610}

header_597 [label="2 : Second Header ►"]

block_598 [label="block 743-749"]

block_599 [label="block 750-752"]

block_600 [label="block 753-755"]

block_601 [label="block 756-757"]

block_602 [label="block 758-760"]

block_603 [label="block 761-765"]

block_604 [label="block 766-768"]

block_605 [label="block 769-924"]

section_606 [label="section: 772-822"]

section_607 [label="section: 823-843"]

section_608 [label="section: 844-910"]

section_609 [label="section: 911-924"]

section_610 [label="section: 925-963"]


block_598 -> { structure_611}
{rank=same; structure_611}

structure_611 [label="structure"]


structure_611 -> { hashline_612}
{rank=same; hashline_612}

hashline_612 [label="hashline"]


hashline_612 -> { hashtag_613}
{rank=same; hashtag_613}

hashtag_613 [label="hashtag"]


hashtag_613 -> leaf_614
leaf_614  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_598 -> leaf_615
leaf_615  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
or the dot which represents a drawer =⦿=, the Unicode character
is actually present in the document.

This tidily preserves the state indicated by the sigil through"]
block_599 -> leaf_616
leaf_616  [color=Gray,shape=rectangle,fontname=Inconsolata,label="any transformation we may take. If you load up last Wednesday's
version of something, it will be in last Wednesday's fold state.
"]
block_600 -> leaf_617
leaf_617  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This lets us have richer folding semantics, like \"don't unfold when
cycling\". It lets us have richer drawer semantics, and so on.
"]
block_601 -> leaf_618
leaf_618  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We will reserve a number of characters for this purpose, at least
"]
block_602 -> leaf_619
leaf_619  [color=Gray,shape=rectangle,fontname=Inconsolata,label="| ▼ |  ► | ⦿ |
    |
"]
block_603 -> leaf_620
leaf_620  [color=Gray,shape=rectangle,fontname=Inconsolata,label="It's legal to delete runes, like anything else. It's also legal to
insert them manually. Neither of these paradigms is typical;
deleting into a rune may or may not cause it to disappear in
normal edit mode.
"]
block_604 -> leaf_621
leaf_621  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Runes, like absolutely everything in Grimoire, are prose if encountered
in a context where they aren't valid structure.
"]
block_605 -> leaf_622
leaf_622  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We will most likely reuse runes inside cookies, though it's just as valid
and quite typical to use normal letters or words.
"]
section_606 -> { header_623 block_624 block_625 block_626 block_627 block_628 block_629 block_630}
{rank=same; header_623 block_624 block_625 block_626 block_627 block_628 block_629 block_630}

header_623 [label="3 : Lists"]

block_624 [label="block 772-779"]

block_625 [label="block 780-781"]

block_626 [label="block 782-796"]

block_627 [label="block 797-798"]

block_628 [label="block 799-800"]

block_629 [label="block 801-820"]

block_630 [label="block 821-822"]


block_624 -> leaf_631
leaf_631  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Something that irks me about Org is basically historic. It was a TODO
list first, and became a heiarchical document editor later. As a result,
the functions that let you tag, track, and so on, are in the wrong place;
an Org file has to choose whether or not it's a task list or a document,
which doesn't fit the metalanguage paradigm cleanly.
"]
block_625 -> leaf_632
leaf_632  [color=Gray,shape=rectangle,fontname=Inconsolata,label="A list looks like this:
"]
block_626 -> { structure_633 structure_634}
{rank=same; structure_633 structure_634}

structure_633 [label="structure"]

structure_634 [label="structure"]


structure_633 -> { hashline_635}
{rank=same; hashline_635}

hashline_635 [label="hashline"]


hashline_635 -> { hashtag_636}
{rank=same; hashtag_636}

hashtag_636 [label="hashtag"]


hashtag_636 -> leaf_637
leaf_637  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_634 -> { hashline_638}
{rank=same; hashline_638}

hashline_638 [label="hashline"]


hashline_638 -> { hashtag_639}
{rank=same; hashtag_639}

hashtag_639 [label="hashtag"]


hashtag_639 -> leaf_640
leaf_640  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_626 -> leaf_641
leaf_641  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- a list
  - can have some data
  - key :: value
  - [ ] boolean
  - multiple choice #relevant-elsewhere
    - ( ) A
    - (*) B
    - ( ) C
  - Can contain ordered Lists
    1. Such as this
    2. And this

Similar enough to Org, though `+` and `*` aren't equivalent options,"]
block_627 -> leaf_642
leaf_642  [color=Gray,shape=rectangle,fontname=Inconsolata,label="and we have radio buttons.
"]
block_628 -> leaf_643
leaf_643  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We also have whitespace lists:
"]
block_629 -> { structure_644}
{rank=same; structure_644}

structure_644 [label="structure"]


structure_644 -> { hashline_645}
{rank=same; hashline_645}

hashline_645 [label="hashline"]


hashline_645 -> { hashtag_646}
{rank=same; hashtag_646}

hashtag_646 [label="hashtag"]


hashtag_646 -> leaf_647
leaf_647  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_629 -> leaf_648
leaf_648  [color=Gray,shape=rectangle,fontname=Inconsolata,label="~ a whitespace list
   has data
   organized by indentation:
     the colon is prose
     [ ] [todo] checkboxes :fred:
   also radio buttons
     (*) as you might expect
   multiple lines may be spanned \\
   by C-style backslash newlines,\\
     level is the same as long as \\
  you keep escaping, though this is\\
  confusing.
   this is the next item
   you can number them:
     1. apple
     2. persimmon
     3. mangosteen

and we're done."]
block_630 -> { structure_649}
{rank=same; structure_649}

structure_649 [label="structure"]


structure_649 -> { hashline_650}
{rank=same; hashline_650}

hashline_650 [label="hashline"]


hashline_650 -> { hashtag_651}
{rank=same; hashtag_651}

hashtag_651 [label="hashtag"]


hashtag_651 -> leaf_652
leaf_652  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_630 -> leaf_653
leaf_653  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_606 -> leaf_654
leaf_654  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Lists

Something that irks me about Org is basically historic. It was a TODO
list first, and became a heiarchical document editor later. As a result,
the functions that let you tag, track, and so on, are in the wrong place;
an Org file has to choose whether or not it's a task list or a document,
which doesn't fit the metalanguage paradigm cleanly.

A list looks like this:

#+BEGIN_EXAMPLE
- a list
  - can have some data
  - key :: value
  - [ ] boolean
  - multiple choice #relevant-elsewhere
    - ( ) A
    - (*) B
    - ( ) C
  - Can contain ordered Lists
    1. Such as this
    2. And this
#+END_EXAMPLE

Similar enough to Org, though `+` and `*` aren't equivalent options,
and we have radio buttons.

We also have whitespace lists:

#+BEGIN_EXAMPLE
~ a whitespace list
   has data
   organized by indentation:
     the colon is prose
     [ ] [todo] checkboxes :fred:
   also radio buttons
     (*) as you might expect
   multiple lines may be spanned \\
   by C-style backslash newlines,\\
     level is the same as long as \\
  you keep escaping, though this is\\
  confusing.
   this is the next item
   you can number them:
     1. apple
     2. persimmon
     3. mangosteen

and we're done.
#+END_EXAMPLE

*"]
section_607 -> { header_655 block_656 block_657 block_658 block_659 block_660}
{rank=same; header_655 block_656 block_657 block_658 block_659 block_660}

header_655 [label="3 : Embedded Data"]

block_656 [label="block 823-829"]

block_657 [label="block 830-832"]

block_658 [label="block 833-835"]

block_659 [label="block 836-840"]

block_660 [label="block 841-843"]


block_656 -> leaf_661
leaf_661  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Anything found in prose between ={= and =}= is EDN. Note that the
outermost pair of curlies denotes a boundary. ={ foo }= is the symbol
foo, ={ foo bar }= is the symbol *foo* and the symbol *bar*, ={{foo bar}}= is
a map with key *foo* and value *bar*.
"]
block_657 -> leaf_662
leaf_662  [color=Gray,shape=rectangle,fontname=Inconsolata,label="To quote the [[https://github.com/edn-format/edn][spec]], \"There is no enclosing element at the top level\". The
braces mark the boundaries of the data region.
"]
block_658 -> leaf_663
leaf_663  [color=Gray,shape=rectangle,fontname=Inconsolata,label="There is a mapping between lists and EDN, the basics of which will be clear
to the astute reader. The non-basics are unclear to the author as well.
"]
block_659 -> leaf_664
leaf_664  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Unresolved: may data be inlined into prose? What would that even mean?
slap some colors on it in the document? If we want to provide a 'this is
code but not for interpretation' mark, we will, it won't be EDN specific.
Inlining colorized code is not high on my todo list.
"]
block_660 -> leaf_665
leaf_665  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I don't think you can. Embeds are down here with lists and
tables in 'things you can't inline', for now.
"]
section_607 -> leaf_666
leaf_666  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Embedded Data

Anything found in prose between ={= and =}= is EDN. Note that the
outermost pair of curlies denotes a boundary. ={ foo }= is the symbol
foo, ={ foo bar }= is the symbol *foo* and the symbol *bar*, ={{foo bar}}= is
a map with key *foo* and value *bar*.

To quote the [[https://github.com/edn-format/edn][spec]], \"There is no enclosing element at the top level\". The
braces mark the boundaries of the data region.

There is a mapping between lists and EDN, the basics of which will be clear
to the astute reader. The non-basics are unclear to the author as well.

Unresolved: may data be inlined into prose? What would that even mean?
slap some colors on it in the document? If we want to provide a 'this is
code but not for interpretation' mark, we will, it won't be EDN specific.
Inlining colorized code is not high on my todo list.

I don't think you can. Embeds are down here with lists and
tables in 'things you can't inline', for now.

*"]
section_608 -> { header_667 block_668 block_669 block_670 block_671 block_672 block_673 block_674 block_675 block_676 block_677 block_678 block_679 block_680 block_681 block_682 block_683}
{rank=same; header_667 block_668 block_669 block_670 block_671 block_672 block_673 block_674 block_675 block_676 block_677 block_678 block_679 block_680 block_681 block_682 block_683}

header_667 [label="3 : Tables"]

block_668 [label="block 844-848"]

block_669 [label="block 849-852"]

block_670 [label="block 853-855"]

block_671 [label="block 856-857"]

block_672 [label="block 858-863"]

block_673 [label="block 864-869"]

block_674 [label="block 870-875"]

block_675 [label="block 876-882"]

block_676 [label="block 883-889"]

block_677 [label="block 890-891"]

block_678 [label="block 892-896"]

block_679 [label="block 897-898"]

block_680 [label="block 899-901"]

block_681 [label="block 902-904"]

block_682 [label="block 905-906"]

block_683 [label="block 907-910"]


block_668 -> leaf_684
leaf_684  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The way tables work in Babel is fine and needs little polish. Any modest
improvements we make will be in the face of considerable experience.
"]
block_669 -> leaf_685
leaf_685  [color=Gray,shape=rectangle,fontname=Inconsolata,label="For example, I expect there's a way to make multiple literal rows serve
as a single row in existing Org, but I don't know what it is. I'll be
playing around a lot in the coming weeks, I hope.
"]
block_670 -> leaf_686
leaf_686  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Composability being an overarching goal, we can embed anything in a table
that we would put elsewhere.
"]
block_671 -> leaf_687
leaf_687  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Looks something like this:
"]
block_672 -> { structure_688}
{rank=same; structure_688}

structure_688 [label="structure"]


structure_688 -> { hashline_689}
{rank=same; hashline_689}

hashline_689 [label="hashline"]


hashline_689 -> { hashtag_690}
{rank=same; hashtag_690}

hashtag_690 [label="hashtag"]


hashtag_690 -> leaf_691
leaf_691  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_672 -> leaf_692
leaf_692  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  | a table           | very simple         |
  |-------------------+---------------------|
  | some rows         | with *bold* stuff   |
  | \"\"literal stuff\"\" | etc.                |
  | 23                | This gets filled in |"]
block_673 -> { structure_693 structure_694}
{rank=same; structure_693 structure_694}

structure_693 [label="structure"]

structure_694 [label="structure"]


structure_693 -> { hashline_695}
{rank=same; hashline_695}

hashline_695 [label="hashline"]


hashline_695 -> { hashtag_696}
{rank=same; hashtag_696}

hashtag_696 [label="hashtag"]


hashtag_696 -> leaf_697
leaf_697  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_694 -> { hashline_698}
{rank=same; hashline_698}

hashline_698 [label="hashline"]


hashline_698 -> { hashtag_699}
{rank=same; hashtag_699}

hashtag_699 [label="hashtag"]


hashtag_699 -> leaf_700
leaf_700  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_673 -> leaf_701
leaf_701  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Another option would be a formula list:
"]
block_674 -> { structure_702}
{rank=same; structure_702}

structure_702 [label="structure"]


structure_702 -> { hashline_703}
{rank=same; hashline_703}

hashline_703 [label="hashline"]


hashline_703 -> { hashtag_704}
{rank=same; hashtag_704}

hashtag_704 [label="hashtag"]


hashtag_704 -> leaf_705
leaf_705  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_674 -> leaf_706
leaf_706  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  | a table           | very simple         |
  |-------------------+---------------------|
  | some rows         | with *bold* stuff   |
  | \"\"literal stuff\"\" | $23 :expenses:      |
  | 23                | This gets filled in |"]
block_675 -> { structure_707 structure_708}
{rank=same; structure_707 structure_708}

structure_707 [label="structure"]

structure_708 [label="structure"]


structure_707 -> { hashline_709}
{rank=same; hashline_709}

hashline_709 [label="hashline"]


hashline_709 -> { hashtag_710}
{rank=same; hashtag_710}

hashtag_710 [label="hashtag"]


hashtag_710 -> leaf_711
leaf_711  [color=Gray,shape=rectangle,fontname=Inconsolata,label="formulas"]
structure_708 -> { hashline_712}
{rank=same; hashline_712}

hashline_712 [label="hashline"]


hashline_712 -> { hashtag_713}
{rank=same; hashtag_713}

hashtag_713 [label="hashtag"]


hashtag_713 -> leaf_714
leaf_714  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_675 -> leaf_715
leaf_715  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   - [X] @3$2 :: @on-formula
   - [ ] @1$1 :: @off-formula

This is a point for Grimoire I dare say.
"]
block_676 -> leaf_716
leaf_716  [color=Gray,shape=rectangle,fontname=Inconsolata,label="A subtle point of parsing I'm not sure is correct is =#formulas -=
or =- #formulas=. I feel like by normal associativity the latter
attaches the tag to the list, then nothing to the tag,
since the rule is a tag preceded only by whitespace owns the line
after it and indentations below it. The tag doesn't affect the indentation level
of the =-=, which could be confusing but won't be.
"]
block_677 -> leaf_717
leaf_717  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We should be able to tag tables like this:
"]
block_678 -> { structure_718 structure_719}
{rank=same; structure_718 structure_719}

structure_718 [label="structure"]

structure_719 [label="structure"]


structure_718 -> { hashline_720}
{rank=same; hashline_720}

hashline_720 [label="hashline"]


hashline_720 -> { hashtag_721}
{rank=same; hashtag_721}

hashtag_721 [label="hashtag"]


hashtag_721 -> leaf_722
leaf_722  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_719 -> { handleline_723}
{rank=same; handleline_723}

handleline_723 [label="handleline"]


handleline_723 -> { handle_724}
{rank=same; handle_724}

handle_724 [label="handle"]


handle_724 -> leaf_725
leaf_725  [color=Gray,shape=rectangle,fontname=Inconsolata,label="named-table"]
block_678 -> leaf_726
leaf_726  [color=Gray,shape=rectangle,fontname=Inconsolata,label="             |-----------+-----------|
             |           |           |
"]
block_679 -> { structure_727}
{rank=same; structure_727}

structure_727 [label="structure"]


structure_727 -> { hashline_728}
{rank=same; hashline_728}

hashline_728 [label="hashline"]


hashline_728 -> { hashtag_729}
{rank=same; hashtag_729}

hashtag_729 [label="hashtag"]


hashtag_729 -> leaf_730
leaf_730  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_679 -> leaf_731
leaf_731  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_680 -> { structure_732}
{rank=same; structure_732}

structure_732 [label="structure"]


structure_732 -> { hashline_733}
{rank=same; hashline_733}

hashline_733 [label="hashline"]


hashline_733 -> { hashtag_734}
{rank=same; hashtag_734}

hashtag_734 [label="hashtag"]


hashtag_734 -> leaf_735
leaf_735  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_680 -> leaf_736
leaf_736  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Note the intermediate indentation of the =#formulas:= category tag."]
block_681 -> leaf_737
leaf_737  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Totally okay in this context, doesn't trigger Nim rules because the table
associates to the tag anyway.
"]
block_682 -> leaf_738
leaf_738  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This gives us a nice left gutter which I propose we can use in various ways.
"]
block_683 -> leaf_739
leaf_739  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This section can get much longer. Generalizing how tables work is incredibly
powerful. My dream is to embed APL into Grimoire. Give me an excuse to
finally learn it!
"]
section_608 -> leaf_740
leaf_740  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Tables

The way tables work in Babel is fine and needs little polish. Any modest
improvements we make will be in the face of considerable experience.

For example, I expect there's a way to make multiple literal rows serve
as a single row in existing Org, but I don't know what it is. I'll be
playing around a lot in the coming weeks, I hope.

Composability being an overarching goal, we can embed anything in a table
that we would put elsewhere.

Looks something like this:

#+begin_src org
  | a table           | very simple         |
  |-------------------+---------------------|
  | some rows         | with *bold* stuff   |
  | \"\"literal stuff\"\" | etc.                |
  | 23                | This gets filled in |
  #formulas {{ @2$2, @a-formula }}
#+end_src


Another option would be a formula list:

#+begin_src org
  | a table           | very simple         |
  |-------------------+---------------------|
  | some rows         | with *bold* stuff   |
  | \"\"literal stuff\"\" | $23 :expenses:      |
  | 23                | This gets filled in |
#formulas -
   - [X] @3$2 :: @on-formula
   - [ ] @1$1 :: @off-formula
#+end_src

This is a point for Grimoire I dare say.

A subtle point of parsing I'm not sure is correct is =#formulas -=
or =- #formulas=. I feel like by normal associativity the latter
attaches the tag to the list, then nothing to the tag,
since the rule is a tag preceded only by whitespace owns the line
after it and indentations below it. The tag doesn't affect the indentation level
of the =-=, which could be confusing but won't be.

We should be able to tag tables like this:

#+begin_src org
@named-table | some data | more data |
             |-----------+-----------|
             |           |           |

    #formulas: etc...

#+end_src

Note the intermediate indentation of the =#formulas:= category tag.
Totally okay in this context, doesn't trigger Nim rules because the table
associates to the tag anyway.

This gives us a nice left gutter which I propose we can use in various ways.

This section can get much longer. Generalizing how tables work is incredibly
powerful. My dream is to embed APL into Grimoire. Give me an excuse to
finally learn it!

*"]
section_609 -> { header_741 block_742 block_743 block_744 block_745 block_746}
{rank=same; header_741 block_742 block_743 block_744 block_745 block_746}

header_741 [label="3 : Clocks"]

block_742 [label="block 911-914"]

block_743 [label="block 915-916"]

block_744 [label="block 917-918"]

block_745 [label="block 919-920"]

block_746 [label="block 921-924"]


block_742 -> leaf_747
leaf_747  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I think timestamps are just a drawer you put a timestamp in.
"]
block_743 -> leaf_748
leaf_748  [color=Gray,shape=rectangle,fontname=Inconsolata,label="That drawer can collapse and look like ⏱.
"]
block_744 -> leaf_749
leaf_749  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Or we can collapse it into something from the set containing 🕞.
"]
block_745 -> leaf_750
leaf_750  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Which normal Emacs doesn't display. I really need to go Japanese soon.
"]
block_746 -> leaf_751
leaf_751  [color=Gray,shape=rectangle,fontname=Inconsolata,label="But it would be just adorable to have a little clock representing the timestamp.
Emoji are quirky but the set contains useful icons, and it's Unicode.
Grimoire supports Unicode.
"]
section_609 -> leaf_752
leaf_752  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Clocks

I think timestamps are just a drawer you put a timestamp in.

That drawer can collapse and look like ⏱.

Or we can collapse it into something from the set containing 🕞.

Which normal Emacs doesn't display. I really need to go Japanese soon.

But it would be just adorable to have a little clock representing the timestamp.
Emoji are quirky but the set contains useful icons, and it's Unicode.
Grimoire supports Unicode.

*"]
section_610 -> { header_753 block_754 block_755 block_756 block_757 section_758 section_759}
{rank=same; header_753 block_754 block_755 block_756 block_757 section_758 section_759}

header_753 [label="3 : Code"]

block_754 [label="block 925-928"]

block_755 [label="block 929-933"]

block_756 [label="block 934-937"]

block_757 [label="block 938-963"]

section_758 [label="section: 946-963"]

section_759 [label="section: 964-1084"]


block_754 -> leaf_760
leaf_760  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The place where it all comes together.
"]
block_755 -> leaf_761
leaf_761  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Grimoire has a servant language, Lua by default, but this
is of course configurable. Eventually we'll write Clu,
it's a race to see which project is finished first but they
have common dependencies, surprise, surprise.
"]
block_756 -> leaf_762
leaf_762  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Code and data are yin and yang in Grimoire. Code embedded in
documents is executed in various ways and times; comments within
code blocks are themselves in Grimoire data format, and so on.
"]
block_757 -> leaf_763
leaf_763  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Given a single language Grimoire text, we can perform a mechanical
figure-ground reversal, such that data blocks become comments and
code blocks become live. We have many more sophisticated weave and
tangle operations, but this is a designed-in property that will prove
handy: sometimes you want to take code, org it up, and then flip it
into a literate context. Upgrade path for existing codebases.

"]
section_758 -> { header_764 block_765 block_766 block_767 block_768}
{rank=same; header_764 block_765 block_766 block_767 block_768}

header_764 [label="4 : Inline Code"]

block_765 [label="block 946-951"]

block_766 [label="block 952-958"]

block_767 [label="block 959-960"]

block_768 [label="block 961-963"]


block_765 -> leaf_769
leaf_769  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Inline code is written =`4 + 5`=. It executes in something similar to
:function mode in Babel, the call is as though it were wrapped in a function
call that looks like:
"]
block_766 -> { structure_770 structure_771}
{rank=same; structure_770 structure_771}

structure_770 [label="structure"]

structure_771 [label="structure"]


structure_770 -> { hashline_772}
{rank=same; hashline_772}

hashline_772 [label="hashline"]


hashline_772 -> { hashtag_773}
{rank=same; hashtag_773}

hashtag_773 [label="hashtag"]


hashtag_773 -> leaf_774
leaf_774  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_771 -> { hashline_775}
{rank=same; hashline_775}

hashline_775 [label="hashline"]


hashline_775 -> { hashtag_776}
{rank=same; hashtag_776}

hashtag_776 [label="hashtag"]


hashtag_776 -> leaf_777
leaf_777  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_766 -> leaf_778
leaf_778  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return tostring((function() return
   4 + 5
end)())

With the difference that the inline servant language is run in a session mode by default,"]
block_767 -> leaf_779
leaf_779  [color=Gray,shape=rectangle,fontname=Inconsolata,label="maintaining state between calls.
"]
block_768 -> leaf_780
leaf_780  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Anything named exists as a data structure in the helper language. This makes it easy to
refer to a block that contains a self-reference, so these are stored in a cycle-safe way.
"]
section_758 -> leaf_781
leaf_781  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Inline Code

Inline code is written =`4 + 5`=. It executes in something similar to
:function mode in Babel, the call is as though it were wrapped in a function
call that looks like:

#+begin_src lua
return tostring((function() return
   4 + 5
end)())
#+end_src

With the difference that the inline servant language is run in a session mode by default,
maintaining state between calls.

Anything named exists as a data structure in the helper language. This makes it easy to
refer to a block that contains a self-reference, so these are stored in a cycle-safe way.

*"]
section_759 -> { header_782 block_783 block_784 block_785 block_786 block_787 block_788 block_789 block_790 block_791 block_792 block_793 block_794 block_795 block_796 block_797 block_798 block_799 block_800 block_801 block_802 block_803 block_804 block_805 block_806 block_807 block_808 block_809 block_810 block_811 block_812 section_813}
{rank=same; header_782 block_783 block_784 block_785 block_786 block_787 block_788 block_789 block_790 block_791 block_792 block_793 block_794 block_795 block_796 block_797 block_798 block_799 block_800 block_801 block_802 block_803 block_804 block_805 block_806 block_807 block_808 block_809 block_810 block_811 block_812 section_813}

header_782 [label="4 : Code Blocks"]

block_783 [label="block 964-967"]

block_784 [label="block 968-969"]

block_785 [label="block 970-974"]

block_786 [label="block 975-977"]

block_787 [label="block 978-979"]

block_788 [label="block 980-982"]

block_789 [label="block 983-988"]

block_790 [label="block 989-990"]

block_791 [label="block 991-996"]

block_792 [label="block 997-999"]

block_793 [label="block 1000-1001"]

block_794 [label="block 1002-1005"]

block_795 [label="block 1006-1007"]

block_796 [label="block 1008-1015"]

block_797 [label="block 1016-1020"]

block_798 [label="block 1021-1026"]

block_799 [label="block 1027-1031"]

block_800 [label="block 1032-1032"]

block_801 [label="block 1033-1036"]

block_802 [label="block 1037-1038"]

block_803 [label="block 1039-1041"]

block_804 [label="block 1042-1047"]

block_805 [label="block 1048-1052"]

block_806 [label="block 1053-1055"]

block_807 [label="block 1056-1059"]

block_808 [label="block 1060-1065"]

block_809 [label="block 1066-1068"]

block_810 [label="block 1069-1074"]

block_811 [label="block 1075-1076"]

block_812 [label="block 1077-1084"]

section_813 [label="section: 1085-1155"]


block_783 -> leaf_814
leaf_814  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The =`inline`= syntax works like the rest, you may use any number of backticks to enclose a form.
"]
block_784 -> leaf_815
leaf_815  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Something like:
"]
block_785 -> { structure_816}
{rank=same; structure_816}

structure_816 [label="structure"]


structure_816 -> { hashline_817}
{rank=same; hashline_817}

hashline_817 [label="hashline"]


hashline_817 -> { hashtag_818}
{rank=same; hashtag_818}

hashtag_818 [label="hashtag"]


hashtag_818 -> leaf_819
leaf_819  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_785 -> leaf_820
leaf_820  [color=Gray,shape=rectangle,fontname=Inconsolata,label="```
-- some code

```"]
block_786 -> { structure_821}
{rank=same; structure_821}

structure_821 [label="structure"]


structure_821 -> { hashline_822}
{rank=same; hashline_822}

hashline_822 [label="hashline"]


hashline_822 -> { hashtag_823}
{rank=same; hashtag_823}

hashtag_823 [label="hashtag"]


hashtag_823 -> leaf_824
leaf_824  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_786 -> leaf_825
leaf_825  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
is just another inline block, it's evaluated and expanded in-place into the weave, if it's named,"]
block_787 -> leaf_826
leaf_826  [color=Gray,shape=rectangle,fontname=Inconsolata,label="it is evaluated when referenced. This:
"]
block_788 -> { structure_827 structure_828}
{rank=same; structure_827 structure_828}

structure_827 [label="structure"]

structure_828 [label="structure"]


structure_827 -> { hashline_829}
{rank=same; hashline_829}

hashline_829 [label="hashline"]


hashline_829 -> { hashtag_830}
{rank=same; hashtag_830}

hashtag_830 [label="hashtag"]


hashtag_830 -> leaf_831
leaf_831  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_828 -> { handleline_832}
{rank=same; handleline_832}

handleline_832 [label="handleline"]


handleline_832 -> { handle_833}
{rank=same; handle_833}

handle_833 [label="handle"]


handle_833 -> leaf_834
leaf_834  [color=Gray,shape=rectangle,fontname=Inconsolata,label="named-block"]
block_788 -> leaf_835
leaf_835  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_789 -> { structure_836}
{rank=same; structure_836}

structure_836 [label="structure"]


structure_836 -> { hashline_837}
{rank=same; hashline_837}

hashline_837 [label="hashline"]


hashline_837 -> { hashtag_838}
{rank=same; hashtag_838}

hashtag_838 [label="hashtag"]


hashtag_838 -> leaf_839
leaf_839  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_789 -> leaf_840
leaf_840  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some code
```

is a named, *prose* block, which contains inline code.
"]
block_790 -> leaf_841
leaf_841  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Separated code blocks use special tags:
"]
block_791 -> { codeblock_842}
{rank=same; codeblock_842}

codeblock_842 [label="code block 993-995"]


codeblock_842 -> leaf_843
leaf_843  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
block_791 -> leaf_844
leaf_844  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_792 -> { structure_845}
{rank=same; structure_845}

structure_845 [label="structure"]


structure_845 -> { hashline_846}
{rank=same; hashline_846}

hashline_846 [label="hashline"]


hashline_846 -> { hashtag_847}
{rank=same; hashtag_847}

hashtag_847 [label="hashtag"]


hashtag_847 -> leaf_848
leaf_848  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_792 -> leaf_849
leaf_849  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The =!= and =/= characters may be multiplied if multiple levels of"]
block_793 -> leaf_850
leaf_850  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nesting apply. As indeed they might in a Grimoire code block.
"]
block_794 -> leaf_851
leaf_851  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We need a good runtime. Playing the Inception game
with Grimoire should be an amusing headache, not a dog-slow
system killer.
"]
block_795 -> leaf_852
leaf_852  [color=Gray,shape=rectangle,fontname=Inconsolata,label="They may be named like anything else:
"]
block_796 -> { codeblock_853 structure_854}
{rank=same; codeblock_853 structure_854}

codeblock_853 [label="code block 1009-1011"]

structure_854 [label="structure"]


codeblock_853 -> leaf_855
leaf_855  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
structure_854 -> { hashline_856}
{rank=same; hashline_856}

hashline_856 [label="hashline"]


hashline_856 -> { hashtag_857}
{rank=same; hashtag_857}

hashtag_857 [label="hashtag"]


hashtag_857 -> leaf_858
leaf_858  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_796 -> leaf_859
leaf_859  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
They may be marked for evaluation:
"]
block_797 -> { codeblock_860}
{rank=same; codeblock_860}

codeblock_860 [label="code block 1017-1019"]


codeblock_860 -> leaf_861
leaf_861  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
block_797 -> leaf_862
leaf_862  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_798 -> { codeblock_863}
{rank=same; codeblock_863}

codeblock_863 [label="code block 1023-1025"]


codeblock_863 -> leaf_864
leaf_864  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return 4 + 5"]
block_798 -> leaf_865
leaf_865  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_799 -> { structure_866}
{rank=same; structure_866}

structure_866 [label="structure"]


structure_866 -> { hashline_867}
{rank=same; hashline_867}

hashline_867 [label="hashline"]


hashline_867 -> { hashtag_868}
{rank=same; hashtag_868}

hashtag_868 [label="hashtag"]


hashtag_868 -> leaf_869
leaf_869  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_799 -> leaf_870
leaf_870  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

-- equivalent:
"]
block_800 -> { structure_871}
{rank=same; structure_871}

structure_871 [label="structure"]


structure_871 -> { handleline_872}
{rank=same; handleline_872}

handleline_872 [label="handleline"]


handleline_872 -> { handle_873}
{rank=same; handle_873}

handle_873 [label="handle"]


handle_873 -> leaf_874
leaf_874  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nine"]
block_800 -> leaf_875
leaf_875  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_801 -> { codeblock_876}
{rank=same; codeblock_876}

codeblock_876 [label="code block 1033-1035"]


codeblock_876 -> leaf_877
leaf_877  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return 4 + 5"]
block_801 -> leaf_878
leaf_878  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_802 -> { structure_879}
{rank=same; structure_879}

structure_879 [label="structure"]


structure_879 -> { hashline_880}
{rank=same; hashline_880}

hashline_880 [label="hashline"]


hashline_880 -> { hashtag_881}
{rank=same; hashtag_881}

hashtag_881 [label="hashtag"]


hashtag_881 -> leaf_882
leaf_882  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_802 -> leaf_883
leaf_883  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_803 -> { structure_884}
{rank=same; structure_884}

structure_884 [label="structure"]


structure_884 -> { hashline_885}
{rank=same; hashline_885}

hashline_885 [label="hashline"]


hashline_885 -> { hashtag_886}
{rank=same; hashtag_886}

hashtag_886 [label="hashtag"]


hashtag_886 -> leaf_887
leaf_887  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_803 -> leaf_888
leaf_888  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Note the =#/lua()= form, which calls the code block, and the =#->= tag, which"]
block_804 -> leaf_889
leaf_889  [color=Gray,shape=rectangle,fontname=Inconsolata,label="marks an anonymous result. =#@nine->= is the automatically generated tag for
the return value of the block named =@nine=, adding =@nine()= to a prose block will
add the number 9 to the weave at that location. *bridge* will either display the result,
the call, or both, configurably, when editing the source, with syntax-highlighting to 
enforce the distinction. 
"]
block_805 -> leaf_890
leaf_890  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Code blocks may be indented as any other blocks, with the associated owership
rules. Code blocks so indented have a logical start equal to their level of
indentation, which is to say the program being called will not see indentation
that is proper to the Grimoire document.
"]
block_806 -> leaf_891
leaf_891  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Code blocks may be placed inside lists, as tables may be, but may not be
explicitly placed inside tables.
"]
block_807 -> leaf_892
leaf_892  [color=Gray,shape=rectangle,fontname=Inconsolata,label="You may insert the result of a named code block in the data context
by simply saying =@a-named-block()=. If there are variables, you may pass
them, =@a-named-block(23, true)= or if you wish, by name:
"]
block_808 -> { structure_893 structure_894 structure_895}
{rank=same; structure_893 structure_894 structure_895}

structure_893 [label="structure"]

structure_894 [label="structure"]

structure_895 [label="structure"]


structure_893 -> { hashline_896}
{rank=same; hashline_896}

hashline_896 [label="hashline"]


hashline_896 -> { hashtag_897}
{rank=same; hashtag_897}

hashtag_897 [label="hashtag"]


hashtag_897 -> leaf_898
leaf_898  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_894 -> { handleline_899}
{rank=same; handleline_899}

handleline_899 [label="handleline"]


handleline_899 -> { handle_900}
{rank=same; handle_900}

handle_900 [label="handle"]


handle_900 -> leaf_901
leaf_901  [color=Gray,shape=rectangle,fontname=Inconsolata,label="a-named-block"]
structure_895 -> { hashline_902}
{rank=same; hashline_902}

hashline_902 [label="hashline"]


hashline_902 -> { hashtag_903}
{rank=same; hashtag_903}

hashtag_903 [label="hashtag"]


hashtag_903 -> leaf_904
leaf_904  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_808 -> leaf_905
leaf_905  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The values will be inserted as per an inline reference.
"]
block_809 -> leaf_906
leaf_906  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Within a formula applied to a table, it is valid to use the description
syntax for a variable to supply an argument to a function.
"]
block_810 -> leaf_907
leaf_907  [color=Gray,shape=rectangle,fontname=Inconsolata,label="There will be further syntax involved in building up the line that
begins a code block. It's considered good form to assign complex
code block headers into distinct tags, and use those, rather than
being explicit and repeating yourself or hiding file-local defaults
in drawers.
"]
block_811 -> leaf_908
leaf_908  [color=Gray,shape=rectangle,fontname=Inconsolata,label="So we prefer something like
"]
block_812 -> { codeblock_909 structure_910}
{rank=same; codeblock_909 structure_910}

codeblock_909 [label="code block 1078-1080"]

structure_910 [label="structure"]


codeblock_909 -> leaf_911
leaf_911  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- some lua code"]
structure_910 -> { hashline_912}
{rank=same; hashline_912}

hashline_912 [label="hashline"]


hashline_912 -> { hashtag_913}
{rank=same; hashtag_913}

hashtag_913 [label="hashtag"]


hashtag_913 -> leaf_914
leaf_914  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_812 -> leaf_915
leaf_915  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
over anything more or less explicit.
"]
section_813 -> { header_916 block_917 section_918 section_919}
{rank=same; header_916 block_917 section_918 section_919}

header_916 [label="1 : Runtime"]

block_917 [label="block 1085-1155"]

section_918 [label="section: 1089-1123"]

section_919 [label="section: 1156-1200"]


block_917 -> leaf_920
leaf_920  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Here, we begin to explore the interactions Grimoire is capable of.
"]
section_918 -> { header_921 block_922 block_923 block_924 block_925 block_926 block_927 block_928 block_929 section_930}
{rank=same; header_921 block_922 block_923 block_924 block_925 block_926 block_927 block_928 block_929 section_930}

header_921 [label="2 : Literate or Live?"]

block_922 [label="block 1089-1093"]

block_923 [label="block 1094-1098"]

block_924 [label="block 1099-1101"]

block_925 [label="block 1102-1105"]

block_926 [label="block 1106-1109"]

block_927 [label="block 1110-1114"]

block_928 [label="block 1115-1119"]

block_929 [label="block 1120-1123"]

section_930 [label="section: 1124-1155"]


block_922 -> leaf_931
leaf_931  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Babel is descended from the tradition of [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]], and
Grimoire inherits this from Babel.
"]
block_923 -> leaf_932
leaf_932  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Grimoire is capable of producing code and documentation in the
classic literate style. This is not the aim of Grimoire: it is
a metalanguage, for working with prose, data, and code in an
integrated fashion.
"]
block_924 -> leaf_933
leaf_933  [color=Gray,shape=rectangle,fontname=Inconsolata,label="What a compiler is to a REPL, literate programming is to living
documents.
"]
block_925 -> leaf_934
leaf_934  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In a literate programming context, we have source, which integrates
code and documentation. The source is then woven into documentation,
and tangled into code. Both are compiled, one is printed, one is run.
"]
block_926 -> leaf_935
leaf_935  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The word 'printed' sounds somewhat archaic, no? The number of tools
Donald Knuth had to write just to write the tools he wanted to write,
and tool the writings he wanted to tool, is simply staggering.
"]
block_927 -> leaf_936
leaf_936  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Traces of that legacy remain in Grimoire. Like Babel, we allow for
LaTeX embedding, with the sugar =`\\latex`=. Starting Lua code with
a backslash is illegal, starting Clu code with a backslash is also
illegal.
"]
block_928 -> leaf_937
leaf_937  [color=Gray,shape=rectangle,fontname=Inconsolata,label="For a Grimoire document to be printed, realistically, in today's world,
it will be translated to LaTeX, hence to PDF, sent off to a print
on demand company, and drop shipped. Some documents may in fact
make this journey, because why not? We aren't oriented around it.
"]
block_929 -> leaf_938
leaf_938  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The basic flow in a Grimoire context is one of excursion and return.
We have tangling and weaving, but also unraveling, where actions taken
within the weave or tangle are integrated back into the source document.
"]
section_930 -> { header_939 block_940 block_941 block_942 block_943 block_944 block_945}
{rank=same; header_939 block_940 block_941 block_942 block_943 block_944 block_945}

header_939 [label="3 : Unraveling the Mystery"]

block_940 [label="block 1124-1131"]

block_941 [label="block 1132-1137"]

block_942 [label="block 1138-1140"]

block_943 [label="block 1141-1145"]

block_944 [label="block 1146-1150"]

block_945 [label="block 1151-1155"]


block_940 -> leaf_946
leaf_946  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
What's unraveling? When I picture Donald Knuth writing literate code,
I picture him with a notebook, writing free-flowing algorithms in a
fashion he refined his entire career. I imagine him carefully transcribing
into Web, running the compiler, going for a stroll around the Stanford
campus, and examining the changes upon his return.
"]
block_941 -> leaf_947
leaf_947  [color=Gray,shape=rectangle,fontname=Inconsolata,label="On the days, and they did happen, when his program was in a state of error,
I picture him returning to his notebook first. While thinking. Perhaps
playing the organ for an hour or two, to relax. He would then correct the
notebook, then the code, then the program, which would be correct now,
most of the time.
"]
block_942 -> leaf_948
leaf_948  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I'm making that all up. But I'd wager I'm not far off the mark. We
don't work like that and most of us can't.
"]
block_943 -> leaf_949
leaf_949  [color=Gray,shape=rectangle,fontname=Inconsolata,label="A tangle is named that because the mapping between it and the source
can be non-trivial. It's quite possible to make it undecidable what to
do with edits to the tangle. it's also possible to move edits from the tangle
back into the source, in most cases, if we structure things well.
"]
block_944 -> leaf_950
leaf_950  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Donald Knuth was unable to print a book that would alter his code. I'm
sure he'd have been delighted to have the ability. Our weaves can easily
be living documents, through in-browser and server side empowerment.
Those changes, too, should make it back into the source.
"]
block_945 -> leaf_951
leaf_951  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Ultimately I imagine many people will prefer to edit and run their
Grimoire documents entirely from a weave that provides a bit of the
ol' WYSIWYG to the experience. Well and good for them, I have my own
view of Heaven, and it isn't Heaven if we don't all fit.
"]
section_930 -> leaf_952
leaf_952  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Unraveling the Mystery

What's unraveling? When I picture Donald Knuth writing literate code,
I picture him with a notebook, writing free-flowing algorithms in a
fashion he refined his entire career. I imagine him carefully transcribing
into Web, running the compiler, going for a stroll around the Stanford
campus, and examining the changes upon his return.

On the days, and they did happen, when his program was in a state of error,
I picture him returning to his notebook first. While thinking. Perhaps
playing the organ for an hour or two, to relax. He would then correct the
notebook, then the code, then the program, which would be correct now,
most of the time.

I'm making that all up. But I'd wager I'm not far off the mark. We
don't work like that and most of us can't.

A tangle is named that because the mapping between it and the source
can be non-trivial. It's quite possible to make it undecidable what to
do with edits to the tangle. it's also possible to move edits from the tangle
back into the source, in most cases, if we structure things well.

Donald Knuth was unable to print a book that would alter his code. I'm
sure he'd have been delighted to have the ability. Our weaves can easily
be living documents, through in-browser and server side empowerment.
Those changes, too, should make it back into the source.

Ultimately I imagine many people will prefer to edit and run their
Grimoire documents entirely from a weave that provides a bit of the
ol' WYSIWYG to the experience. Well and good for them, I have my own
view of Heaven, and it isn't Heaven if we don't all fit.

*"]
section_918 -> leaf_953
leaf_953  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Literate or Live?

Babel is descended from the tradition of [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]], and
Grimoire inherits this from Babel.

Grimoire is capable of producing code and documentation in the
classic literate style. This is not the aim of Grimoire: it is
a metalanguage, for working with prose, data, and code in an
integrated fashion.

What a compiler is to a REPL, literate programming is to living
documents.

In a literate programming context, we have source, which integrates
code and documentation. The source is then woven into documentation,
and tangled into code. Both are compiled, one is printed, one is run.

The word 'printed' sounds somewhat archaic, no? The number of tools
Donald Knuth had to write just to write the tools he wanted to write,
and tool the writings he wanted to tool, is simply staggering.

Traces of that legacy remain in Grimoire. Like Babel, we allow for
LaTeX embedding, with the sugar =`\\latex`=. Starting Lua code with
a backslash is illegal, starting Clu code with a backslash is also
illegal.

For a Grimoire document to be printed, realistically, in today's world,
it will be translated to LaTeX, hence to PDF, sent off to a print
on demand company, and drop shipped. Some documents may in fact
make this journey, because why not? We aren't oriented around it.

The basic flow in a Grimoire context is one of excursion and return.
We have tangling and weaving, but also unraveling, where actions taken
within the weave or tangle are integrated back into the source document.

*"]
section_919 -> { header_954 block_955 block_956 block_957 block_958 section_959 section_960}
{rank=same; header_954 block_955 block_956 block_957 block_958 section_959 section_960}

header_954 [label="2 : Source, Tangle and Weave"]

block_955 [label="block 1156-1160"]

block_956 [label="block 1161-1164"]

block_957 [label="block 1165-1168"]

block_958 [label="block 1169-1200"]

section_959 [label="section: 1173-1200"]

section_960 [label="section: 1201-1219"]


block_955 -> leaf_961
leaf_961  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
These classic concepts from literate programming are central to
the Grimoire paradigm.
"]
block_956 -> leaf_962
leaf_962  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In Grimoire, something like a PDF is not a true weave. It is a product;
much like an image or data derived from a simulation, it is regenerated
when necessary but has no further connection to the Grimoire environment.
"]
block_957 -> leaf_963
leaf_963  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Our first section discusses the format of Grimoire source code. Like Babel,
unlike Web and descendants, it is self-tangling. Grimoire will be tightly
integrated and purpose-built for this task, operating at a REPL+ level.
"]
block_958 -> leaf_964
leaf_964  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We still wish to use it to compile programs written in appropriate languages.
These languages needn't be educated in the ways of Grimoire, imposing this
requirement would be so onerous as to block adoption.
"]
section_959 -> { header_965 block_966 block_967 block_968 block_969 block_970}
{rank=same; header_965 block_966 block_967 block_968 block_969 block_970}

header_965 [label="3 : Unraveling the Tangle"]

block_966 [label="block 1173-1178"]

block_967 [label="block 1179-1182"]

block_968 [label="block 1183-1189"]

block_969 [label="block 1190-1193"]

block_970 [label="block 1194-1200"]


block_966 -> leaf_971
leaf_971  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Babel offers limited facilities for working within source blocks. What it
doesn't offer is the critical 'unravel' operation, which takes changes to
the tangle and integrates them back into the weave.
"]
block_967 -> leaf_972
leaf_972  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This is a partially-solved problem, with Babel able to put comment tags into
the source which allow Emacs to jump back into your actual source from
errors in the tangle.
"]
block_968 -> leaf_973
leaf_973  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This is just not good enough. For any number of reasons, we need to be able
to unravel. I'll cite one: Converting existing codebases over to literacy.
The first step is to recreate the existing program on a source-line-identical
level. The entire existing developer base is familiar with the program already
and isn't going to want to start editing a bunch of Grimoire. They can most
likely be induced to accept readable metadata, and that's it.
"]
block_969 -> leaf_974
leaf_974  [color=Gray,shape=rectangle,fontname=Inconsolata,label="That's all we need. Code is in one of three categories: either it is a single
literal copy from source, it's one of several copies from source, or
it's generated code that's dependent on information in the source.
"]
block_970 -> leaf_975
leaf_975  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We incorporate all changes to the former automatically when we unravel.
Changes to a single version of multiple copies prompts user interaction: do
you want to embed the change as its own source block, propagate it to each
instance, or decline the merge? Changes to generated code are simply
forbidden. If one is doing generation on the code base, working from
the weave is the more comfortable approach.
"]
section_959 -> leaf_976
leaf_976  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Unraveling the Tangle

Babel offers limited facilities for working within source blocks. What it
doesn't offer is the critical 'unravel' operation, which takes changes to
the tangle and integrates them back into the weave.

This is a partially-solved problem, with Babel able to put comment tags into
the source which allow Emacs to jump back into your actual source from
errors in the tangle.

This is just not good enough. For any number of reasons, we need to be able
to unravel. I'll cite one: Converting existing codebases over to literacy.
The first step is to recreate the existing program on a source-line-identical
level. The entire existing developer base is familiar with the program already
and isn't going to want to start editing a bunch of Grimoire. They can most
likely be induced to accept readable metadata, and that's it.

That's all we need. Code is in one of three categories: either it is a single
literal copy from source, it's one of several copies from source, or
it's generated code that's dependent on information in the source.

We incorporate all changes to the former automatically when we unravel.
Changes to a single version of multiple copies prompts user interaction: do
you want to embed the change as its own source block, propagate it to each
instance, or decline the merge? Changes to generated code are simply
forbidden. If one is doing generation on the code base, working from
the weave is the more comfortable approach.

*"]
section_960 -> { header_977 block_978 block_979 block_980 block_981}
{rank=same; header_977 block_978 block_979 block_980 block_981}

header_977 [label="3 : Backweaving"]

block_978 [label="block 1201-1204"]

block_979 [label="block 1205-1209"]

block_980 [label="block 1210-1214"]

block_981 [label="block 1215-1219"]


block_978 -> leaf_982
leaf_982  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
An analogous operation is backweaving.
"]
block_979 -> leaf_983
leaf_983  [color=Gray,shape=rectangle,fontname=Inconsolata,label="A weave in Grimoire is an HTML/CSS/JS document. In other words, a program.
The weave is much closer akin to the source than any tangle. Any Grimoire
program can have a weave view, though it isn't necessary; many will have
no tangle at all, containing the functionality within Grimoire.
"]
block_980 -> leaf_984
leaf_984  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The weave may therefore be manipulated, and we need some way to reflect
those changes back into the source. This can't be automated in a general
way. What we're left with is an EDN protocol for exchanging information
to update the weave in cooperation with some server logic and git.
"]
block_981 -> leaf_985
leaf_985  [color=Gray,shape=rectangle,fontname=Inconsolata,label="So, could you write the server logic for a site as a literate program,
push it to a server that tangles and weaves it, and use the source
and Grimoire/bridge as the sysadmin view? I bet you could, it might
even be fairly popular.
"]
section_960 -> leaf_986
leaf_986  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Backweaving

An analogous operation is backweaving.

A weave in Grimoire is an HTML/CSS/JS document. In other words, a program.
The weave is much closer akin to the source than any tangle. Any Grimoire
program can have a weave view, though it isn't necessary; many will have
no tangle at all, containing the functionality within Grimoire.

The weave may therefore be manipulated, and we need some way to reflect
those changes back into the source. This can't be automated in a general
way. What we're left with is an EDN protocol for exchanging information
to update the weave in cooperation with some server logic and git.

So, could you write the server logic for a site as a literate program,
push it to a server that tangles and weaves it, and use the source
and Grimoire/bridge as the sysadmin view? I bet you could, it might
even be fairly popular."]
section_919 -> leaf_987
leaf_987  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Source, Tangle and Weave

These classic concepts from literate programming are central to
the Grimoire paradigm.

In Grimoire, something like a PDF is not a true weave. It is a product;
much like an image or data derived from a simulation, it is regenerated
when necessary but has no further connection to the Grimoire environment.

Our first section discusses the format of Grimoire source code. Like Babel,
unlike Web and descendants, it is self-tangling. Grimoire will be tightly
integrated and purpose-built for this task, operating at a REPL+ level.

We still wish to use it to compile programs written in appropriate languages.
These languages needn't be educated in the ways of Grimoire, imposing this
requirement would be so onerous as to block adoption.

*** Unraveling the Tangle

Babel offers limited facilities for working within source blocks. What it
doesn't offer is the critical 'unravel' operation, which takes changes to
the tangle and integrates them back into the weave.

This is a partially-solved problem, with Babel able to put comment tags into
the source which allow Emacs to jump back into your actual source from
errors in the tangle.

This is just not good enough. For any number of reasons, we need to be able
to unravel. I'll cite one: Converting existing codebases over to literacy.
The first step is to recreate the existing program on a source-line-identical
level. The entire existing developer base is familiar with the program already
and isn't going to want to start editing a bunch of Grimoire. They can most
likely be induced to accept readable metadata, and that's it.

That's all we need. Code is in one of three categories: either it is a single
literal copy from source, it's one of several copies from source, or
it's generated code that's dependent on information in the source.

We incorporate all changes to the former automatically when we unravel.
Changes to a single version of multiple copies prompts user interaction: do
you want to embed the change as its own source block, propagate it to each
instance, or decline the merge? Changes to generated code are simply
forbidden. If one is doing generation on the code base, working from
the weave is the more comfortable approach.

*"]
section_813 -> leaf_988
leaf_988  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Runtime

Here, we begin to explore the interactions Grimoire is capable of.

** Literate or Live?

Babel is descended from the tradition of [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]], and
Grimoire inherits this from Babel.

Grimoire is capable of producing code and documentation in the
classic literate style. This is not the aim of Grimoire: it is
a metalanguage, for working with prose, data, and code in an
integrated fashion.

What a compiler is to a REPL, literate programming is to living
documents.

In a literate programming context, we have source, which integrates
code and documentation. The source is then woven into documentation,
and tangled into code. Both are compiled, one is printed, one is run.

The word 'printed' sounds somewhat archaic, no? The number of tools
Donald Knuth had to write just to write the tools he wanted to write,
and tool the writings he wanted to tool, is simply staggering.

Traces of that legacy remain in Grimoire. Like Babel, we allow for
LaTeX embedding, with the sugar =`\\latex`=. Starting Lua code with
a backslash is illegal, starting Clu code with a backslash is also
illegal.

For a Grimoire document to be printed, realistically, in today's world,
it will be translated to LaTeX, hence to PDF, sent off to a print
on demand company, and drop shipped. Some documents may in fact
make this journey, because why not? We aren't oriented around it.

The basic flow in a Grimoire context is one of excursion and return.
We have tangling and weaving, but also unraveling, where actions taken
within the weave or tangle are integrated back into the source document.

*** Unraveling the Mystery

What's unraveling? When I picture Donald Knuth writing literate code,
I picture him with a notebook, writing free-flowing algorithms in a
fashion he refined his entire career. I imagine him carefully transcribing
into Web, running the compiler, going for a stroll around the Stanford
campus, and examining the changes upon his return.

On the days, and they did happen, when his program was in a state of error,
I picture him returning to his notebook first. While thinking. Perhaps
playing the organ for an hour or two, to relax. He would then correct the
notebook, then the code, then the program, which would be correct now,
most of the time.

I'm making that all up. But I'd wager I'm not far off the mark. We
don't work like that and most of us can't.

A tangle is named that because the mapping between it and the source
can be non-trivial. It's quite possible to make it undecidable what to
do with edits to the tangle. it's also possible to move edits from the tangle
back into the source, in most cases, if we structure things well.

Donald Knuth was unable to print a book that would alter his code. I'm
sure he'd have been delighted to have the ability. Our weaves can easily
be living documents, through in-browser and server side empowerment.
Those changes, too, should make it back into the source.

Ultimately I imagine many people will prefer to edit and run their
Grimoire documents entirely from a weave that provides a bit of the
ol' WYSIWYG to the experience. Well and good for them, I have my own
view of Heaven, and it isn't Heaven if we don't all fit.

*"]
section_759 -> leaf_989
leaf_989  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Code Blocks

The =`inline`= syntax works like the rest, you may use any number of backticks to enclose a form.

Something like:

#+begin_example
```
-- some code

```
#+end_example

is just another inline block, it's evaluated and expanded in-place into the weave, if it's named,
it is evaluated when referenced. This:

#+begin_example

@named-block ```
-- some code
```
#+end_example

is a named, *prose* block, which contains inline code.

Separated code blocks use special tags:

#+begin_example

#!lua
-- some lua code
#/lua

#+end_example

The =!= and =/= characters may be multiplied if multiple levels of
nesting apply. As indeed they might in a Grimoire code block.

We need a good runtime. Playing the Inception game
with Grimoire should be an amusing headache, not a dog-slow
system killer.

They may be named like anything else:

#+begin_example
#!lua @a-named-block
-- some lua code
#/lua
#+end_example

They may be marked for evaluation:

#+begin_example
#!lua 
-- some lua code
#/lua()

#-> nil

#!lua @nine
return 4 + 5
#/lua()

#@nine-> 9


-- equivalent:

@nine
#!lua
return 4 + 5
#/lua()

#@nine-> 9

#+end_example

Note the =#/lua()= form, which calls the code block, and the =#->= tag, which
marks an anonymous result. =#@nine->= is the automatically generated tag for
the return value of the block named =@nine=, adding =@nine()= to a prose block will
add the number 9 to the weave at that location. *bridge* will either display the result,
the call, or both, configurably, when editing the source, with syntax-highlighting to 
enforce the distinction. 

Code blocks may be indented as any other blocks, with the associated owership
rules. Code blocks so indented have a logical start equal to their level of
indentation, which is to say the program being called will not see indentation
that is proper to the Grimoire document.

Code blocks may be placed inside lists, as tables may be, but may not be
explicitly placed inside tables.

You may insert the result of a named code block in the data context
by simply saying =@a-named-block()=. If there are variables, you may pass
them, =@a-named-block(23, true)= or if you wish, by name:

#+begin_example
@a-named-block(foo=23, bar=true)
#+end_example

The values will be inserted as per an inline reference.

Within a formula applied to a table, it is valid to use the description
syntax for a variable to supply an argument to a function.

There will be further syntax involved in building up the line that
begins a code block. It's considered good form to assign complex
code block headers into distinct tags, and use those, rather than
being explicit and repeating yourself or hiding file-local defaults
in drawers.

So we prefer something like

#+begin_example
#!lua/session-logged-no-tangle
-- some lua code
#/lua
#+end_example

over anything more or less explicit.

*"]
section_610 -> leaf_990
leaf_990  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Code

The place where it all comes together.

Grimoire has a servant language, Lua by default, but this
is of course configurable. Eventually we'll write Clu,
it's a race to see which project is finished first but they
have common dependencies, surprise, surprise.

Code and data are yin and yang in Grimoire. Code embedded in
documents is executed in various ways and times; comments within
code blocks are themselves in Grimoire data format, and so on.

Given a single language Grimoire text, we can perform a mechanical
figure-ground reversal, such that data blocks become comments and
code blocks become live. We have many more sophisticated weave and
tangle operations, but this is a designed-in property that will prove
handy: sometimes you want to take code, org it up, and then flip it
into a literate context. Upgrade path for existing codebases.


**** Inline Code

Inline code is written =`4 + 5`=. It executes in something similar to
:function mode in Babel, the call is as though it were wrapped in a function
call that looks like:

#+begin_src lua
return tostring((function() return
   4 + 5
end)())
#+end_src

With the difference that the inline servant language is run in a session mode by default,
maintaining state between calls.

Anything named exists as a data structure in the helper language. This makes it easy to
refer to a block that contains a self-reference, so these are stored in a cycle-safe way.

*"]
section_595 -> leaf_991
leaf_991  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   ** Second Header ►
#+end_src

or the dot which represents a drawer =⦿=, the Unicode character
is actually present in the document.

This tidily preserves the state indicated by the sigil through
any transformation we may take. If you load up last Wednesday's
version of something, it will be in last Wednesday's fold state.

This lets us have richer folding semantics, like \"don't unfold when
cycling\". It lets us have richer drawer semantics, and so on.

We will reserve a number of characters for this purpose, at least

| ▼ |  ► | ⦿ |
    |

It's legal to delete runes, like anything else. It's also legal to
insert them manually. Neither of these paradigms is typical;
deleting into a rune may or may not cause it to disappear in
normal edit mode.

Runes, like absolutely everything in Grimoire, are prose if encountered
in a context where they aren't valid structure.

We will most likely reuse runes inside cookies, though it's just as valid
and quite typical to use normal letters or words.

*** Lists

Something that irks me about Org is basically historic. It was a TODO
list first, and became a heiarchical document editor later. As a result,
the functions that let you tag, track, and so on, are in the wrong place;
an Org file has to choose whether or not it's a task list or a document,
which doesn't fit the metalanguage paradigm cleanly.

A list looks like this:

#+BEGIN_EXAMPLE
- a list
  - can have some data
  - key :: value
  - [ ] boolean
  - multiple choice #relevant-elsewhere
    - ( ) A
    - (*) B
    - ( ) C
  - Can contain ordered Lists
    1. Such as this
    2. And this
#+END_EXAMPLE

Similar enough to Org, though `+` and `*` aren't equivalent options,
and we have radio buttons.

We also have whitespace lists:

#+BEGIN_EXAMPLE
~ a whitespace list
   has data
   organized by indentation:
     the colon is prose
     [ ] [todo] checkboxes :fred:
   also radio buttons
     (*) as you might expect
   multiple lines may be spanned \\
   by C-style backslash newlines,\\
     level is the same as long as \\
  you keep escaping, though this is\\
  confusing.
   this is the next item
   you can number them:
     1. apple
     2. persimmon
     3. mangosteen

and we're done.
#+END_EXAMPLE

*** Embedded Data

Anything found in prose between ={= and =}= is EDN. Note that the
outermost pair of curlies denotes a boundary. ={ foo }= is the symbol
foo, ={ foo bar }= is the symbol *foo* and the symbol *bar*, ={{foo bar}}= is
a map with key *foo* and value *bar*.

To quote the [[https://github.com/edn-format/edn][spec]], \"There is no enclosing element at the top level\". The
braces mark the boundaries of the data region.

There is a mapping between lists and EDN, the basics of which will be clear
to the astute reader. The non-basics are unclear to the author as well.

Unresolved: may data be inlined into prose? What would that even mean?
slap some colors on it in the document? If we want to provide a 'this is
code but not for interpretation' mark, we will, it won't be EDN specific.
Inlining colorized code is not high on my todo list.

I don't think you can. Embeds are down here with lists and
tables in 'things you can't inline', for now.

*** Tables

The way tables work in Babel is fine and needs little polish. Any modest
improvements we make will be in the face of considerable experience.

For example, I expect there's a way to make multiple literal rows serve
as a single row in existing Org, but I don't know what it is. I'll be
playing around a lot in the coming weeks, I hope.

Composability being an overarching goal, we can embed anything in a table
that we would put elsewhere.

Looks something like this:

#+begin_src org
  | a table           | very simple         |
  |-------------------+---------------------|
  | some rows         | with *bold* stuff   |
  | \"\"literal stuff\"\" | etc.                |
  | 23                | This gets filled in |
  #formulas {{ @2$2, @a-formula }}
#+end_src


Another option would be a formula list:

#+begin_src org
  | a table           | very simple         |
  |-------------------+---------------------|
  | some rows         | with *bold* stuff   |
  | \"\"literal stuff\"\" | $23 :expenses:      |
  | 23                | This gets filled in |
#formulas -
   - [X] @3$2 :: @on-formula
   - [ ] @1$1 :: @off-formula
#+end_src

This is a point for Grimoire I dare say.

A subtle point of parsing I'm not sure is correct is =#formulas -=
or =- #formulas=. I feel like by normal associativity the latter
attaches the tag to the list, then nothing to the tag,
since the rule is a tag preceded only by whitespace owns the line
after it and indentations below it. The tag doesn't affect the indentation level
of the =-=, which could be confusing but won't be.

We should be able to tag tables like this:

#+begin_src org
@named-table | some data | more data |
             |-----------+-----------|
             |           |           |

    #formulas: etc...

#+end_src

Note the intermediate indentation of the =#formulas:= category tag.
Totally okay in this context, doesn't trigger Nim rules because the table
associates to the tag anyway.

This gives us a nice left gutter which I propose we can use in various ways.

This section can get much longer. Generalizing how tables work is incredibly
powerful. My dream is to embed APL into Grimoire. Give me an excuse to
finally learn it!

*** Clocks

I think timestamps are just a drawer you put a timestamp in.

That drawer can collapse and look like ⏱.

Or we can collapse it into something from the set containing 🕞.

Which normal Emacs doesn't display. I really need to go Japanese soon.

But it would be just adorable to have a little clock representing the timestamp.
Emoji are quirky but the set contains useful icons, and it's Unicode.
Grimoire supports Unicode.

*"]
section_584 -> leaf_992
leaf_992  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Top Header ▼
 "]
section_331 -> leaf_993
leaf_993  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Runes

After drawers is as good a place to put runes as any.

Runes are characters drawn from the pictographic zones of Unicode,
which describe semantic activity within a document.

Contra Org, when we have something like the aformentioned:

#+begin_src
 "]
section_315 -> leaf_994
leaf_994  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   ** Second Header ►
#+end_example

This indicates that the top header is partially unfolded
and that the second header is completely folded. Deleting
into the mark unfolds.

Within sections, ordinary prose rules apply. A section
may contain any number of blocks.

\"begins\" means first non-whitespace character. Indentation levels are tracked by
Nim rules, obviously a Grimoire document can contain no tab marks
and if any wander in they become four spaces.

Contra other block forms, tags may not precede a headline.

**** Header Lines

Anything after a run of =*= and a space, and before a newline, is
a header line.

Header lines and list lines are structured identically. If I discover
a necessary exception, I'll note it.

That structure is discussed under [[*Lists][lists]].

**** Zero-header tag

The special [[*Tags][tag]] =#*=, which is only meaningful at the top of a document,
 indicates a 'zero header'. This lets you use the one-star level as a
series within a single document.

The related tag =#meta*= must be followed by a space and any number of
stars. This indicates a meta-level for the entire under-tree, that
exists somewhere else. Further semantics may be provided.

This section belongs in some further API section.

***** TODO Move to API Section

*** Prose blocks

A prose block is preceded and followed by a single newline. Extraneous
whitespace on the bare line is filtered.

Prose blocks may not be indented in a semantically meaningful way.

#+begin_example

prose

    prose

        prose

#+end_example

is not nested, nor will formatter correct it.

*** Prose markup

Prose markup rules apply in any prose contexts, not just for prose blocks.

We mark =*bold*=, =/italic/=, =_underline_=, =~strikethrough~=, 
and =​=literal=​=, using the indicated marks. They must not be separated 
with whitespace from the connecting prose. Any number may be used and matched,
whitespace is allowed, so =**bold math: 4 * 5**= will highlight
correctly.

There is also [[*Inline%20Code][Inline Code]], which is formatted =`code`=.

These all follow the prose markup rule: any number of the starting
character matches the same number of the ending character in the
document string.

We make subscripts mildly annoying, =sub__script= and =super^^script=, 
to avoid colliding the former with =snake_case=. That's a lot of ways 
to parse the =_= character...

In general, prose is more 'active'  than in Babel. There are more things
you can't say without triggering a parsed data structure.  Due to quirks
of Org  involving string  escaping, =`\\\"\\\"`=  can't be  literally quoted
without repercussions. Check  out the source if you enjoy pounding your
head in frustration at the nastiness of escaped strings.

Let's just use a code block:

#+BEGIN_EXAMPLE
\"\"literal string *containing* @some #things:of-various-sorts { that would be parsed }\"\"
#+END_EXAMPLE

So literal strings start with a minimum of two, rather than a minimum of
one, of the \" character. This is pretty-printed in edit mode as =‟literal”=,
but such a string does *not* create escaping, we rely on semantic highlighting
to make the distinction clear.

Any number of \"\"\"\" collapse into one set of such balanced quites.

In the woven documentation, no quotation marks appear, just the string.

**** Latex

For further markup purposes in a prose context, we escape to LaTeX. The
syntax is =`\\latex`=, where the backslash causes us to use LaTeX instead
of Lua. Our TeX backend is LuaTeX, giving arbitrary levels of control from
within a Grimoire-native language.

*** Comments

In a structure context, you may place line comments. These begin with =--=
and continue to the end of a line.

Commenting out a header line, or anything else, causes it to be ignored.
It does *not* result in any subdata being commented out, though it will
in the case of a headline change the ownership of the owned blocks.

The  tag =#comment=  in a  valid tag  content position  marks the  owned
region  of  the tagged  block  as  a  comment.  Nothing within  will  be
evaluated or exported, though it will be parsed.

*** Marks

Marks provide global semantic categories for Grimoire. They may appear
anywhere, including a prose context, whitespace is required on both sides.

We use  a couple kinds  of marks:  =@names= name things,  and =#tags=
categorize them. Tags are semantics, while names are nominal. 

Tags that  are boundaries are  paired as  =#tag= and =#/tag=,  plus some
light sugaring. Names are never bounded

Marks in the first position own the following line. If there is indentation
below that line, they own that too. This doesn't affect the associativity.

Marks may be namespaced, as =@name.subname= or =#tag.sub-tag.sub-tag=.

If  you  require   further  namespacing,  =@many/levels/java.class=  and
=#mojo/nation.space/station=  is your  friend. Codices (that is, projects
following the bridge conventions for organization) will use namespacing
in a consistent way. 

As I continue to muse on it, I  can think of no reason why marks couldn't follow
URI syntax,  or at  least mirror  it closely.  Chaining marks  is not  valid, so
=@named@example.com= could be a valid name. 

This would mean we could say something like =@file://~/usr/blah=.

Or =#!/usr/bin/perl/=...

Yes. This  is a good idea.  Let's do this.  It doesn't displace [[*Links][link]]  syntax, it
enhances it. A  URI [[http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax][may not begin with  a slash]] so this is  parse-clean for tags
and names both. Tags aren't intended to  be user extensible in the narrow sense,
but uniformity is a virtue.

I don't know why you might want to stick a query in a tag. It's not my
place to know. We just slap a parser on that puppy and continue.

Implication: The hash or at should be syntax highlighted a different color
from the tag. I'd say hash and at get the same color, with categories and
symbols getting different ones.

Apparently, [[http://blog.nig.gl/post/48802013022/although-parentheses-are-technically-allowed-in][parentheses are allowed in URLs]], but follow the link, they
suck and you should never use them. They play badly with our calling
convention for named structures, and aren't allowed in our schema.

It's not a real URI anyway, or it can be but it's also allowed to be a legal
fragment without the handle. In our case the assumed handle is =grimoire://=?

Not a real URI. But an acceptable fake one.

The actual rule for a mark is that it begins with =@= or =#= and is surrounded
by whitespace. Internal parsing of the mark is part of recognition, anything 
not recognized is subsequently ignored. It's still considered a mark for e.g. 
weaving purposes. 



**** Plural Hashtags

In some cases, such as =#formula= and =#formulas=, a tag may have a
singular or plural form. These are equivalent from the runtimes perspective.

The same concept applies to pairs such as =#export= and =#exports=, though
the linguistic distinction is not that of plurality.

*** Classes

Tags are for Grimoire. A category provides runtime semantics,
cooperating with structure groups to provide the API. Names
play the role of a value in languages which provide a
value-variable distinction: every name within a documents reachable
namespace must be globally unique.

Specifically names are globally hyperstatic: any redefinition affects
the referent from the moment the parser receives it forward. Redefinitions
are warned against and have no utility, don't do it.

Classes are roughly equivalent to categories/hashtags, but
for the user. They have a light semantics similar to their
function in Org.

A class is defined as =:Class:= or =:class:= including
=:several:Classes:chained:=.

A capital letter means the class inherits onto all subgroups of the block,
a miniscule means the class is associated with the indentation level it is
found within.

You know you're programming a computer when class and category have distinct
semantics. At least there are no objects, and only two primitive types,
structure and prose.

*** Links

There's nothing at all wrong with the syntax or behavior of Babel links.

Which look like this:

#+begin_example
[[http://example.com][Hello Example]]
#+end_example

With various wrinkles, all supported.

We won't support legacy forms of footnoting, such as =[1]=. This applies
to legacy versions of table formulas and list syntax also.

In Grimoire  there's one way  to do things.  At least, we  avoid variant
syntax with identical semantics.

*** Cookies

List line contexts (header lines and list lines) may have cookies. A
cookie looks like =[ ]=, it must have contents and a space on both sides.

Cookies are valid after the symbol that defines the list line, but before
anything else. They are also valid at the end of a list line, in which
case they are preceded by a space and followed by a newline.

Cookies are distinctive in that they may only be applied to list lines.
Most other token-like groups, specifically tags, classes, and inline drawers,
may be embedded into all prose contexts excepting literal strings.

Cookies are used similarly to cookies in Org, but with consistent semantics.
A simple cookie set is \"X\" and \" \", the user cycles through them. TODO and
DONE are another option.

I don't want cookies to turn into lightweight tables. Still, saying to
the user \"you may have precisely two cookies a line\" is restrictive.
It's not a violation of the [[http://c2.com/cgi/wiki?TwoIsAnImpossibleNumber][\"Two is an Impossible Number\"]] principle,
because they're head and tail. I think this is ugly:

#+begin_example
 - [ ] [ ] [ ] Oh god boxes [ ] [ ] [ ]
#+end_example

And whatever you're trying to model there should be a table.

You can stick a table in a list. I don't know if I mentioned, it's kind
of an obvious thing, I'll write a unit for it at some point.

Still. I can see a case for two on the left. Once you allow two, you allow
n, without excellent reason.

[[*Radio%20cookies][Radio cookies]] must be the leftmost cookie on a line, only one is of course allowed.
I could allow a single-line short form multi-radio-button interface but what
is it, a fancy text slider for some value? No. Any number of ordinary cookies
can follow. Knock yourself out.

Anything more than a couple and one should consider a class or a table.
Handrolling data structures is perverse in a markup language, and I'm
still tempted to forbid it.

I don't like distinctions without difference. A cookie at the end of a
line is filled by Grimoire, not the user. This mirrors Org's use, which is
to display either a percent or a n/m marker for completion of list items.
The user seeds the cookie, in these cases with =%= or =/=, and the runtime
does the rest.

Adding more than one such structure to the tail list would complicate the
reference syntax, which I haven't designed, and again, it's just not necessary.
Grimoire can fill in any data structure, \"n-dimensional end cookie array\"
isn't one we have a compelling need for.

Cookies could interact badly with link syntax. I don't think a [bare box]
qualifies as a link in Org, clearly it doesn't, we can follow that notion
and disallow \"[]\" as a filling for cookies.

I also think they should be allowed in table cells, which have their own
context which is mostly handwaved right now but is prose++.

**** Radio cookies

We have one 'weird cookie'. A radio cookie, which looks like =( )=,
must be present at the head position of list line contexts. All
list lines at the same level of indentation must have one, if one does.

Only one is selected at any given time. These would be awkward to add
into tables, to little gain.

This comes perilously close to pushing us into the realm of error.
The formatter adds buttons to an entire subtree if one member has it,
and if more than one is ticked off, it warns if possible or removes
all but the first mark encountered. If none are present the first
option is selected.

The runtime will not normally build an invalid radio list, but
Grimoire must import plain text.

*** Drawers

A drawer is a block that's hidden by default. The computer sees it,
the user sees ⦿, or a similar rune.

#+BEGIN_EXAMPLE
:[a-drawer]:
contents
:/[a-drawer]:
#+END_EXAMPLE

This closes to a single Unicode character, such as ⦿, which can't be deleted
without opening it. Deleting into an ordinary fold marker opens the fold,
deleting towards a drawer marker skips past it.

=a-drawer=  is  a type,  not  a  name, something  like  =weave=  or =tangle=  in
practice. This may or  may not be supported with a =#weave=  tag. 

I'm not entirely sure how to interact names with drawers, perhaps like this:

#+begin_example
:[a-drawer]:
@drawer-name
- some contents
  - in list form
  - etc.
[:/a-drawer]:
#+end_example


Under the  hood, a  drawer is just  a chunked  block owned by  a tag.  An editor
should keep it closed unless it's  open, those are the only additional semantics
associated.

This lets master wizards embed unobtrusive magic into documents for apprentice
wizards to spell with.

An inline drawer looks like =:[[some contents]]:=.  As usual when we say \"inline\" it
can be as long as you want. Being anonymous, because untagged, the only semantics
of such a drawer are to hide the contents in source mode. 

*"]
section_302 -> leaf_995
leaf_995  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Top Header ▼
 "]
section_297 -> leaf_996
leaf_996  [color=Gray,shape=rectangle,fontname=Inconsolata,label="    ** Second Header
  #+end_example

The rest of the header lines are reformatted with the same
degree of indentation. Note that you still must use the
requisite number of asterisks, this is a syntax sugar giving
a more natural look to collapsed header structures. Prose blocks
needn't be indented to match.

Collapsed headers look like this:

#+begin_example
 "]
section_282 -> leaf_997
leaf_997  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  * Top Header
 "]
section_283 -> { header_998 block_999 block_1000 block_1001 section_1002}
{rank=same; header_998 block_999 block_1000 block_1001 section_1002}

header_998 [label="4 : Zero-header tag"]

block_999 [label="block 408-413"]

block_1000 [label="block 414-417"]

block_1001 [label="block 418-419"]

section_1002 [label="section: 420-421"]


block_999 -> leaf_1003
leaf_1003  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The special [[*Tags][tag]] =#*=, which is only meaningful at the top of a document,
 indicates a 'zero header'. This lets you use the one-star level as a
series within a single document.
"]
block_1000 -> leaf_1004
leaf_1004  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The related tag =#meta*= must be followed by a space and any number of
stars. This indicates a meta-level for the entire under-tree, that
exists somewhere else. Further semantics may be provided.
"]
block_1001 -> leaf_1005
leaf_1005  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This section belongs in some further API section.
"]
section_1002 -> { header_1006 block_1007}
{rank=same; header_1006 block_1007}

header_1006 [label="5 : TODO Move to API Section"]

block_1007 [label="block 420-421"]


block_1007 -> leaf_1008
leaf_1008  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_1002 -> leaf_1009
leaf_1009  [color=Gray,shape=rectangle,fontname=Inconsolata,label="***** TODO Move to API Section

*"]
section_283 -> leaf_1010
leaf_1010  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Zero-header tag

The special [[*Tags][tag]] =#*=, which is only meaningful at the top of a document,
 indicates a 'zero header'. This lets you use the one-star level as a
series within a single document.

The related tag =#meta*= must be followed by a space and any number of
stars. This indicates a meta-level for the entire under-tree, that
exists somewhere else. Further semantics may be provided.

This section belongs in some further API section.

*"]
section_272 -> leaf_1011
leaf_1011  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Headers

Grimoire is arcically constrained by structure groups,
called headers.

These start on a new line and begin with any number of  =*=. These must
be followed by a space mark to be valid. Contra Babel, you may
have a content-free header line, provided a space is found before the
newline.

In weaves and the like, headers represent document structure. Their
intention is structural: they support the same syntax as lists,
but the user is expected to use lists for list purposes. Putting
[TODO] in a header line should mean you have a document-specific
task to perform in that block.

Contra Babel, you may put spaces before the beginning of a header line.

The semantics of header lines are entirely determined by
the number of stars.

If you write

  #+begin_example
  * Top Header
    ** Second Header
  #+end_example

The rest of the header lines are reformatted with the same
degree of indentation. Note that you still must use the
requisite number of asterisks, this is a syntax sugar giving
a more natural look to collapsed header structures. Prose blocks
needn't be indented to match.

Collapsed headers look like this:

#+begin_example
 * Top Header ▼
   ** Second Header ►
#+end_example

This indicates that the top header is partially unfolded
and that the second header is completely folded. Deleting
into the mark unfolds.

Within sections, ordinary prose rules apply. A section
may contain any number of blocks.

\"begins\" means first non-whitespace character. Indentation levels are tracked by
Nim rules, obviously a Grimoire document can contain no tab marks
and if any wander in they become four spaces.

Contra other block forms, tags may not precede a headline.

**** Header Lines

Anything after a run of =*= and a space, and before a newline, is
a header line.

Header lines and list lines are structured identically. If I discover
a necessary exception, I'll note it.

That structure is discussed under [[*Lists][lists]].

*"]
section_42 -> leaf_1012
leaf_1012  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Syntax

Now that we've established the basic constraints, let's
start our recursive descent into the parse.

*"]
section_2 -> leaf_1013
leaf_1013  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Musings on Metasyntax
** Constraints

There is a difference between a metalanguage and a literate programming language. Babel is a metalanguage,
as Grimoire is intended to be.

An effective metalanguage balances three concerns. It must be usable, readable, and parsable.

*** Usable

A metalanguage is used interactively, on a deeper level than REPLs.

This is what makes working with Org so amazing. The first purpose of what became Babel
was simply editing outlines. This was outline mode, which dates back to the era when
using asterisks and =- [ ]= checkboxes in a plain ASCII text file was fairly futuristic
behavior.

You can't really call that a language either, though it's a syntax. More and more features
were attached until we have modern Babel. But because each feature was build as an extension
to the editing/runtime environment, Babel is fairly smooth to work with.

If you can handle Emacs. I can, some can't. A metalanguage is tightly coupled to its runtime,
because its runtime is its editing environment. Not much of a metalanguage if this isn't the
case.

Grimoire is the culmination of a considerable dependency chain. We need a data structure, a
parser to work with the data structure, and an editing environment that builds on these. For
maximum enjoyment, we'll want a custom terminal that enhances the xterm protocol with a few
features, most notably graphics.

Just like I have trouble writing Lua without burning huge amounts of time planning out Clu, I
can't use Org without doing the same for Grimoire. It's all related: I need a really good parser.

[[https://github.com/UpstandingHackers/hammer][hammer]] is the leading contender. But back to Grimoire.

*** Readable

Grimoire is designed to be read.  It's important that the raw syntax not
 break the reader's flow.  A good metalanguage lets the user employ just
 as much magic as she's comfortable with, without imposing more.

Our syntax is  designed to support this. As such  it is deeply concerned
with matters  such as indentation  and whitespacing, which are  basic to
readability.

It will be quite possible and indeed comfortable to write pure documents
such  as blog  posts in  Grimoire form.  In that  use case  it resembles
Markdown.

*** Parsable

Grimoire  documents are  intended  to be  highly  convoluted. The  basic
editing operation  is the fold. The  Grimoire editor must be  capable of
handling documents in the tens of megabytes with a complex and preserved
folding structure.

This requires  a ground-up  editing environment  rewrite to  employ data
structures   with   correct   big-O    complexity   and   an   efficient
implementation.

This  also  requires  that  the   language  be  well-designed  for  easy
recognition of the structural elements. As this document evolves, I will
be defining a grammar in the syntax preferred by barbarian.

Grimoire is  an error-free  language. There  are several  concepts which
interact to  create this, namely  structure, prose, well-  and malformed
structure, and validity.

A parser for Grimoire which doesn't  succeed without error for any utf-8
string is not valid.

** Structure

This is a top-down look at Grimoire's proposed syntax.

*** Encoding

Grimoire is defined in terms of utf-8.

The core syntax is defined in terms of the reachable keys on a US keyboard.
This tradition is firmly entrenched in the mid teens, and I have no
designs on budging that at present. The miser in me likes that they're
a byte each. The lawyer in me insists that this isn't ASCII, which is a
seven-bit legacy encoding. All aspects of utf-8 are equally meaningful.

We aren't at all afraid to use Unicode characters to display aspects
of the runtime. In fact we favor this, as it marks those operations
as distinctive. Most people can't type ⦿ without effort (I can't)
and it's easy to recognize as a folded drawer once you've seen a couple.

Grimoire is case sensitive and uses lower-snake-case for built-in English
phrases. There is a convention (see classes) that uses capitalization of
user words to affect semantics. This may be overridden with other rules
for languages that lack the majuscule-miniscule distinction.

I want Grimoire to have correct Unicode handling, for some value of
correct. It can't be considered 1.0 without this.

Bidirectional handling in a context that's indentation sensitive is
an example of something subtle. Grimoire uses indentation in various
ways, so here's the rule:

Any newline that has a reversed direction ends indentation. So if
you are going ltr, issue an rtl marker, and a newline, your indentation
level is zero. If you reverse direction twice in a line, you keep
your indentation level. Three times, you lose it.

I'd love to get a Hebrew and/or Arabic fluent hacker on the project
early, to make sure this works correctly.

Another thing I want to get right is equivalence. If you have a
variable called \"Glück\" the compiler shouldn't complain if it's
rendered in either of the valid ways. For some sequences that's
\"any of the valid ways\". If we normalized your prose, you might
have problems later, so we don't want to solve it that way.

**** Internationalization

All parts of Grimoire defined in English will be namespaced
as =en:/=, and loaded by default. Other languages will be added
when there is a fluent maintainer available.

Note  that  many  words  aren't  truly English.  Notably  the  names  of
programming languages are  the same in all human languages.   A tag like
=#author= can be namespaced =#fr:/auteur= and will be, but =#!python= is not
in the =en:/= namespace.

*** Prose and Structure

The major distinction Grimoire draws is between prose and structure.

Prose is the default parsing state. It is far from unstructured from the
runtime  perspective. Although  this needn't  be embedded  in the  parse
tree,  Grimoire   understands  concepts   such  as   paragraphs,  words,
punctuation,  capital letters,  languages, and  anything else  proper to
prose.

I refer to human languages, but Grimoire understands programming languages
also. In principle, all of them, it shouldn't be harder to add them than
it is to call them from shell, though getting a runtime rigged up to
another runtime always calls for some finesse to derive a good experience.

\"Programming languages\" is overly specific. Grimoire draws a distinction
between prose and structure. Blocks may contain either, or both.

Something that's nice about a language build on a prose/structure
relationship is that it can be error free. Anything *grym* can't build into
a structure is just prose.

Markdown has this property. Sometimes you run into crappy parsers which
build errors into Markdown, which is just obnoxious. If you [[http://daringfireball.net/projects/markdown/syntax][RTFM]],
you'll find the word \"error\" once. Helpfully explaining how Markdown
keeps you from making one.

We do what we can to make the document look the same as it is
in fact structured. Syntax highlighting handles the edge cases.

*** Ownership

The basic structural relationship in Grimoire is ownership.

Root elements of a heirarchy own their children, blocks own
lines that refer to that block. Indentation has a subtle but
regular interaction with ownership; it does what you expect.

Edge cases are resolved using the cling rule.

**** The Cling Rule

The cling rule specifies that a group 'clings' to another group when
it is closer to that group than the other group. Ties resolve down.

This should make it intuitive to group elements that aren't grouping the
way you expect: put in whitespace until the block is visually distinguished
from the surroundings.

Cling applies between blocks which are at the same level of ownership.
Ownership has precedence over cling: all blocks underneath e.g. a header
line are owned by that line, newlines notwithstanding.

Note that indentation of e.g. lists invokes the cling rule within the
indentation level.


#+begin_example
| x | y | z |

#tag


someprose on a block
#+end_example

Tags the table, but

#+begin_example
| x | y | z |


#tag

someprose on a block
#+end_example

Tags the block.

Even clings are resolved forwards:

#+begin_example
| x | y | z |

#tag

someprose on a block
#+end_example

Tags  the prose  block. The first and last examples should
be considered bad style.

*** Whitespace, Lines, and Indentation.

Grimoire is a structured document format. There are semantics associated
with every character we encode.

**** Whitespace

Whitespace is either the space or newline character. Returns are removed,
tabs resolved to two spaces by the formatter, the latter is warned against.

Most of the token-like categories we refer to must be surrounded by
whitespace. Newlines have semantics more often than they do not.

Unicode actually contains quite a number of whitespace characters. They are
all treated as a single ordinary space. If that space is semantically meaningful,
as in the space between =*** A Headline=, it is filtered into an ordinary space.
Otherwise it's considered prose, the only filtration prose receives is tab->space
conversion.

Grimoire mercilessly enforces tab-space conversion, even on your code blocks.
I will cling to this tenet as long as I can, the tab character needs to die,
the world has decided, that key is special and shouldn't insert a special
dropping that looks like n spaces.

*make*? Outta my face with make. Yes, we'll have a make syntax, yes, it will
put the tabs back in.

**** Lines

When we refer to the beginning of a line, this allows for spaces before the
reference point. We call the absolute beginning of a line the first
position.

**** Indentation

Grimoire is an indentation-aware language. Most kinds of block can be
arcically[fn:1] ordered by means of indentation.

Indentation follows [[http://nim-lang.org/manual.html#indentation][Nim rules]].

[fn:1] There's nothing sacred about ordered subrules, and if we're making up
a new word, let's drop the silent h. Webster was a cool guy.
*** Order of Recognition

Starting from the neutral context, which is always at a newline, Grimoire
tries to make one of its initializing special forms. Failing that, it will
begin a prose block.

If there is whitespace, it affects indentation level in indicated ways.
They will not directly affect the semantics of the following form, that is,
these rules apply after any potentially block-ending newline, apart from
spaces that may be found between the newline and the character.

At present,  =*=, =#=,  =|=, =-=,  , =~=,  =@=, =:=  and ={=  all create
special  contexts.  A  special  context  creates a  block  in a  context
specific way.

Blocks have a left associativity which can be recursive.

*** Blocks

Grimoire is oriented around blocks.

Blocks are at least one line long,  all restarts are on a new line.  Any
syntactic structure smaller than a block we call an element.

Some types of blocks nest.  A document is a single  block.  There may be
other semantic units such as directories, I'd think a language that uses
strict  nested heirarchy  as powerfully  as Grimoire  could dictate  the
semantics of a file system, but that's currently out of scope.

Indentation is relevant to some  kinds of blocks. In general, whitespace
matters quite a  bit in a Grimoire  document. We keep some  of the warts
out because the tab character is  illegal, and there will be a mandatory
formatter, =grym  fmt= if  you will, that  does everything  from turning
=**bold**=  into =*bold*=  (because the  extra stars  weren't used),  to
newline stripping, and so on.  This is normally applied incrementally by
the runtime editing environment.

Indentation is human  readable and, with some care, a  computer may come
to the  same conclusions a  human would. I'm  still wary of  Python, but
there's no good  reason, unless the headache of most  Python not working
correctly  on my  computer, for  reasons I  can't track  down that  seem
related to  there being two languages  invoked as 'python', counts  as a
good reason.

*"]

}
