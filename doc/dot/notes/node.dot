digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 60"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-39"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6}
{rank=same; header_2 prose_3 section_4 section_5 section_6}

header_2 [label="1 : Node class"]

prose_3 [label="prose"]

section_4 [label="section: 3-11"]

section_5 [label="section: 12-39"]

section_6 [label="section: 40-55"]


prose_3 -> { raw_7}
{rank=same; raw_7}

raw_7 [label="raw"]


raw_7 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_4 -> { header_9 prose_10 prose_11}
{rank=same; header_9 prose_10 prose_11}

header_9 [label="2 : THIS FILE IS DEPRECATED"]

prose_10 [label="prose"]

prose_11 [label="prose"]


prose_10 -> { raw_12}
{rank=same; raw_12}

raw_12 [label="raw"]


raw_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The behavior of abstract syntax trees in `pegylator` is provided by the Node
class.
"]
prose_11 -> { raw_14}
{rank=same; raw_14}

raw_14 [label="raw"]


raw_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is in turn poorly specified and full of exploratory code that is in need
of a few once-overs.

"]
section_5 -> { header_16 prose_17 prose_18 prose_19 prose_20 prose_21 prose_22}
{rank=same; header_16 prose_17 prose_18 prose_19 prose_20 prose_21 prose_22}

header_16 [label="2 : Members"]

prose_17 [label="prose"]

prose_18 [label="prose"]

prose_19 [label="prose"]

prose_20 [label="prose"]

prose_21 [label="prose"]

prose_22 [label="prose"]


prose_17 -> { raw_23}
{rank=same; raw_23}

raw_23 [label="raw"]


raw_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  To be a Node, all indexed elements of the Array must also be Nodes. 
"]
prose_18 -> { raw_25}
{rank=same; raw_25}

raw_25 [label="raw"]


raw_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There are invariant fields a Node is also expected to have, they are:
 
  - `first` :  Index into `str` which begins the span.
  - `last`  :  Index into `str` which ends the span.
  - `id`    :  A string naming the Node. 
               This is identical to the name of the pattern that recognizes
               or captures it.

"]
prose_19 -> { raw_27}
{rank=same; raw_27}

raw_27 [label="raw"]


raw_27 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There are other fields which are of less obvious value, which still exist:
"]
prose_20 -> { raw_29}
{rank=same; raw_29}

raw_29 [label="raw"]


raw_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - `str`  : a \"string\" covering the whole abstract syntax tree.
             This is normally found on root for which see:
  - `root` : a function which, called, returns the root node.
             I was impressed with this idea when I came up with it.
             Haven't been getting much use out of it.
"]
prose_21 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
An important optional field, if a Node has a semantic span (such as a symbol)
then it will have:
"]
prose_22 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - `val` :  The substring of value to the syntax tree.

"]
section_6 -> { header_35 prose_36 prose_37 section_38 section_39}
{rank=same; header_35 prose_36 prose_37 section_38 section_39}

header_35 [label="2 : Node metatable"]

prose_36 [label="prose"]

prose_37 [label="prose"]

section_38 [label="section: 49-55"]

section_39 [label="section: 56-60"]


prose_36 -> { raw_40}
{rank=same; raw_40}

raw_40 [label="raw"]


raw_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  This is currently constructed wildly and piecemeal.  It also does important
work. 
"]
prose_37 -> { raw_42}
{rank=same; raw_42}

raw_42 [label="raw"]


raw_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Best methods are:

"]
section_38 -> { header_44 prose_45 prose_46}
{rank=same; header_44 prose_45 prose_46}

header_44 [label="3 : dot"]

prose_45 [label="prose"]

prose_46 [label="prose"]


prose_45 -> { raw_47}
{rank=same; raw_47}

raw_47 [label="raw"]


raw_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Some of my most recent code, this prints the AST as a dot file. 
"]
prose_46 -> { raw_49}
{rank=same; raw_49}

raw_49 [label="raw"]


raw_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It is now reasonably documented in [[src/peg/transform.lua]].

"]
section_39 -> { header_51 prose_52}
{rank=same; header_51 prose_52}

header_51 [label="3 : select"]

prose_52 [label="prose"]


prose_52 -> { raw_53}
{rank=same; raw_53}

raw_53 [label="raw"]


raw_53 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Select pulls out sub Nodes which fulfill certain predicates.

"]

}
