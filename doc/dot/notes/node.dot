digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 60"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-39"]


section_1 -> { header_2 block_3 section_4 section_5 section_6}
{rank=same; header_2 block_3 section_4 section_5 section_6}

header_2 [label="1 : Node class"]

block_3 [label="block 1-39"]

section_4 [label="section: 3-11"]

section_5 [label="section: 12-39"]

section_6 [label="section: 40-55"]


block_3 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_4 -> { header_8 block_9 block_10}
{rank=same; header_8 block_9 block_10}

header_8 [label="2 : THIS FILE IS DEPRECATED"]

block_9 [label="block 3-7"]

block_10 [label="block 8-11"]


block_9 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  The behavior of abstract syntax trees in `pegylator` is provided by the Node
class.
"]
block_10 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This is in turn poorly specified and full of exploratory code that is in need
of a few once-overs.

"]
section_4 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** THIS FILE IS DEPRECATED

  The behavior of abstract syntax trees in `pegylator` is provided by the Node
class.

This is in turn poorly specified and full of exploratory code that is in need
of a few once-overs.


*"]
section_5 -> { header_14 block_15 block_16 block_17 block_18 block_19 block_20}
{rank=same; header_14 block_15 block_16 block_17 block_18 block_19 block_20}

header_14 [label="2 : Members"]

block_15 [label="block 12-16"]

block_16 [label="block 17-25"]

block_17 [label="block 26-27"]

block_18 [label="block 28-33"]

block_19 [label="block 34-36"]

block_20 [label="block 37-39"]


block_15 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, all indexed elements of the Array must also be Nodes. 
"]
block_16 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="There are invariant fields a Node is also expected to have, they are:
 
  - `first` :  Index into `str` which begins the span.
  - `last`  :  Index into `str` which ends the span.
  - `id`    :  A string naming the Node. 
               This is identical to the name of the pattern that recognizes
               or captures it.

"]
block_17 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="There are other fields which are of less obvious value, which still exist:
"]
block_18 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  - `str`  : a \"string\" covering the whole abstract syntax tree.
             This is normally found on root for which see:
  - `root` : a function which, called, returns the root node.
             I was impressed with this idea when I came up with it.
             Haven't been getting much use out of it.
"]
block_19 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="An important optional field, if a Node has a semantic span (such as a symbol)
then it will have:
"]
block_20 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  - `val` :  The substring of value to the syntax tree.

"]
section_5 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Members


  To be a Node, all indexed elements of the Array must also be Nodes. 

There are invariant fields a Node is also expected to have, they are:
 
  - `first` :  Index into `str` which begins the span.
  - `last`  :  Index into `str` which ends the span.
  - `id`    :  A string naming the Node. 
               This is identical to the name of the pattern that recognizes
               or captures it.


There are other fields which are of less obvious value, which still exist:

  - `str`  : a \"string\" covering the whole abstract syntax tree.
             This is normally found on root for which see:
  - `root` : a function which, called, returns the root node.
             I was impressed with this idea when I came up with it.
             Haven't been getting much use out of it.

An important optional field, if a Node has a semantic span (such as a symbol)
then it will have:

  - `val` :  The substring of value to the syntax tree.


*"]
section_6 -> { header_28 block_29 block_30 section_31 section_32}
{rank=same; header_28 block_29 block_30 section_31 section_32}

header_28 [label="2 : Node metatable"]

block_29 [label="block 40-45"]

block_30 [label="block 46-55"]

section_31 [label="section: 49-55"]

section_32 [label="section: 56-60"]


block_29 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This is currently constructed wildly and piecemeal.  It also does important
work. 
"]
block_30 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Best methods are:

"]
section_31 -> { header_35 block_36 block_37}
{rank=same; header_35 block_36 block_37}

header_35 [label="3 : dot"]

block_36 [label="block 49-52"]

block_37 [label="block 53-55"]


block_36 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Some of my most recent code, this prints the AST as a dot file. 
"]
block_37 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="It is now reasonably documented in [[src/peg/transform.lua]].

"]
section_31 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** dot

  Some of my most recent code, this prints the AST as a dot file. 

It is now reasonably documented in [[src/peg/transform.lua]].


*"]
section_32 -> { header_41 block_42}
{rank=same; header_41 block_42}

header_41 [label="3 : select"]

block_42 [label="block 56-60"]


block_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Select pulls out sub Nodes which fulfill certain predicates.

"]
section_32 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** select

  Select pulls out sub Nodes which fulfill certain predicates.
"]
section_6 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable


  This is currently constructed wildly and piecemeal.  It also does important
work. 

Best methods are:


*** dot

  Some of my most recent code, this prints the AST as a dot file. 

It is now reasonably documented in [[src/peg/transform.lua]].


*"]
section_1 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node class

** THIS FILE IS DEPRECATED

  The behavior of abstract syntax trees in `pegylator` is provided by the Node
class.

This is in turn poorly specified and full of exploratory code that is in need
of a few once-overs.


** Members


  To be a Node, all indexed elements of the Array must also be Nodes. 

There are invariant fields a Node is also expected to have, they are:
 
  - `first` :  Index into `str` which begins the span.
  - `last`  :  Index into `str` which ends the span.
  - `id`    :  A string naming the Node. 
               This is identical to the name of the pattern that recognizes
               or captures it.


There are other fields which are of less obvious value, which still exist:

  - `str`  : a \"string\" covering the whole abstract syntax tree.
             This is normally found on root for which see:
  - `root` : a function which, called, returns the root node.
             I was impressed with this idea when I came up with it.
             Haven't been getting much use out of it.

An important optional field, if a Node has a semantic span (such as a symbol)
then it will have:

  - `val` :  The substring of value to the syntax tree.


*"]

}
