digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 118"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-118"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10}

header_2 [label="0 : "]

block_3 [label="block 1-3"]

block_4 [label="block 4-78"]

block_5 [label="block 79-80"]

block_6 [label="block 81-89"]

block_7 [label="block 90-93"]

block_8 [label="block 94-96"]

block_9 [label="block 97-99"]

block_10 [label="block 100-118"]



block_3 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" extended PEG module
"]
block_4 -> { codeblock_12}
{rank=same; codeblock_12}

codeblock_12 [label="code block 4-77"]



codeblock_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local lpeg = require \"lpeg\"
local Node = require \"peg/node\"

local function makerange(first, second)
   local patts = {}
   local patt  = {}
   if (second) then
      if (string.len(first) == string.len(second)) then
         for i = 1, string.len(first) do
            patts[i] = lpeg.R(string.sub(first,i,i)..string.sub(second,i,i))
         end
         patt = patts[1]
         for i = 2, string.len(first) do
            patt = patt + patts[i]
         end
         return patt
      else
         error(\"Ranges must be of equal byte width\")
         return {}
      end
   else 
      return lpeg.R(first)
   end
end


local function num_bytes(str)
--returns the number of bytes in the next character in str
   local c = str:byte(1)
   if c >= 0x00 and c <= 0x7F then
      return 1
   elseif c >= 0xC2 and c <= 0xDF then
      return 2
   elseif c >= 0xE0 and c <= 0xEF then
      return 3
   elseif c >= 0xF0 and c <= 0xF4 then
      return 4
   end
end

local function Su (str)
--[[
   --convert a 'set' pattern to uniquely match the characters 
   --in the range.
   local catch = {}
   local i = 0
   for i = 1, #str do
      catch[i]
   end
   --]]
end

local function spanner(first, last, str, root)
   local vals = {}
   vals.span = true
   vals.val = string.sub(str, first, last - 1)
   vals.first = first
   vals.last = last - 1
   if vals.last >= vals.first then
      return vals
   end
   -- If a capture contains nothing, we don't want a node for it
   return nil
end

local function Csp (patt)
   return lpeg.Cp() 
      * lpeg.Cmt(patt, function() return true end) 
      * lpeg.Cp() 
      * lpeg.Carg(1) 
      * lpeg.Carg(2) / spanner
end"]

block_4 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

block_5 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" from the lpeg tutorial
"]
block_6 -> { codeblock_16}
{rank=same; codeblock_16}

codeblock_16 [label="code block 81-88"]



codeblock_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function split (s, sep)
  sep = lpeg.P(sep)
  local elem = lpeg.C((1 - sep)^0)
  local p = lpeg.Ct(elem * (sep * elem)^0)   -- make a table capture
  return lpeg.match(p, s)
end"]

block_6 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

block_7 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Match a pattern anywhere in a string.
 
 Taken from the lpeg tutorial
"]

block_8 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - #param
   - p : lpeg pattern
"]

block_9 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - #returns
    - the first and last index of the first match, or nil
"]
block_10 -> { codeblock_22}
{rank=same; codeblock_22}

codeblock_22 [label="code block 100-118"]



codeblock_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local I = lpeg.Cp()

local function  anyP(p)
     return lpeg.P{ I * p * I + 1 * lpeg.V(1) }
end



local Ru = makerange


return { R = Ru,
      Csp = Csp,
      anyP = anyP,
      match = lpeg.match,
      split = split,
      spanner = spanner }"]

block_10 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

}
