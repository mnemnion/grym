digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="96  "]

doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="96  "]

section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10 block_11}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10 block_11}

header_2 [label=":   "]
block_3 [label="-1  "]
block_4 [label="14  "]
block_5 [label="63  "]
block_6 [label="66  "]
block_7 [label="18  "]
block_8 [label="27  "]
block_9 [label="77  "]
block_10 [label="82  "]
block_11 [label="96  "]


block_3 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]block_4 -> { codeblock_13}
{rank=same; codeblock_13}

codeblock_13 [label="10  "]


codeblock_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="--- Generates a terminal syntax highlighter for a given grammar. 

--local clu = require \"clu/prelude\"
local lpeg = require \"lpeg\"
local ast = require \"peg/ast\"
local util = require \"lib/util\"
local tableand = util.tableand
"]
block_4 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 peg rules. Don't belong here, but this is the
 only parser we have for awhile.

"]block_5 -> { codeblock_16}
{rank=same; codeblock_16}

codeblock_16 [label="61  "]


codeblock_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="--local p = clu.env.palette

 testrules = { atom           = {\"White\",\"Clear\"},
              pattern        = {\"Blue\",\"Clear\"},
              optional       = {\"Green\",\"Clear\"},
              more_than_one  = {\"Green\",\"Clear\"},
              some_number    = {\"Green\",\"Clear\"},
              some_suffix    = {\"Green\",\"Clear\"},
              which_suffix   = {\"Green\",\"Clear\"},
              maybe          = {\"Green\",\"Clear\"},
              set            = {\"Yellow\",\"Clear\"},
              range          = {\"Yellow\",\"Clear\"},
              literal        = {\"Yellow\",\"Clear\"},
              PEL            = {\"Grey\",\"Clear\"},
              PER            = {\"Grey\",\"Clear\"},
              hidden_rule    = {\"Cyan\",\"Clear\"},
              hidden_pattern = {\"Cyan\",\"Clear\"},
              hidden_match   = {\"Cyan\",\"Clear\"},
              repeats        = {\"Red\",\"Clear\"},
              comment        = {\"Grey\",\"Clear\"}}


function makerules(rules)
    local rule_table = {}
    local p = nil
       -- this logic belongs in a palette 
      -- object which may be called. 
    if clu.env.ansi then 
      p = clu.env.palette.default
   else
      p = clu.env.palette.no_color
   end 
   for k,v in pairs(rules) do
      if type(v) == \"table\" then 
         rule_table[k] = { p[v[1]] , p[v[2]] }
      else -- string or function
         error \"error in makerules, non-table values NYI\"
      end
   end
   return rule_table
end



--local testrules = { atom = {\"\",\"\"}, lhs = {\"\",\"\"}}
"]
block_5 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
block_6 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" wraps a value in a rule, or
 returns it if the rule is nil.

"]block_7 -> { codeblock_20}
{rank=same; codeblock_20}

codeblock_20 [label="17  "]


codeblock_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function rulewrap_value(ast,rules)
    if rules[ast.id] then
       local rule = rules[ast.id]
       if type (rule) == \"string\" then -- pre only
          return rule..ast.val..p.Clear
      elseif type (rule) == \"table\" then -- pre and post
         return rule[1]..ast.val..rule[2]
      elseif type (rule) == \"function\" then -- function over value
         print \"function reached in rulewrap_value\"
         return \"\"
      end
    else
       return ast.val
    end
end

local function rulewrap_open(ast,rules)
   if rules[ast.id] then
      local rule = rules[ast.id]
      if type(rule) == \"string\" then -- pre only
         return rule
      elseif type(rule) == \"table\" then -- use pre
         return rule[1]
      elseif type(rule) == \"function\" then -- fn over span
         print \"function reached in rulewrap_start\"
         return \"\"
      end
   else 
      return \"\" 
   end
end

local function rulewrap_close(ast,rules)
   if rules[ast.id] then
      local rule = rules[ast.id]
      if type(rule) == \"string\" then 
         return \"\"
      elseif type(rule) == \"table\" then
         return rule[2]
      elseif type(rule) == \"function\" then
         print \"function reached in rulewrap_close\"
         return \"\"
      end
   else
      return \"\"
   end
end

--- highlights a Node.
"]
block_7 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_8 -> { structure_23 structure_24 structure_25 structure_26}
{rank=same; structure_23 structure_24 structure_25 structure_26}

structure_23 [label="re  "]
structure_24 [label="re  "]
structure_25 [label="re  "]
structure_26 [label="re  "]

structure_23 -> { handleline_27}
{rank=same; handleline_27}

handleline_27 [label="ne  "]

handleline_27 -> { handle_28}
{rank=same; handle_28}

handle_28 [label="le  "]


handle_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]structure_24 -> { handleline_30}
{rank=same; handleline_30}

handleline_30 [label="ne  "]

handleline_30 -> { handle_31}
{rank=same; handle_31}

handle_31 [label="le  "]


handle_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]structure_25 -> { handleline_33}
{rank=same; handleline_33}

handleline_33 [label="ne  "]

handleline_33 -> { handle_34}
{rank=same; handle_34}

handle_34 [label="le  "]


handle_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]structure_26 -> { handleline_36}
{rank=same; handleline_36}

handleline_36 [label="ne  "]

handleline_36 -> { handle_37}
{rank=same; handle_37}

handle_37 [label="le  "]


handle_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_8 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" uses spans and the original string.
 anything not collected by the grammar is 
 quoted verbatim, so if the context is Red,
 it will be Red also. 

"]block_9 -> { codeblock_40}
{rank=same; codeblock_40}

codeblock_40 [label="76  "]


codeblock_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function light(ast, rules)
   if rules then 
      rules = makerules(rules)
   else 
      rules = makerules(testrules) 
   end

   local source = ast:root().str
   local queue = {}
   local phrase = \"\"
   local cursor = 1
   local gap = \"\"
   local ndx, first, last = ast:range()
   local new = true
   for i = first, last do
      local node, close, _ = ndx(i)
      if rules[node.id] 
        and node.val == nil then -- open regional rule
         gap = source:sub(cursor,node.first-1)
         cursor = node.first
         queue[close] = node
         phrase = phrase..gap..rulewrap_open(node,rules)
      elseif node.id and node.val then -- wrap values in rule
         if new then 
            phrase = phrase..source:sub(1,ndx[1].first-1)
            new = false
         end
         if cursor <= node.first then
              gap = source:sub(cursor,node.first-1)
         end
         cursor = node.last+1
         phrase = phrase..gap..rulewrap_value(node,rules)
      end
      if queue[i] then -- close regional rule
         gap = source:sub(cursor,queue[i].last-1)
         cursor = queue[i].last
         phrase = phrase
                  ..rulewrap_open(queue[i],rules)
                  ..gap
                  ..rulewrap_close(queue[i],rules)
      end
   end
   phrase = phrase..source:sub(cursor,-1)
   return phrase
end

--- generates a highlighter from a rule table
"]
block_9 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_10 -> { structure_43 structure_44 structure_45 structure_46}
{rank=same; structure_43 structure_44 structure_45 structure_46}

structure_43 [label="re  "]
structure_44 [label="re  "]
structure_45 [label="re  "]
structure_46 [label="re  "]

structure_43 -> { handleline_47}
{rank=same; handleline_47}

handleline_47 [label="ne  "]

handleline_47 -> { handle_48}
{rank=same; handle_48}

handle_48 [label="le  "]


handle_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]structure_44 -> { handleline_50}
{rank=same; handleline_50}

handleline_50 [label="ne  "]

handleline_50 -> { handle_51}
{rank=same; handle_51}

handle_51 [label="le  "]


handle_51 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]structure_45 -> { handleline_53}
{rank=same; handleline_53}

handleline_53 [label="ne  "]

handleline_53 -> { handle_54}
{rank=same; handle_54}

handle_54 [label="le  "]


handle_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]structure_46 -> { handleline_56}
{rank=same; handleline_56}

handleline_56 [label="ne  "]

handleline_56 -> { handle_57}
{rank=same; handle_57}

handle_57 [label="le  "]


handle_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_10 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_11 -> { codeblock_60}
{rank=same; codeblock_60}

codeblock_60 [label="96  "]


codeblock_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function Highlighter(parser, rules)
   local function lighter(source)
      if type(source) == \"string\" then
         source = ast.parse(parser,source)
      end
      return light(source, rules)
   end
   return lighter
end

return {Highlighter = Highlighter,
      light = light}
"]
block_11 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
}
