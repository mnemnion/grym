digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 82"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-82"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10}

header_2 [label="0 : "]

block_3 [label="block 1-5"]

block_4 [label="block 6-7"]

block_5 [label="block 8-9"]

block_6 [label="block 10-12"]

block_7 [label="block 13-14"]

block_8 [label="block 15-19"]

block_9 [label="block 20-22"]

block_10 [label="block 23-82"]


block_3 -> { prose_11}
{rank=same; prose_11}

prose_11 [label="prose"]


prose_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" This walks an AST, making back references to the parent node.
 
 This shouldn't be a separate step, but that's premature optimization.
"]
block_4 -> { prose_13}
{rank=same; prose_13}

prose_13 [label="prose"]


prose_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" This is conceptually simple:
"]
block_5 -> { prose_15}
{rank=same; prose_15}

prose_15 [label="prose"]


prose_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Take the tree, add a parent reference  that points to itself.
"]
block_6 -> { prose_17}
{rank=same; prose_17}

prose_17 [label="prose"]


prose_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Take all child members, if they're nodes, call the function recursively with the parent and
 nodes as argument.
"]
block_7 -> { prose_19}
{rank=same; prose_19}

prose_19 [label="prose"]


prose_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" This is the usual recursive function wrapped in pre and post matter. 
"]
block_8 -> { prose_21}
{rank=same; prose_21}

prose_21 [label="prose"]


prose_21 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Now that I've added an index, I'm considering a cleaner parent implementation, where the 
 parent is simply a number which must be looked up against the index. To completely eliminate
 back references, the index might be a closure which returns the table given the argument, 
 thus `index(i)` rather than `index[i]`. 
"]
block_9 -> { prose_23}
{rank=same; prose_23}

prose_23 [label="prose"]


prose_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" It would be useful for our decorated AST to have no cycles, since we're guaranteed to 
 traverse it in linear time with no cycle checking. 
"]
block_10 -> { codeblock_25}
{rank=same; codeblock_25}

codeblock_25 [label="code block 23-82"]


codeblock_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local util = require \"lib/util\"
local backwalk = {}

local function make_backref (ast)
   return function() return ast end
end


local function index_gen ()
   local first = {}
   local last  = {}
   local closed = {}
   local depth = {}
   local length = 0
   local meta  = util.F()
   meta.__call = function(_, ordinal)
      return first[ordinal], last[ordinal], depth[ordinal]
   end
   -- This override requires 5.2
   meta.__len = function() return length end
   closed.len = function() return length end
   closed.add = function(table, deep)
      length = length+1
      first[length] = table
      first[table]  = length -- Janus table!
       depth[length] = deep
       depth[table]  = deep
   end
   closed.close = function(table)
      last[first[table]] = length
      last[table] = length
   end
   setmetatable(closed,meta)
   return closed
end

function backwalk.walk_ast (ast)
   local index = index_gen()
   local str = ast.str
   local function walker (ast, parent, deep)
      deep = deep + 1
      if ast.isnode then
         index.add(ast,deep)
         for i, v in ipairs(ast) do
            if type(v) == \"table\" and v.isnode then
                walker(v,ast, deep)
            end
         end
         ast.parent = make_backref(parent)
         index.close(ast)
       end
   end
   walker(ast,ast,0)
   ast.index = index
   return ast 
end

return backwalk"]

}
