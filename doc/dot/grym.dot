digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="23  "]

doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="41  "]

section_1 -> { header_2 block_3 section_4 section_5}
{rank=same; header_2 block_3 section_4 section_5}

header_2 [label="e   "]
block_3 [label="41  "]
section_4 [label="41  "]
section_5 [label="01  "]


block_3 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A metalanguage for magic spells.

"]section_4 -> { header_7 block_8 block_9}
{rank=same; header_7 block_8 block_9}

header_7 [label="es  "]
block_8 [label="-8  "]
block_9 [label="41  "]


block_8 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Like any main entry =grym.lua= is mostly imports.

"]block_9 -> { codeblock_11}
{rank=same; codeblock_11}

codeblock_11 [label="40  "]


codeblock_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="require \"pl.strict\"

local verbose = false


local pl_file  = require \"pl.file\"
local pl_dir   = require \"pl.dir\"
local pl_path  = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

L = require \"lpeg\"

local ansi = require \"lib/ansi\"
u    = require \"lib/util\"


local ast  = require \"peg/ast\"
local epeg = require \"peg/epeg\"

local P_grym = require \"grym/grymmyr\" 
m = require \"grym/morphemes\"
Doc = require \"grym/doc\"

local invert = require \"invert\"
local knit   = require \"knit\"
local weave  = require \"weave\"
"]
block_9 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]section_5 -> { header_14 block_15 block_16 block_17 section_18 section_19}
{rank=same; header_14 block_15 block_16 block_17 section_18 section_19}

header_14 [label="ng  "]
block_15 [label="46  "]
block_16 [label="49  "]
block_17 [label="01  "]
section_18 [label="01  "]
section_19 [label="23  "]


block_15 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is done crudely, we can use =pl.lapp= in future to parse within
commands to each verb.

"]
block_16 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Note here that we pass in the pwd from a shell script. This may 
change, now that we've added [[sh][../lib/sh.lua]]]]

"]block_17 -> { codeblock_22}
{rank=same; codeblock_22}

codeblock_22 [label="90  "]


codeblock_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local pwd, verb = \"\", \"\"

if (arg) then
    pwd = table.remove(arg, 1)
    verb = table.remove(arg, 1)
    for _, v in ipairs(arg) do
        io.write(ansi.yellow(v)..\"\\n\")
    end
end


local grym = {}

grym.invert = invert
grym.knit   = knit
grym.weave  = weave

samples = getfiles(\"samples\")

local own = require \"grym/own\"

if verb == \"invert\" then
    -- If we allow inversion in its present no-guards state,
    -- we will lose all commentary
    u.freeze(\"no\")
    --invert:invert_all(pwd)
elseif verb == \"knit\" then
    -- knitter goes here
    knit:knit_all(pwd)
elseif verb == \"weave\" then
    -- local weaved = weave:weaveMd(Doc(read(\"../orb/grym/block.gm\")))
    -- io.write(weaved)
    weave:weave_all(pwd)    

elseif not verb then
    -- do the things
    weave:weave_all(pwd)
    knit:knit_all(pwd)
end
"]
block_17 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]section_18 -> { header_25 block_26 block_27}
{rank=same; header_25 block_26 block_27}

header_25 [label="ng  "]
block_26 [label="93  "]
block_27 [label="01  "]


block_26 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_27 -> { codeblock_29}
{rank=same; codeblock_29}

codeblock_29 [label="00  "]


codeblock_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sample_doc = Doc(read(\"../orb/grym.orb\")) or \"\"

dot_sh = (require \"sh\"):clear_G().command('dot', '-Tsvg')


"]
block_27 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]section_19 -> { header_32 block_33 block_34}
{rank=same; header_32 block_33 block_34}

header_32 [label="es  "]
block_33 [label="03  "]
block_34 [label="23  "]


block_33 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_34 -> { codeblock_36}
{rank=same; codeblock_36}

codeblock_36 [label="22  "]


codeblock_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="---[[
for _,v in ipairs(samples) do
    if v:match(\"~\") == nil then
        if verbose then io.write(v) end
        local sample = read(v)
        --io.write(v..\"\\n\")
        local doc = Doc(sample)
        local doc_dot = doc:dot()
        local old_dot = read(\"../orb/dot/\" .. v .. \".dot\")
        if old_dot and old_dot ~= doc_dot then
            io.write(\"   -- changed dotfile: \" .. v)
            write(\"../orb/dot/\" .. v .. \"-old.dot\", old_dot)
        end
        write(\"../orb/dot/\" .. v .. \".dot\", doc:dot())
    end
end
--]]
"]
block_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
}
