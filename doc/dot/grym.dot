digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 102"]

doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-102"]

section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 block_8}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 block_8}

header_2 [label="Grimoire "]
block_3 [label="block 1-4"]
block_4 [label="block 5-36"]
block_5 [label="block 37-38"]
block_6 [label="block 39-80"]
block_7 [label="block 81-82"]
block_8 [label="block 83-nil"]


block_3 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A metalanguage for magic spells.

"]block_4 -> { codeblock_10}
{rank=same; codeblock_10}

codeblock_10 [label="code block 5-35"]


codeblock_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="require \"pl.strict\"

local verbose = false


local pl_file  = require \"pl.file\"
local pl_dir   = require \"pl.dir\"
local pl_path  = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

local L = require \"lpeg\"

local ansi = require \"lib/ansi\"
local u    = require \"lib/util\"

local ast  = require \"peg/ast\"
local epeg = require \"peg/epeg\"

local P_grym = require \"grym/grymmyr\" 
local m = require \"grym/morphemes\"
local Doc = require \"grym/doc\"

local invert = require \"invert\"
local knit   = require \"knit\"
local weave  = require \"weave\"
"]
block_4 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_5 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Argument parsing goes here

"]block_6 -> { codeblock_14}
{rank=same; codeblock_14}

codeblock_14 [label="code block 39-78"]


codeblock_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local pwd, verb = \"\", \"\"

if (arg) then
    pwd = table.remove(arg, 1)
    verb = table.remove(arg, 1)
    for _, v in ipairs(arg) do
        io.write(ansi.yellow(v)..\"\n\")
    end
end


local grym = {}

grym.invert = invert
grym.knit = knit

samples = getfiles(\"samples\")

local own = require \"grym/own\"

if verb == \"invert\" then
    -- If we allow inversion in its present no-guards state,
    -- we will lose all commentary
    u.freeze(\"no\")
    --invert:invert_all(pwd)
elseif verb == \"knit\" then
    -- knitter goes here
    knit:knit_all(pwd)
elseif verb == \"weave\" then
    -- local weaved = weave:weaveMd(Doc(read(\"../orb/grym/block.gm\")))
    -- io.write(weaved)
    weave:weave_all(pwd)    

elseif not verb then
    -- do the things
    weave:weave_all(pwd)
    knit:knit_all(pwd)
end
"]
block_6 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
block_7 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Run the samples and make dotfiles

"]block_8 -> { codeblock_18}
{rank=same; codeblock_18}

codeblock_18 [label="code block 83-101"]


codeblock_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="--[[
for _,v in ipairs(samples) do
    if v:match(\"~\") == nil then
        if verbose then io.write(v) end
        local sample = read(v)
        --io.write(v..\"\n\")
        local doc = Doc(sample)
        local doc_dot = doc:dot()
        local old_dot = read(\"../org/dot/\" .. v .. \".dot\")
        if old_dot and old_dot ~= doc_dot then
            io.write(\"   -- changed dotfile: \" .. v)
            write(\"../org/dot/\" .. v .. \"-old.dot\", old_dot)
        end
        write(\"../org/dot/\" .. v .. \".dot\", doc:dot())
    end
end
--]]
"]
block_8 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
}
