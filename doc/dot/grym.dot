digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 167"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-60"]


section_1 -> { header_2 block_3 section_4 section_5}
{rank=same; header_2 block_3 section_4 section_5}

header_2 [label="1 : Grimoire "]

block_3 [label="block 1-60"]

section_4 [label="section: 5-41"]

section_5 [label="section: 61-145"]


block_3 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A metalanguage for magic spells.
"]
section_4 -> { header_7 block_8 section_9 section_10}
{rank=same; header_7 block_8 section_9 section_10}

header_7 [label="2 : Requires"]

block_8 [label="block 5-41"]

section_9 [label="section: 10-41"]

section_10 [label="section: 42-60"]


block_8 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Like any main entry =grym.lua= is mostly imports.

"]
section_9 -> { header_12 block_13 block_14}
{rank=same; header_12 block_13 block_14}

header_12 [label="3 : locals"]

block_13 [label="block 10-11"]

block_14 [label="block 12-41"]


block_13 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_14 -> { codeblock_16}
{rank=same; codeblock_16}

codeblock_16 [label="code block 12-39"]


codeblock_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="require \"pl.strict\"

local verbose = false


local pl_file  = require \"pl.file\"
local pl_dir   = require \"pl.dir\"
local pl_path  = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

local ansi = require \"ansi\"

local P_grym = require \"grym/grymmyr\" 

local invert = require \"invert\"
local knit   = require \"knit\"
local weave  = require \"weave\"

local ast  = require \"peg/ast\"
local epeg = require \"peg/epeg\"

"]
block_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_9 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** locals

#!lua
require \"pl.strict\"

local verbose = false


local pl_file  = require \"pl.file\"
local pl_dir   = require \"pl.dir\"
local pl_path  = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

local ansi = require \"ansi\"

local P_grym = require \"grym/grymmyr\" 

local invert = require \"invert\"
local knit   = require \"knit\"
local weave  = require \"weave\"

local ast  = require \"peg/ast\"
local epeg = require \"peg/epeg\"


#/lua


*"]
section_10 -> { header_20 block_21 block_22 block_23}
{rank=same; header_20 block_21 block_22 block_23}

header_20 [label="3 : globals"]

block_21 [label="block 42-45"]

block_22 [label="block 46-47"]

block_23 [label="block 48-60"]


block_21 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  For interactive and introspective development.
"]
block_22 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Can't wait to build a reasonable REPL.
"]
block_23 -> { codeblock_26}
{rank=same; codeblock_26}

codeblock_26 [label="code block 48-59"]


codeblock_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="L = require \"lpeg\"
u = require \"util\"
s = require \"status\"
m = require \"grym/morphemes\"
Doc = require \"grym/doc\"

Link = require \"grym/link\"

spec = require \"node/spec\"
pnf = require \"node/define\""]
block_23 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_10 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** globals

  For interactive and introspective development.

Can't wait to build a reasonable REPL.

#!lua
L = require \"lpeg\"
u = require \"util\"
s = require \"status\"
m = require \"grym/morphemes\"
Doc = require \"grym/doc\"

Link = require \"grym/link\"

spec = require \"node/spec\"
pnf = require \"node/define\"
#/lua

*"]
section_4 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Requires

Like any main entry =grym.lua= is mostly imports.


*** locals

#!lua
require \"pl.strict\"

local verbose = false


local pl_file  = require \"pl.file\"
local pl_dir   = require \"pl.dir\"
local pl_path  = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

local ansi = require \"ansi\"

local P_grym = require \"grym/grymmyr\" 

local invert = require \"invert\"
local knit   = require \"knit\"
local weave  = require \"weave\"

local ast  = require \"peg/ast\"
local epeg = require \"peg/epeg\"


#/lua


*"]
section_5 -> { header_31 block_32 block_33 block_34 section_35 section_36}
{rank=same; header_31 block_32 block_33 block_34 section_35 section_36}

header_31 [label="2 : Argument parsing"]

block_32 [label="block 61-65"]

block_33 [label="block 66-68"]

block_34 [label="block 69-145"]

section_35 [label="section: 136-145"]

section_36 [label="section: 146-167"]


block_32 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is done crudely, we can use =pl.lapp= in future to parse within
commands to each verb.
"]
block_33 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Note here that we pass in the pwd from a shell script. This may 
change, now that we've added [[sh][../lib/sh.lua]]]]
"]
block_34 -> { codeblock_39}
{rank=same; codeblock_39}

codeblock_39 [label="code block 69-134"]


codeblock_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local pwd, verb = \"\", \"\"

if (arg) then
    pwd = table.remove(arg, 1)
    verb = table.remove(arg, 1)
    for _, v in ipairs(arg) do
        io.write(ansi.yellow(v)..\"\\n\")
    end
end


local grym = {}

grym.invert = invert
grym.knit   = knit
grym.weave  = weave

samples = getfiles(\"samples\")

local own = require \"grym/own\"

if verb == \"invert\" then
    -- If we allow inversion in its present no-guards state,
    -- we will lose all commentary
    u.freeze(\"no\")
    --invert:invert_all(pwd)
elseif verb == \"knit\" then
    -- knitter goes here
    knit:knit_all(pwd)
elseif verb == \"weave\" then
    -- local weaved = weave:weaveMd(Doc(read(\"../orb/grym/block.gm\")))
    -- io.write(weaved)
    weave:weave_all(pwd) 
elseif verb == \"spec\" then
    -- This is just a shim to get us inside whatever
    -- I'm working on
    local abstr = \"(form (inner form 23))\"
    local abNode = spec.clu(abstr)
    assert(abNode.isNode)
    io.write(tostring(abNode))
    io.write(tostring(abNode:dot()))
    io.write(\"nodewalker:\\n\")
    for node in abNode:walkDeep() do
        io.write(node.id .. \" -- \")
    end
    io.write(\"\\n\")
    for node in abNode:walk() do
        io.write(node.id .. \" ~~ \")
    end
    io.write(\"\\n\")
    for node in abNode:select(\"bmatch\") do
        io.write(node.id .. \" %% \")
    end
    io.write(\"\\n\")
    for tok in abNode:tokens() do
        io.write(tok .. \" || \")
    end
    io.write(\"\\n\")

elseif not verb then
    -- do the things
    weave:weave_all(pwd)
    knit:knit_all(pwd)
end"]
block_34 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_35 -> { header_42 block_43 block_44}
{rank=same; header_42 block_43 block_44}

header_42 [label="4 : Sample Doc for REPLing"]

block_43 [label="block 136-137"]

block_44 [label="block 138-145"]


block_43 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_44 -> { codeblock_46}
{rank=same; codeblock_46}

codeblock_46 [label="code block 138-144"]


codeblock_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sample_doc = Doc(read(\"../orb/grym.orb\")) or \"\"

dot_sh = (require \"sh\"):clear_G().command('dot', '-Tsvg')

"]
block_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_35 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Sample Doc for REPLing

#!lua
sample_doc = Doc(read(\"../orb/grym.orb\")) or \"\"

dot_sh = (require \"sh\"):clear_G().command('dot', '-Tsvg')


#/lua

*"]
section_36 -> { header_50 block_51 block_52}
{rank=same; header_50 block_51 block_52}

header_50 [label="3 : Run the samples and make dotfiles"]

block_51 [label="block 146-147"]

block_52 [label="block 148-167"]


block_51 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_52 -> { codeblock_54}
{rank=same; codeblock_54}

codeblock_54 [label="code block 148-166"]


codeblock_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="---[[
for _,v in ipairs(samples) do
    if v:match(\"~\") == nil then
        if verbose then io.write(v) end
        local sample = read(v)
        --io.write(v..\"\\n\")
        local doc = Doc(sample)
        local doc_dot = doc:dot()
        local old_dot = read(\"../orb/dot/\" .. v .. \".dot\")
        if old_dot and old_dot ~= doc_dot then
            io.write(\"   -- changed dotfile: \" .. v)
            write(\"../orb/dot/\" .. v .. \"-old.dot\", old_dot)
        end
        write(\"../orb/dot/\" .. v .. \".dot\", doc:dot())
    end
end
--]]"]
block_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_36 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Run the samples and make dotfiles

#!lua
---[[
for _,v in ipairs(samples) do
    if v:match(\"~\") == nil then
        if verbose then io.write(v) end
        local sample = read(v)
        --io.write(v..\"\\n\")
        local doc = Doc(sample)
        local doc_dot = doc:dot()
        local old_dot = read(\"../orb/dot/\" .. v .. \".dot\")
        if old_dot and old_dot ~= doc_dot then
            io.write(\"   -- changed dotfile: \" .. v)
            write(\"../orb/dot/\" .. v .. \"-old.dot\", old_dot)
        end
        write(\"../orb/dot/\" .. v .. \".dot\", doc:dot())
    end
end
--]]
#/lua"]
section_5 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Argument parsing

This is done crudely, we can use =pl.lapp= in future to parse within
commands to each verb.

Note here that we pass in the pwd from a shell script. This may 
change, now that we've added [[sh][../lib/sh.lua]]]]

#!lua
local pwd, verb = \"\", \"\"

if (arg) then
    pwd = table.remove(arg, 1)
    verb = table.remove(arg, 1)
    for _, v in ipairs(arg) do
        io.write(ansi.yellow(v)..\"\\n\")
    end
end


local grym = {}

grym.invert = invert
grym.knit   = knit
grym.weave  = weave

samples = getfiles(\"samples\")

local own = require \"grym/own\"

if verb == \"invert\" then
    -- If we allow inversion in its present no-guards state,
    -- we will lose all commentary
    u.freeze(\"no\")
    --invert:invert_all(pwd)
elseif verb == \"knit\" then
    -- knitter goes here
    knit:knit_all(pwd)
elseif verb == \"weave\" then
    -- local weaved = weave:weaveMd(Doc(read(\"../orb/grym/block.gm\")))
    -- io.write(weaved)
    weave:weave_all(pwd) 
elseif verb == \"spec\" then
    -- This is just a shim to get us inside whatever
    -- I'm working on
    local abstr = \"(form (inner form 23))\"
    local abNode = spec.clu(abstr)
    assert(abNode.isNode)
    io.write(tostring(abNode))
    io.write(tostring(abNode:dot()))
    io.write(\"nodewalker:\\n\")
    for node in abNode:walkDeep() do
        io.write(node.id .. \" -- \")
    end
    io.write(\"\\n\")
    for node in abNode:walk() do
        io.write(node.id .. \" ~~ \")
    end
    io.write(\"\\n\")
    for node in abNode:select(\"bmatch\") do
        io.write(node.id .. \" %% \")
    end
    io.write(\"\\n\")
    for tok in abNode:tokens() do
        io.write(tok .. \" || \")
    end
    io.write(\"\\n\")

elseif not verb then
    -- do the things
    weave:weave_all(pwd)
    knit:knit_all(pwd)
end
#/lua

**** Sample Doc for REPLing

#!lua
sample_doc = Doc(read(\"../orb/grym.orb\")) or \"\"

dot_sh = (require \"sh\"):clear_G().command('dot', '-Tsvg')


#/lua

*"]
section_1 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grimoire 

A metalanguage for magic spells.

** Requires

Like any main entry =grym.lua= is mostly imports.


*** locals

#!lua
require \"pl.strict\"

local verbose = false


local pl_file  = require \"pl.file\"
local pl_dir   = require \"pl.dir\"
local pl_path  = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

local ansi = require \"ansi\"

local P_grym = require \"grym/grymmyr\" 

local invert = require \"invert\"
local knit   = require \"knit\"
local weave  = require \"weave\"

local ast  = require \"peg/ast\"
local epeg = require \"peg/epeg\"


#/lua


*** globals

  For interactive and introspective development.

Can't wait to build a reasonable REPL.

#!lua
L = require \"lpeg\"
u = require \"util\"
s = require \"status\"
m = require \"grym/morphemes\"
Doc = require \"grym/doc\"

Link = require \"grym/link\"

spec = require \"node/spec\"
pnf = require \"node/define\"
#/lua

*"]

}
