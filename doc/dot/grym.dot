digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 176"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-69"]


section_1 -> { header_2 prose_3 section_4 section_5}
{rank=same; header_2 prose_3 section_4 section_5}

header_2 [label="1 : Grimoire "]

prose_3 [label="prose"]

section_4 [label="section: 5-38"]

section_5 [label="section: 70-154"]


header_2 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grimoire "]
prose_3 -> { raw_7}
{rank=same; raw_7}

raw_7 [label="raw"]


raw_7 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A metalanguage for magic spells.
"]
section_4 -> { header_9 prose_10 section_11 section_12}
{rank=same; header_9 prose_10 section_11 section_12}

header_9 [label="2 : Requires"]

prose_10 [label="prose"]

section_11 [label="section: 10-38"]

section_12 [label="section: 39-58"]


header_9 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Requires"]
prose_10 -> { raw_14}
{rank=same; raw_14}

raw_14 [label="raw"]


raw_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Like any main entry =grym.lua= is mostly imports.

"]
section_11 -> { header_16 prose_17 codeblock_18}
{rank=same; header_16 prose_17 codeblock_18}

header_16 [label="3 : locals"]

prose_17 [label="prose"]

codeblock_18 [label="code block 12-36"]


header_16 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** locals"]
prose_17 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_18 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="require \"pl.strict\"

local verbose = false


local pl_file  = require \"pl.file\"
local pl_dir   = require \"pl.dir\"
local pl_path  = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

local ansi = require \"ansi\"

local invert = require \"invert\"
local knit   = require \"knit\"
local weave  = require \"weave\"

local epeg = require \"epeg\"

"]
section_12 -> { header_23 prose_24 prose_25 codeblock_26 section_27}
{rank=same; header_23 prose_24 prose_25 codeblock_26 section_27}

header_23 [label="3 : globals"]

prose_24 [label="prose"]

prose_25 [label="prose"]

codeblock_26 [label="code block 45-56"]

section_27 [label="section: 59-69"]


header_23 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** globals"]
prose_24 -> { raw_29}
{rank=same; raw_29}

raw_29 [label="raw"]


raw_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  For interactive and introspective development.
"]
prose_25 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Can't wait to build a reasonable REPL.
"]
codeblock_26 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="L = require \"lpeg\"
u = require \"util\"
s = require \"status\"
m = require \"grym/morphemes\"
Doc = require \"grym/doc\"

Link = require \"grym/link\"

spec = require \"node/spec\"
Node = require \"node/node\""]
section_27 -> { header_34 prose_35 codeblock_36}
{rank=same; header_34 prose_35 codeblock_36}

header_34 [label="4 : Sample Doc for REPLing"]

prose_35 [label="prose"]

codeblock_36 [label="code block 64-68"]


header_34 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Sample Doc for REPLing"]
prose_35 -> { raw_38 link_39 raw_40}
{rank=same; raw_38 link_39 raw_40}

raw_38 [label="raw"]

link_39 [label="link"]

raw_40 [label="raw"]


raw_38 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  I'm going to add a "]
link_39 -> { anchortext_42 url_43}
{rank=same; anchortext_42 url_43}

anchortext_42 [label="anchortext"]

url_43 [label="url"]


anchortext_42 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="link here"]
url_43 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_40 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="]], to have something
to work with.
"]
codeblock_36 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sample_doc = Doc(read(\"../orb/grym.orb\")) or \"\"

dot_sh = (require \"sh\"):clear_G().command('dot', '-Tsvg')"]
section_5 -> { header_48 prose_49 prose_50 codeblock_51 section_52}
{rank=same; header_48 prose_49 prose_50 codeblock_51 section_52}

header_48 [label="2 : Argument parsing"]

prose_49 [label="prose"]

prose_50 [label="prose"]

codeblock_51 [label="code block 78-152"]

section_52 [label="section: 155-176"]


header_48 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Argument parsing"]
prose_49 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is done crudely, we can use =pl.lapp= in future to parse within
commands to each verb.
"]
prose_50 -> { raw_56}
{rank=same; raw_56}

raw_56 [label="raw"]


raw_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Note here that we pass in the pwd from a shell script. This may 
change, now that we've added [[sh][../lib/sh.lua]]]]
"]
codeblock_51 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local pwd, verb = \"\", \"\"

if (arg) then
    pwd = table.remove(arg, 1)
    verb = table.remove(arg, 1)
    for _, v in ipairs(arg) do
        io.write(ansi.yellow(v)..\"\\n\")
    end
end


local grym = {}

grym.invert = invert
grym.knit   = knit
grym.weave  = weave

samples = getfiles(\"samples\")

local own = require \"grym/own\"

if verb == \"invert\" then
    -- If we allow inversion in its present no-guards state,
    -- we will lose all commentary
    u.freeze(\"no\")
    --invert:invert_all(pwd)
elseif verb == \"knit\" then
    -- knitter goes here
    knit:knit_all(pwd)
elseif verb == \"weave\" then
    -- local weaved = weave:weaveMd(Doc(read(\"../orb/grym/block.gm\")))
    -- io.write(weaved)
    weave:weave_all(pwd) 
elseif verb == \"spec\" then
    -- This is just a shim to get us inside whatever
    -- I'm working on
    local abstr = \"((first second) third (fourth fifth 23))\"
    local abNode = spec.clu(abstr)
    assert(abNode.isNode)
    io.write(tostring(abNode))
    io.write(tostring(abNode:dot()))
    io.write(\"nodewalker:\\n\")
    for node in abNode:walkDeep() do
        io.write(node.id .. \" -- \")
    end
    io.write(\"\\n\")
    for node in abNode:walk() do
        io.write(node.id .. \" ~~ \")
    end
    io.write(\"\\n\")
    for node in abNode:select(\"atom\") do
        io.write(node.id .. \" %% \")
    end
    io.write(\"\\n\")
    for tok in abNode:tokens() do
        io.write(tok .. \" || \")
    end
    io.write(\"\\n\\n\"..ansi.cyan(\"DOC SEQUENCE\")..\"\\n\")
    for sec in sample_doc:select(\"section\") do
        io.write(ansi.magenta(\"section\") .. \"\\n\")
        io.write(tostring(sec) .. \"\\n\")
    end
    local sects = sample_doc:gather \"section\"
    for _, sec in ipairs(sects) do
        io.write(ansi.cyan(\"section\") .. \"\\n\")
        io.write(tostring(sec) .. \"\\n\")
    end

elseif not verb then
    -- do the things
    weave:weave_all(pwd)
    knit:knit_all(pwd)
end"]
section_52 -> { header_59 prose_60 codeblock_61}
{rank=same; header_59 prose_60 codeblock_61}

header_59 [label="3 : Run the samples and make dotfiles"]

prose_60 [label="prose"]

codeblock_61 [label="code block 157-175"]


header_59 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Run the samples and make dotfiles"]
prose_60 -> { raw_63}
{rank=same; raw_63}

raw_63 [label="raw"]


raw_63 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_61 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="---[[
for _,v in ipairs(samples) do
    if v:match(\"~\") == nil then
        if verbose then io.write(v) end
        local sample = read(v)
        --io.write(v..\"\\n\")
        local doc = Doc(sample)
        local doc_dot = doc:dot()
        local old_dot = read(\"../orb/dot/\" .. v .. \".dot\")
        if old_dot and old_dot ~= doc_dot then
            io.write(\"   -- changed dotfile: \" .. v)
            write(\"../orb/dot/\" .. v .. \"-old.dot\", old_dot)
        end
        write(\"../orb/dot/\" .. v .. \".dot\", doc:dot())
    end
end
--]]"]

}
