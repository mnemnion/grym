digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 34"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-34"]


section_1 -> { header_2 prose_3 codeblock_4 codeblock_5 codeblock_6}
{rank=same; header_2 prose_3 codeblock_4 codeblock_5 codeblock_6}

header_2 [label="1 : Grammar Module"]

prose_3 [label="prose"]

codeblock_4 [label="code block 4-9"]

codeblock_5 [label="code block 14-30"]

codeblock_6 [label="code block 32-34"]


prose_3 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
codeblock_4 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"status\" 
local define = require \"node/define\""]
codeblock_5 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(grammar_template, metas)
    local metas = metas or {}
  if type(grammar_template) == 'function' then
    local grammar = define.define(grammar_template, nil, metas)
    io.write(\"type of grammar is \" .. type(grammar) .. \"\\n\")
    for k,v in pairs(grammar) do
      io.write(\"  \" .. tostring(k) .. \"  \" .. tostring(v) .. \"\\n\")
    end
    return function(str)
            return L.match(grammar, str, 1, str) -- other 
         end
  else
    s:halt(\"no way to build grammar out of \" .. type(template))
  end
end"]
codeblock_6 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]

}
