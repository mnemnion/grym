digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 272"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-177"]


section_1 -> { header_2}
{rank=same; header_2}

header_2 [label="1 : Node"]


section_3 -> { header_6}
{rank=same; header_6}

header_6 [label="3 : includes"]


codeblock_7 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\"
local dot = require \"node/dot\""]
section_4 -> { header_9}
{rank=same; header_9}

header_9 [label="2 : Node metatable"]


codeblock_10 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local N = {}
N.__index = N
N.isNode = true"]
section_11 -> { header_14}
{rank=same; header_14}

header_14 [label="3 : Fields"]


section_12 -> { header_15}
{rank=same; header_15}

header_15 [label="3 : Methods"]


codeblock_16 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. \"id: \" .. node.id .. \",  \"
      .. \"first: \" .. node.first .. \", last: \" .. node.last .. \"\\n\"
   if node[1] then
    for _,v in ipairs(node) do
      if(v.isNode) then
        phrase = phrase .. N.toString(v, depth + 1)
      end
    end
  end 
   return phrase
end"]
codeblock_17 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.dotLabel(node)
  return node.id
end

function N.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function N.dot(node)
  return dot.dot(node)
end

function N.toValue(node)
  return node.str:sub(node.first,node.last)
end
"]
section_18 -> { header_24}
{rank=same; header_24}

header_24 [label="4 : N.walkDeep"]


codeblock_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.walkDeep(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_19 -> { header_27}
{rank=same; header_27}

header_27 [label="4 : N.walk"]


codeblock_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_20 -> { header_30}
{rank=same; header_30}

header_30 [label="4 : N.select(node, pred)"]


codeblock_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' and node.isNode and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

  return coroutine.wrap(function() traverse(node) end)
end"]
section_21 -> { header_33}
{rank=same; header_33}

header_33 [label="4 : N.tokens(node)"]


codeblock_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.tokens(node)
  local function traverse(ast)
    for node in N.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_5 -> { header_36}
{rank=same; header_36}

header_36 [label="2 : Node Instances"]


section_37 -> { header_39}
{rank=same; header_39}

header_39 [label="3 : Fields"]


section_40 -> { header_41}
{rank=same; header_41}

header_41 [label="4 : line tracking (optional)"]


section_38 -> { header_42}
{rank=same; header_42}

header_42 [label="3 : Other fields"]


codeblock_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return N"]

}
