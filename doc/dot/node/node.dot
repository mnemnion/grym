digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 272"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-177"]


section_1 -> { header_2 block_3 section_4 section_5 section_6}
{rank=same; header_2 block_3 section_4 section_5 section_6}

header_2 [label="1 : Node"]

block_3 [label="block 1-177"]

section_4 [label="section: 6-12"]

section_5 [label="section: 13-35"]

section_6 [label="section: 178-237"]


block_3 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Time to stabilize this class once and for all. 
"]
section_4 -> { header_8 block_9 block_10}
{rank=same; header_8 block_9 block_10}

header_8 [label="3 : includes"]

block_9 [label="block 6-7"]

block_10 [label="block 8-12"]


block_9 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_10 -> { codeblock_12}
{rank=same; codeblock_12}

codeblock_12 [label="code block 8-11"]


codeblock_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\"
local dot = require \"node/dot\""]
block_10 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_4 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes

#!lua
local s = require \"status\"
local dot = require \"node/dot\"
#/lua

*"]
section_5 -> { header_16 block_17 block_18 section_19 section_20}
{rank=same; header_16 block_17 block_18 section_19 section_20}

header_16 [label="2 : Node metatable"]

block_17 [label="block 13-18"]

block_18 [label="block 19-35"]

section_19 [label="section: 28-35"]

section_20 [label="section: 36-159"]


block_17 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is =str=. 
"]
block_18 -> { codeblock_22}
{rank=same; codeblock_22}

codeblock_22 [label="code block 19-24"]


codeblock_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local N = {}
N.__index = N
N.isNode = true"]
block_18 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_19 -> { header_25 block_26}
{rank=same; header_25 block_26}

header_25 [label="3 : Fields"]

block_26 [label="block 28-35"]


block_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
   - line_first :  Always -1.
   - line_last  :  Always -1. 
"]
section_19 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
   - line_first :  Always -1.
   - line_last  :  Always -1. 

*"]
section_20 -> { header_29 block_30 block_31 block_32 section_33 section_34 section_35 section_36}
{rank=same; header_29 block_30 block_31 block_32 section_33 section_34 section_35 section_36}

header_29 [label="3 : Methods"]

block_30 [label="block 36-37"]

block_31 [label="block 38-54"]

block_32 [label="block 55-159"]

section_33 [label="section: 78-98"]

section_34 [label="section: 99-121"]

section_35 [label="section: 122-159"]

section_36 [label="section: 160-177"]


block_30 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_31 -> { codeblock_38}
{rank=same; codeblock_38}

codeblock_38 [label="code block 38-53"]


codeblock_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. \"id: \" .. node.id .. \",  \"
      .. \"first: \" .. node.first .. \", last: \" .. node.last .. \"\\n\"
   if node[1] then
    for _,v in ipairs(node) do
      if(v.isNode) then
        phrase = phrase .. N.toString(v, depth + 1)
      end
    end
  end 
   return phrase
end"]
block_31 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_32 -> { codeblock_41}
{rank=same; codeblock_41}

codeblock_41 [label="code block 55-76"]


codeblock_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.dotLabel(node)
  return node.id
end

function N.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function N.dot(node)
  return dot.dot(node)
end

function N.toValue(node)
  return node.str:sub(node.first,node.last)
end
"]
block_32 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_33 -> { header_44 block_45 block_46}
{rank=same; header_44 block_45 block_46}

header_44 [label="4 : N.walkDeep"]

block_45 [label="block 78-81"]

block_46 [label="block 82-98"]


block_45 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Depth-first iterator. 
"]
block_46 -> { codeblock_48}
{rank=same; codeblock_48}

codeblock_48 [label="code block 82-97"]


codeblock_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.walkDeep(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
block_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_33 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.walkDeep

Depth-first iterator. 

#!lua
function N.walkDeep(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end
#/lua

*"]
section_34 -> { header_52 block_53 block_54}
{rank=same; header_52 block_53 block_54}

header_52 [label="4 : N.walk"]

block_53 [label="block 99-102"]

block_54 [label="block 103-121"]


block_53 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Breadth-first iterator.  This is the default. 
"]
block_54 -> { codeblock_56}
{rank=same; codeblock_56}

codeblock_56 [label="code block 103-119"]


codeblock_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
block_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_34 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.walk

Breadth-first iterator.  This is the default. 

#!lua
function N.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end

#/lua


*"]
section_35 -> { header_60 block_61 block_62}
{rank=same; header_60 block_61 block_62}

header_60 [label="4 : N.select(node, pred)"]

block_61 [label="block 122-127"]

block_62 [label="block 128-159"]


block_61 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Takes the Node and walks it, yielding the Nodes which match the predicate.
=pred= is either a string, which matches to =id=, or a function, which takes
a Node and returns true or false on some premise. 
"]
block_62 -> { codeblock_64}
{rank=same; codeblock_64}

codeblock_64 [label="code block 128-157"]


codeblock_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' and node.isNode and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

  return coroutine.wrap(function() traverse(node) end)
end"]
block_62 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_35 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.select(node, pred)

  Takes the Node and walks it, yielding the Nodes which match the predicate.
=pred= is either a string, which matches to =id=, or a function, which takes
a Node and returns true or false on some premise. 

#!lua
function N.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' and node.isNode and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

  return coroutine.wrap(function() traverse(node) end)
end
#/lua


*"]
section_36 -> { header_68 block_69 block_70}
{rank=same; header_68 block_69 block_70}

header_68 [label="4 : N.tokens(node)"]

block_69 [label="block 160-163"]

block_70 [label="block 164-177"]


block_69 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Iterator returning all 'captured' values as strings.
"]
block_70 -> { codeblock_72}
{rank=same; codeblock_72}

codeblock_72 [label="code block 164-176"]


codeblock_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.tokens(node)
  local function traverse(ast)
    for node in N.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
block_70 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_36 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.tokens(node)

  Iterator returning all 'captured' values as strings.

#!lua
function N.tokens(node)
  local function traverse(ast)
    for node in N.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  
#/lua  

*"]
section_20 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Methods

#!lua
function N.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. \"id: \" .. node.id .. \",  \"
      .. \"first: \" .. node.first .. \", last: \" .. node.last .. \"\\n\"
   if node[1] then
    for _,v in ipairs(node) do
      if(v.isNode) then
        phrase = phrase .. N.toString(v, depth + 1)
      end
    end
  end 
   return phrase
end
#/lua

#!lua
function N.dotLabel(node)
  return node.id
end

function N.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function N.dot(node)
  return dot.dot(node)
end

function N.toValue(node)
  return node.str:sub(node.first,node.last)
end

#/lua

**** N.walkDeep

Depth-first iterator. 

#!lua
function N.walkDeep(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end
#/lua

**** N.walk

Breadth-first iterator.  This is the default. 

#!lua
function N.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end

#/lua


**** N.select(node, pred)

  Takes the Node and walks it, yielding the Nodes which match the predicate.
=pred= is either a string, which matches to =id=, or a function, which takes
a Node and returns true or false on some premise. 

#!lua
function N.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' and node.isNode and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

  return coroutine.wrap(function() traverse(node) end)
end
#/lua


*"]
section_5 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable

  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is =str=. 

#!lua

local N = {}
N.__index = N
N.isNode = true
#/lua



*** Fields

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
   - line_first :  Always -1.
   - line_last  :  Always -1. 

*"]
section_6 -> { header_78 block_79 block_80 block_81 block_82 block_83 section_84 section_85}
{rank=same; header_78 block_79 block_80 block_81 block_82 block_83 section_84 section_85}

header_78 [label="2 : Node Instances"]

block_79 [label="block 178-182"]

block_80 [label="block 183-186"]

block_81 [label="block 187-190"]

block_82 [label="block 191-196"]

block_83 [label="block 197-237"]

section_84 [label="section: 202-224"]

section_85 [label="section: 238-272"]


block_79 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  To be a Node, currently, indexed elements of the Array portion must also be 
Nodes. 
"]
block_80 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="I'm mostly convinced that indexed elements can also be strings, and that 
this is the form leaf nodes should take.  Currently, they have a 'val' field
and no children, which we should replace with a child string at [1].
"]
block_81 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This gives us a lighter way to handle the circumstance where we have, say,
a list, =(foo bar baz)=. We currently either need a \"left-per\" or \"pal\"
Node class to hold the =(=, or we would have to skip it entirely.
"]
block_82 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Quipu can't lose any information from the string, so they have to include
whitespace.  We're not limited in the same way and can reconstruct less 
semantically crucial parts of a document using the span and the original 
string, since we're not /currently/ editing our strings once they're
entered in.
"]
block_83 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Nodes are meant to be broadly compatible with everything we intend to
do with abstract syntax trees.  The more I think about this the better
it strikes me as an approach. 

"]
section_84 -> { header_91 block_92 block_93 block_94 block_95 block_96 section_97}
{rank=same; header_91 block_92 block_93 block_94 block_95 block_96 section_97}

header_91 [label="3 : Fields"]

block_92 [label="block 202-208"]

block_93 [label="block 209-211"]

block_94 [label="block 212-215"]

block_95 [label="block 216-220"]

block_96 [label="block 221-224"]

section_97 [label="section: 225-237"]


block_92 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into =str= which begins the span.
  - last  :  Index into =str= which ends the span.
"]
block_93 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In principle, we want the Node to be localized. We could include a 
reference to the whole =str= and derive substrings lazily.
"]
block_94 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 
"]
block_95 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 
"]
block_96 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 

"]
section_97 -> { header_103 block_104 block_105 block_106 block_107}
{rank=same; header_103 block_104 block_105 block_106 block_107}

header_103 [label="4 : line tracking (optional)"]

block_104 [label="block 225-228"]

block_105 [label="block 229-231"]

block_106 [label="block 232-234"]

block_107 [label="block 235-237"]


block_104 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It may be wise to always track lines, in which case we will include:
"]
block_105 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends
"]
block_106 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 
"]
block_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- [ ] #todo decide if line tracking is in fact optional

"]
section_97 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** line tracking (optional)

It may be wise to always track lines, in which case we will include:

  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends

This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 

- [ ] #todo decide if line tracking is in fact optional


*"]
section_84 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into =str= which begins the span.
  - last  :  Index into =str= which ends the span.

In principle, we want the Node to be localized. We could include a 
reference to the whole =str= and derive substrings lazily.

If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 

So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 

This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 


*"]
section_85 -> { header_114 block_115 block_116 block_117 block_118 block_119 block_120 block_121 block_122 block_123}
{rank=same; header_114 block_115 block_116 block_117 block_118 block_119 block_120 block_121 block_122 block_123}

header_114 [label="3 : Other fields"]

block_115 [label="block 238-243"]

block_116 [label="block 244-246"]

block_117 [label="block 247-249"]

block_118 [label="block 250-253"]

block_119 [label="block 254-258"]

block_120 [label="block 259-260"]

block_121 [label="block 261-263"]

block_122 [label="block 264-266"]

block_123 [label="block 267-272"]


block_115 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  The way the Grammar class will work: each =V\"patt\"= can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 
"]
block_116 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 
"]
block_117 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="If it does, the metatable will have a =__call= method, which expects two
parameters, itself, and the node, which will include the span. 
"]
block_118 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This will require reattunement of basically every class in the =/grym= folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.
"]
block_119 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 
"]
block_120 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="In the meantime we have things like
"]
block_121 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- lines :  If this exists, there's a collection of lines which need to be
           joined with =\\n= to reconstruct the actual span.
"]
block_122 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="           We want to do this the other way, and use the span itself for the
           inner parse. 
"]
block_123 -> { codeblock_132}
{rank=same; codeblock_132}

codeblock_132 [label="code block 267-269"]


codeblock_132 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return N"]
block_123 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_85 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields

  The way the Grammar class will work: each =V\"patt\"= can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 

If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 

If it does, the metatable will have a =__call= method, which expects two
parameters, itself, and the node, which will include the span. 

This will require reattunement of basically every class in the =/grym= folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.

The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 

In the meantime we have things like

- lines :  If this exists, there's a collection of lines which need to be
           joined with =\\n= to reconstruct the actual span.

           We want to do this the other way, and use the span itself for the
           inner parse. 

#!lua
return N
#/lua

"]
section_6 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances

  To be a Node, currently, indexed elements of the Array portion must also be 
Nodes. 

I'm mostly convinced that indexed elements can also be strings, and that 
this is the form leaf nodes should take.  Currently, they have a 'val' field
and no children, which we should replace with a child string at [1].

This gives us a lighter way to handle the circumstance where we have, say,
a list, =(foo bar baz)=. We currently either need a \"left-per\" or \"pal\"
Node class to hold the =(=, or we would have to skip it entirely.

Quipu can't lose any information from the string, so they have to include
whitespace.  We're not limited in the same way and can reconstruct less 
semantically crucial parts of a document using the span and the original 
string, since we're not /currently/ editing our strings once they're
entered in.

Nodes are meant to be broadly compatible with everything we intend to
do with abstract syntax trees.  The more I think about this the better
it strikes me as an approach. 


*** Fields

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into =str= which begins the span.
  - last  :  Index into =str= which ends the span.

In principle, we want the Node to be localized. We could include a 
reference to the whole =str= and derive substrings lazily.

If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 

So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 

This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 


**** line tracking (optional)

It may be wise to always track lines, in which case we will include:

  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends

This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 

- [ ] #todo decide if line tracking is in fact optional


*"]
section_1 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node


  Time to stabilize this class once and for all. 

*** includes

#!lua
local s = require \"status\"
local dot = require \"node/dot\"
#/lua

** Node metatable

  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is =str=. 

#!lua

local N = {}
N.__index = N
N.isNode = true
#/lua



*** Fields

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
   - line_first :  Always -1.
   - line_last  :  Always -1. 

*** Methods

#!lua
function N.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. \"id: \" .. node.id .. \",  \"
      .. \"first: \" .. node.first .. \", last: \" .. node.last .. \"\\n\"
   if node[1] then
    for _,v in ipairs(node) do
      if(v.isNode) then
        phrase = phrase .. N.toString(v, depth + 1)
      end
    end
  end 
   return phrase
end
#/lua

#!lua
function N.dotLabel(node)
  return node.id
end

function N.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function N.dot(node)
  return dot.dot(node)
end

function N.toValue(node)
  return node.str:sub(node.first,node.last)
end

#/lua

**** N.walkDeep

Depth-first iterator. 

#!lua
function N.walkDeep(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end
#/lua

**** N.walk

Breadth-first iterator.  This is the default. 

#!lua
function N.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end

#/lua


**** N.select(node, pred)

  Takes the Node and walks it, yielding the Nodes which match the predicate.
=pred= is either a string, which matches to =id=, or a function, which takes
a Node and returns true or false on some premise. 

#!lua
function N.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' and node.isNode and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

  return coroutine.wrap(function() traverse(node) end)
end
#/lua


**** N.tokens(node)

  Iterator returning all 'captured' values as strings.

#!lua
function N.tokens(node)
  local function traverse(ast)
    for node in N.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  
#/lua  

*"]

}
