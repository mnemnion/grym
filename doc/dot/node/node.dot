digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 79"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-18"]


section_1 -> { header_2 prose_3 section_4 section_5}
{rank=same; header_2 prose_3 section_4 section_5}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 6-8"]

section_5 [label="section: 19-48"]


prose_3 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Time to stabilize this class once and for all. 

"]
section_4 -> { header_7 prose_8 section_9}
{rank=same; header_7 prose_8 section_9}

header_7 [label="2 : Node metatable"]

prose_8 [label="prose"]

section_9 [label="section: 9-18"]


prose_8 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_9 -> { header_11 prose_12}
{rank=same; header_11 prose_12}

header_11 [label="3 : Fields"]

prose_12 [label="prose"]


prose_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
   - line_first :  Always -1.
   - line_last  :  Always -1. 


"]
section_5 -> { header_14 prose_15 section_16 section_17}
{rank=same; header_14 prose_15 section_16 section_17}

header_14 [label="2 : Node Instances"]

prose_15 [label="prose"]

section_16 [label="section: 24-38"]

section_17 [label="section: 49-79"]


prose_15 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, all indexed elements of the Array portion must also be Nodes. 

"]
section_16 -> { header_19 prose_20 prose_21 prose_22 prose_23 section_24}
{rank=same; header_19 prose_20 prose_21 prose_22 prose_23 section_24}

header_19 [label="3 : Fields"]

prose_20 [label="prose"]

prose_21 [label="prose"]

prose_22 [label="prose"]

prose_23 [label="prose"]

section_24 [label="section: 39-48"]


prose_20 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into =str= which begins the span.
  - last  :  Index into =str= which ends the span.
"]
prose_21 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In principle, we want the Node to be localized. We could include a 
reference to the whole =str= and derive substrings lazily.
"]
prose_22 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Instead, we're going to use a constructor pattern. That involves handing the
constructor the substring of the capture, so let's just keept it around:
"]
prose_23 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - span :  The substring captured by the Node. 
"]
section_24 -> { header_29 prose_30 prose_31 prose_32}
{rank=same; header_29 prose_30 prose_31 prose_32}

header_29 [label="4 : line tracking (optional)"]

prose_30 [label="prose"]

prose_31 [label="prose"]

prose_32 [label="prose"]


prose_30 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

It may be wise to always track lines, in which case we will include:
"]
prose_31 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends
"]
prose_32 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 
"]
section_17 -> { header_36 prose_37 prose_38 prose_39 prose_40 prose_41 prose_42 prose_43 prose_44}
{rank=same; header_36 prose_37 prose_38 prose_39 prose_40 prose_41 prose_42 prose_43 prose_44}

header_36 [label="3 : Other fields"]

prose_37 [label="prose"]

prose_38 [label="prose"]

prose_39 [label="prose"]

prose_40 [label="prose"]

prose_41 [label="prose"]

prose_42 [label="prose"]

prose_43 [label="prose"]

prose_44 [label="prose"]


prose_37 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The way the Grammar class will work: each =V\"patt\"= can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 
"]
prose_38 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 
"]
prose_39 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it does, the metatable will have a =__call= method, which expects two
parameters, itself, and the node, which will include the span. 
"]
prose_40 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will require reattunement of basically every class in the =/grym= folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.
"]
prose_41 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 
"]
prose_42 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the meantime we have things like
"]
prose_43 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines :  If this exists, there's a collection of lines which need to be
           joined with =\\n= to reconstruct the actual span.
"]
prose_44 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           We want to do this the other way, and use the span itself for the
           inner parse. 


"]

}
