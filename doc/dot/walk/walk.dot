digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 95"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-67"]


// END RANK doc_0

section_1 -> { header_2 prose_3 codeblock_4 codeblock_5 codeblock_6 prose_7 codeblock_8 section_9}
{rank=same; header_2 prose_3 codeblock_4 codeblock_5 codeblock_6 prose_7 codeblock_8 section_9}

header_2 [label="1 : Walk module"]

prose_3 [label="prose"]

codeblock_4 [label="code block 6-29"]

codeblock_5 [label="code block 31-36"]

codeblock_6 [label="code block 38-47"]

prose_7 [label="prose"]

codeblock_8 [label="code block 53-66"]

section_9 [label="section: 68-95"]


// END RANK section_1

header_2 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Walk module"]
// END RANK header_2

prose_3 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_3

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Contains common functions for recursively executing over some part of
a codex.
"]
// END RANK raw_11

codeblock_4 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"lib/status\"
local u = require \"lib/util\"
local a = require \"lib/ansi\"
s.chatty = true

local pl_file = require \"pl.file\"
local pl_dir = require \"pl.dir\"
local pl_path = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local makepath = pl_dir.makepath
local extension = pl_path.extension
local dirname = pl_path.dirname
local basename = pl_path.basename
local read = pl_file.read
local write = pl_file.write
local delete = pl_file.delete
local isdir = pl_path.isdir

local epeg = require \"epeg\""]
// END RANK codeblock_4

codeblock_5 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local W = {}
W.Path = require \"walk/path\"
W.Dir  = require \"walk/directory\"
W.File = require \"walk/file\""]
// END RANK codeblock_5

codeblock_6 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function W.strHas(substr, str)
    return L.match(epeg.anyP(substr), str)
end

function W.endsWith(substr, str)
    return L.match(L.P(string.reverse(substr)),
        string.reverse(str))
end"]
// END RANK codeblock_6

prose_7 -> { raw_16 prespace_17 literal_18 raw_19}
{rank=same; raw_16 prespace_17 literal_18 raw_19}

raw_16 [label="raw"]

prespace_17 [label="prespace"]

literal_18 [label="literal"]

raw_19 [label="raw"]


// END RANK prose_7

raw_16 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Finds the last match for a literal substring and replaces it
with"]
// END RANK raw_16

prespace_17 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_17

literal_18 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="swap"]
// END RANK literal_18

raw_19 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", returning the new string.
"]
// END RANK raw_19

codeblock_8 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function W.subLastFor(match, swap, str)
    local trs, hctam = string.reverse(str), string.reverse(match)
    local first, last = W.strHas(hctam, trs)
    if last then
        -- There is some way to do this without reversing the string twice,
        -- but I can't be arsed to find it. ONE BASED INDEXES ARE A MISTAKE
        return string.reverse(trs:sub(1, first - 1)
            .. string.reverse(swap) .. trs:sub(last, -1))
    else
        s:halt(\"didn't find an instance of \" .. match .. \" in string: \" .. str)
    end
end"]
// END RANK codeblock_8

section_9 -> { header_25 prose_26 codeblock_27 codeblock_28}
{rank=same; header_25 prose_26 codeblock_27 codeblock_28}

header_25 [label="3 : Update on change"]

prose_26 [label="prose"]

codeblock_27 [label="code block 70-88"]

codeblock_28 [label="code block 92-94"]


// END RANK section_9

header_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Update on change
"]
// END RANK header_25

prose_26 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


// END RANK prose_26

raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_30

codeblock_27 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function W.writeOnChange(newest, current, out_file, depth)
    -- If the text has changed, write it
    if newest ~= current then
        s:chat(a.green((\"  \"):rep(depth) .. \"  - \" .. out_file))
        write(out_file, newest)
        return true
    -- If the new text is blank, delete the old file
    elseif current ~= \"\" and newest == \"\" then
        s:chat(a.red((\"  \"):rep(depth) .. \"  - \" .. out_file))
        delete(out_file)
        return false
    else
    -- Otherwise do nothing

        return nil
    end
end"]
// END RANK codeblock_27

codeblock_28 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return W"]
// END RANK codeblock_28


}
