digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 91"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-64"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 block_8 section_9}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 block_8 section_9}

header_2 [label="1 : Walk module"]

block_3 [label="block 1-5"]

block_4 [label="block 6-30"]

block_5 [label="block 31-34"]

block_6 [label="block 35-46"]

block_7 [label="block 47-49"]

block_8 [label="block 50-64"]

section_9 [label="section: 65-91"]


block_3 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Contains common functions for recursively executing over some part of
a codex.  
"]
block_4 -> { codeblock_11}
{rank=same; codeblock_11}

codeblock_11 [label="code block 6-29"]


codeblock_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"lib/status\"
local u = require \"lib/util\"
local a = require \"lib/ansi\"
s.chatty = true

local pl_file = require \"pl.file\"
local pl_dir = require \"pl.dir\"
local pl_path = require \"pl.path\"
local getfiles = pl_dir.getfiles
local getdirectories = pl_dir.getdirectories
local makepath = pl_dir.makepath
local extension = pl_path.extension
local dirname = pl_path.dirname
local basename = pl_path.basename
local read = pl_file.read
local write = pl_file.write
local delete = pl_file.delete
local isdir = pl_path.isdir

local epeg = require \"peg/epeg\""]
block_4 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_5 -> { codeblock_14}
{rank=same; codeblock_14}

codeblock_14 [label="code block 31-33"]


codeblock_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local W = {}"]
block_5 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_6 -> { codeblock_17}
{rank=same; codeblock_17}

codeblock_17 [label="code block 35-44"]


codeblock_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function W.strHas(substr, str)
    return L.match(epeg.anyP(substr), str)
end

function W.endsWith(substr, str)
    return L.match(L.P(string.reverse(substr)),
        string.reverse(str))
end"]
block_6 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_7 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Finds the last match for a literal substring and replaces it
with =swap=, returning the new string.
"]
block_8 -> { codeblock_21}
{rank=same; codeblock_21}

codeblock_21 [label="code block 50-63"]


codeblock_21 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function W.subLastFor(match, swap, str)
    local trs, hctam = string.reverse(str), string.reverse(match)
    local first, last = W.strHas(hctam, trs)
    if last then
        -- There is some way to do this without reversing the string twice,
        -- but I can't be arsed to find it. ONE BASED INDEXES ARE A MISTAKE
        return string.reverse(trs:sub(1, first - 1) 
            .. string.reverse(swap) .. trs:sub(last, -1))
    else
        s:halt(\"didn't find an instance of \" .. match .. \" in string: \" .. str)
    end 
end"]
block_8 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_9 -> { header_24 block_25 block_26 block_27}
{rank=same; header_24 block_25 block_26 block_27}

header_24 [label="3 : Update on change"]

block_25 [label="block 65-66"]

block_26 [label="block 67-88"]

block_27 [label="block 89-91"]


block_25 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_26 -> { codeblock_29}
{rank=same; codeblock_29}

codeblock_29 [label="code block 67-85"]


codeblock_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function W.writeOnChange(newest, current, out_file, depth)
    -- If the text has changed, write it
    if newest ~= current then
        s:chat(a.green((\"  \"):rep(depth) .. \"  - \" .. out_file))
        write(out_file, newest)
        return true
    -- If the new text is blank, delete the old file
    elseif current ~= \"\" and newest == \"\" then
        s:chat(a.red((\"  \"):rep(depth) .. \"  - \" .. out_file))
        delete(out_file)
        return false
    else
    -- Otherwise do nothing
        s:verb((\"  \"):rep(depth) .. \"  - \" .. out_file)
        return nil
    end
end"]
block_26 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
block_27 -> { codeblock_32}
{rank=same; codeblock_32}

codeblock_32 [label="code block 89-91"]


codeblock_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return W"]
block_27 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

}
