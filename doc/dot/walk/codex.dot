digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 130"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-22"]


// END RANK doc_0

section_1 -> { header_2 prose_3 codeblock_4 codeblock_5 section_6}
{rank=same; header_2 prose_3 codeblock_4 codeblock_5 section_6}

header_2 [label="1 : Codex"]

prose_3 [label="prose"]

codeblock_4 [label="code block 6-13"]

codeblock_5 [label="code block 16-20"]

section_6 [label="section: 23-44"]


// END RANK section_1

header_2 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Codex"]
// END RANK header_2

prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


// END RANK prose_3

raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Now that we have some abstractions over the parts of a Codex,
let's write a class that's singlehandedly responsible for them.
"]
// END RANK raw_8

codeblock_4 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"core/status\" ()
s.verbose = true
local Dir  = require \"walk/directory\"
local File = require \"walk/file\"
local Path = require \"walk/path\"
local Deck = require \"walk/deck\""]
// END RANK codeblock_4

codeblock_5 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Codex = {}
Codex.__index = Codex
local __Codices = {} -- One codex per directory"]
// END RANK codeblock_5

section_6 -> { header_12 prose_13 prose_14 prose_15 codeblock_16 section_17}
{rank=same; header_12 prose_13 prose_14 prose_15 codeblock_16 section_17}

header_12 [label="2 : Codex.caseOrb(codex)"]

prose_13 [label="prose"]

prose_14 [label="prose"]

prose_15 [label="prose"]

codeblock_16 [label="code block 35-42"]

section_17 [label="section: 45-130"]


// END RANK section_6

header_12 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Codex.caseOrb(codex)"]
// END RANK header_12

prose_13 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


// END RANK prose_13

raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This loads information about an Orb directory, including all of its
subdirectories, into the Codex.
"]
// END RANK raw_19

prose_14 -> { raw_21 prespace_22 bold_23 raw_24}
{rank=same; raw_21 prespace_22 bold_23 raw_24}

raw_21 [label="raw"]

prespace_22 [label="prespace"]

bold_23 [label="bold"]

raw_24 [label="raw"]


// END RANK prose_14

raw_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It does"]
// END RANK raw_21

prespace_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_22

bold_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="not"]
// END RANK bold_23

raw_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" read the Orb files, which is done lazily, it makes Files
from them and organizes them for later operations.
"]
// END RANK raw_24

prose_15 -> { raw_29}
{rank=same; raw_29}

raw_29 [label="raw"]


// END RANK prose_15

raw_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's not even clear that this should be a method, might be better as
a local function or just part of the constructor.

"]
// END RANK raw_29

codeblock_16 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Codex.caseOrb(codex)
   local orb = codex.orbDir
   assert(orb.idEst == Dir, \"orb directory not a directory\")
   local orbDeck = Deck(codex, orb)
   return codex
end"]
// END RANK codeblock_16

section_17 -> { header_32 prose_33 prose_34 codeblock_35 codeblock_36 codeblock_37}
{rank=same; header_32 prose_33 prose_34 codeblock_35 codeblock_36 codeblock_37}

header_32 [label="3 : isACodex"]

prose_33 [label="prose"]

prose_34 [label="prose"]

codeblock_35 [label="code block 53-90"]

codeblock_36 [label="code block 92-107"]

codeblock_37 [label="code block 110-113"]


// END RANK section_17

header_32 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** isACodex"]
// END RANK header_32

prose_33 -> { raw_39 link_40 raw_41 prespace_42 literal_43 raw_44 prespace_45 literal_46 raw_47}
{rank=same; raw_39 link_40 raw_41 prespace_42 literal_43 raw_44 prespace_45 literal_46 raw_47}

raw_39 [label="raw"]

link_40 [label="link"]

raw_41 [label="raw"]

prespace_42 [label="prespace"]

literal_43 [label="literal"]

raw_44 [label="raw"]

prespace_45 [label="prespace"]

literal_46 [label="literal"]

raw_47 [label="raw"]


// END RANK prose_33

raw_39 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Used in our constructor to determine to what degree the local
directory fits the Codex format.  If it meets all the "]
// END RANK raw_39

link_40 -> { anchortext_49 url_50}
{rank=same; anchortext_49 url_50}

anchortext_49 [label="anchortext"]

url_50 [label="url"]


// END RANK link_40

anchortext_49 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="critera"]
// END RANK anchortext_49

url_50 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_50

raw_41 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
then"]
// END RANK raw_41

prespace_42 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_42

literal_43 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="codex.codex"]
// END RANK literal_43

raw_44 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is set to"]
// END RANK raw_44

prespace_45 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_45

literal_46 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
// END RANK literal_46

raw_47 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_47

prose_34 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


// END RANK prose_34

raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Any partial matches are added to the Codex as they are found.
"]
// END RANK raw_60

codeblock_35 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function isACodex(dir, codex)
   local isCo = false
   local orbDir, srcDir, libDir, srcLibDir = nil, nil, nil, nil
   codex.root = dir
   dir:getsubdirs()
   for i, sub in ipairs(dir.subdirs) do
      local name = sub:basename()
      if name == \"orb\" then
         s:verb(\"orb: \" .. tostring(sub))
         orbDir = sub
         codex.orb = sub
      elseif name == \"src\" then
         s:verb(\"src: \" .. tostring(sub))
         srcDir = Dir(sub)
         codex.src = sub
         srcDir:getsubdirs()
         for j, subsub in ipairs(sub.subdirs) do
            local subname = subsub:basename()
            if subname == \"lib\" then
               s:verb(\"src/lib: \" .. tostring(subsub))
               subLibDir = subsub
            end
         end
          --]]
      elseif name == \"lib\" then
         s:verb(\"lib: \" .. tostring(sub))
         libDir = sub
         codex.lib = sub
      end
   end
   if orbDir and srcDir and libDir and subLibDir then
      -- check equality of /lib and /src/lib
      codex.codex = true
   end
   return codex
end"]
// END RANK codeblock_35

codeblock_36 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(dir)
   if type(dir) == \"string\" then
      dir = Dir(dir)
   end
   if __Codices[dir] then
      return __Codices[dir]
   end
   local codex = setmetatable({}, Codex)
   codex = isACodex(dir, codex)
   if codex.orb then
      local orbDeck = Deck(codex, codex.orb)
   end
   return codex
end"]
// END RANK codeblock_36

codeblock_37 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Codex.idEst = new
return new"]
// END RANK codeblock_37


}
