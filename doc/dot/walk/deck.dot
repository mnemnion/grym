digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 181"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-98"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6 section_7}
{rank=same; header_2 prose_3 prose_4 section_5 section_6 section_7}

header_2 [label="1 : Deck"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 10-64"]

section_6 [label="section: 65-98"]

section_7 [label="section: 99-150"]


// END RANK section_1

header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Deck"]
// END RANK header_2

prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_3

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


A Deck is the bridge-level abstraction of a directory.
"]
// END RANK raw_9

prose_4 -> { raw_11 prespace_12 literal_13 raw_14}
{rank=same; raw_11 prespace_12 literal_13 raw_14}

raw_11 [label="raw"]

prespace_12 [label="prespace"]

literal_13 [label="literal"]

raw_14 [label="raw"]


// END RANK prose_4

raw_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
From the"]
// END RANK raw_11

prespace_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_12

literal_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="orb"]
// END RANK literal_13

raw_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" perspective, this is specialized on orb files and
directories. I'll then adapt it for weaving and sorcery, once those
become more sophisticated than raw string concatenation.
"]
// END RANK raw_14

section_5 -> { header_19 prose_20 prose_21 prose_22 prose_23 prose_24 prose_25 prose_26 codeblock_27 codeblock_28 codeblock_29}
{rank=same; header_19 prose_20 prose_21 prose_22 prose_23 prose_24 prose_25 prose_26 codeblock_27 codeblock_28 codeblock_29}

header_19 [label="2 : Instance fields."]

prose_20 [label="prose"]

prose_21 [label="prose"]

prose_22 [label="prose"]

prose_23 [label="prose"]

prose_24 [label="prose"]

prose_25 [label="prose"]

prose_26 [label="prose"]

codeblock_27 [label="code block 31-42"]

codeblock_28 [label="code block 44-48"]

codeblock_29 [label="code block 50-62"]


// END RANK section_5

header_19 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Instance fields."]
// END RANK header_19

prose_20 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


// END RANK prose_20

raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

I want to design this interace deliberately so that it supports what I'm
doing rather than getting in the way.
"]
// END RANK raw_31

prose_21 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


// END RANK prose_21

raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Decks have sub decks, if any, in the array portion of their table.
"]
// END RANK raw_33

prose_22 -> { raw_35 prespace_36 literal_37 raw_38}
{rank=same; raw_35 prespace_36 literal_37 raw_38}

raw_35 [label="raw"]

prespace_36 [label="prespace"]

literal_37 [label="literal"]

raw_38 [label="raw"]


// END RANK prose_22

raw_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Files are kept in the"]
// END RANK raw_35

prespace_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_36

literal_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.dir"]
// END RANK literal_37

raw_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" object, where they belong.
"]
// END RANK raw_38

prose_23 -> { raw_43 prespace_44 literal_45 raw_46}
{rank=same; raw_43 prespace_44 literal_45 raw_46}

raw_43 [label="raw"]

prespace_44 [label="prespace"]

literal_45 [label="literal"]

raw_46 [label="raw"]


// END RANK prose_23

raw_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A deck has a pointer to its codex at"]
// END RANK raw_43

prespace_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_44

literal_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.codex"]
// END RANK literal_45

raw_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", and must be created
by one.
"]
// END RANK raw_46

prose_24 -> { raw_51 prespace_52 literal_53 raw_54}
{rank=same; raw_51 prespace_52 literal_53 raw_54}

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_24

raw_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Docs go into the"]
// END RANK raw_51

prespace_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_52

literal_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="docs"]
// END RANK literal_53

raw_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" map. Currently both in the codex and the
particular deck, keyed by full path name.
"]
// END RANK raw_54

prose_25 -> { raw_59 prespace_60 literal_61 raw_62}
{rank=same; raw_59 prespace_60 literal_61 raw_62}

raw_59 [label="raw"]

prespace_60 [label="prespace"]

literal_61 [label="literal"]

raw_62 [label="raw"]


// END RANK prose_25

raw_59 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Sorcery goes into the"]
// END RANK raw_59

prespace_60 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_60

literal_61 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="srcs"]
// END RANK literal_61

raw_62 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" map following the same logic.
"]
// END RANK raw_62

prose_26 -> { raw_67 prespace_68 literal_69 raw_70 prespace_71 literal_72 raw_73 prespace_74 literal_75 raw_76 prespace_77 literal_78 raw_79}
{rank=same; raw_67 prespace_68 literal_69 raw_70 prespace_71 literal_72 raw_73 prespace_74 literal_75 raw_76 prespace_77 literal_78 raw_79}

raw_67 [label="raw"]

prespace_68 [label="prespace"]

literal_69 [label="literal"]

raw_70 [label="raw"]

prespace_71 [label="prespace"]

literal_72 [label="literal"]

raw_73 [label="raw"]

prespace_74 [label="prespace"]

literal_75 [label="literal"]

raw_76 [label="raw"]

prespace_77 [label="prespace"]

literal_78 [label="literal"]

raw_79 [label="raw"]


// END RANK prose_26

raw_67 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A Doc which has"]
// END RANK raw_67

prespace_68 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_68

literal_69 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="{basename}.org"]
// END RANK literal_69

raw_70 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", that is, the basename of the deck,
will be added to"]
// END RANK raw_70

prespace_71 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_71

literal_72 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.eponym"]
// END RANK literal_72

raw_73 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  If there is a"]
// END RANK raw_73

prespace_74 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_74

literal_75 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".deck"]
// END RANK literal_75

raw_76 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" file in the
directory, this becomes"]
// END RANK raw_76

prespace_77 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_77

literal_78 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="dec.dotDeck"]
// END RANK literal_78

raw_79 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_79

codeblock_27 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s   = require \"status\" ()
s.verbose = false
s.chatty  = true

local c   = require \"core/color\"
local cAlert = c.color.alert

local Dir = require \"walk/directory\"
local Doc = require \"Orbit/doc\"
local Node = require \"Node\""]
// END RANK codeblock_27

codeblock_28 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Deck = {}
Deck.__index = Deck
local __Decks = {}"]
// END RANK codeblock_28

codeblock_29 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- ignore a few critters that can show up
local decIgnore = {\".DS_Store\", \".git\"}

local function ignore(file)
   local willIgnore = false
   local basename = file:basename()
   for _, str in ipairs(decIgnore) do
      willIgnore = willIgnore or basename == str
   end
   return willIgnore
end"]
// END RANK codeblock_29

section_6 -> { header_96 prose_97 prose_98 codeblock_99}
{rank=same; header_96 prose_97 prose_98 codeblock_99}

header_96 [label="2 : spin(deck)"]

prose_97 [label="prose"]

prose_98 [label="prose"]

codeblock_99 [label="code block 71-96"]


// END RANK section_6

header_96 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** spin(deck)"]
// END RANK header_96

prose_97 -> { raw_101}
{rank=same; raw_101}

raw_101 [label="raw"]


// END RANK prose_97

raw_101 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If we're going to be lazy, this is where we should do it!
"]
// END RANK raw_101

prose_98 -> { raw_103}
{rank=same; raw_103}

raw_103 [label="raw"]


// END RANK prose_98

raw_103 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Right now, we're going to load all Docs into memory, willy nilly.
"]
// END RANK raw_103

codeblock_99 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function spin(deck)
   local err = {}
   local dir = deck.dir
   local codex = deck.codex
   for _, subdeck in ipairs(deck) do
      spin(subdeck)
   end
   local files = dir:getfiles()
   for _, file in ipairs(files) do
      if not ignore(file) then
         local doc = Doc(file:read())
         if doc.id and doc.id == \"doc\" then
            deck.docs[file.path.str] = doc
            codex.docs[file.path.str] = doc
         else
            s:complain(\"no doc\",
                       tostring(file) .. \" doesn't generate a doc\")
         end
      end
   end
   return deck, err
end

Deck.spin = spin"]
// END RANK codeblock_99

section_7 -> { header_106 prose_107 prose_108 prose_109 codeblock_110 section_111}
{rank=same; header_106 prose_107 prose_108 prose_109 codeblock_110 section_111}

header_106 [label="2 : case(deck)"]

prose_107 [label="prose"]

prose_108 [label="prose"]

prose_109 [label="prose"]

codeblock_110 [label="code block 111-149"]

section_111 [label="section: 151-181"]


// END RANK section_7

header_106 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** case(deck)"]
// END RANK header_106

prose_107 -> { raw_113 prespace_114 literal_115 raw_116 prespace_117 literal_118 raw_119 prespace_120 literal_121 raw_122}
{rank=same; raw_113 prespace_114 literal_115 raw_116 prespace_117 literal_118 raw_119 prespace_120 literal_121 raw_122}

raw_113 [label="raw"]

prespace_114 [label="prespace"]

literal_115 [label="literal"]

raw_116 [label="raw"]

prespace_117 [label="prespace"]

literal_118 [label="literal"]

raw_119 [label="raw"]

prespace_120 [label="prespace"]

literal_121 [label="literal"]

raw_122 [label="raw"]


// END RANK prose_107

raw_113 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Casing is what we call gathering information about a deck, its subdecks,
and associated files. "]
// END RANK raw_113

prespace_114 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_114

literal_115 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="case"]
// END RANK literal_115

raw_116 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will also pull the"]
// END RANK raw_116

prespace_117 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_117

literal_118 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".deck"]
// END RANK literal_118

raw_119 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" file into memory,
parse it into a Doc, and attach that at"]
// END RANK raw_119

prespace_120 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_120

literal_121 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.dotDeck"]
// END RANK literal_121

raw_122 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_122

prose_108 -> { raw_133}
{rank=same; raw_133}

raw_133 [label="raw"]


// END RANK prose_108

raw_133 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Casing a deck will cause its subdecks to be cased also, recursively. This is
where we will add inode comparison to keep from following cyclic references,
since it's what draws directory attributes out of the filesystem into memory.
"]
// END RANK raw_133

prose_109 -> { raw_135 link_136 raw_137}
{rank=same; raw_135 link_136 raw_137}

raw_135 [label="raw"]

link_136 [label="link"]

raw_137 [label="raw"]


// END RANK prose_109

raw_135 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
After casing a Deck is ready to be "]
// END RANK raw_135

link_136 -> { anchortext_139 url_140}
{rank=same; anchortext_139 url_140}

anchortext_139 [label="anchortext"]

url_140 [label="url"]


// END RANK link_136

anchortext_139 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spun"]
// END RANK anchortext_139

url_140 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_140

raw_137 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_137

codeblock_110 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new

function Deck.case(deck)
   s:verb(\"dir: \" .. tostring(deck.dir))
   local dir = deck.dir
   local codex = deck.codex
   local basename = dir:basename()
   assert(dir.idEst == Dir, \"dir not a directory\")
   local codexRoot = codex.root:basename()
   s:verb(\"root: \" .. tostring(codex.root) .. \" base: \" ..tostring(codexRoot))
   local subdirs = dir:getsubdirs()
   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)
   for i, sub in ipairs(subdirs) do
      s:verb(\"  - \" .. sub.path.str)
      deck[i] = new(codex, sub)
   end
   local files = dir:getfiles()
   s:verb(\"  \" .. \"# files: \" .. #files)
   for i, file in ipairs(files) do
      if not ignore(file) then
         local name = file:basename()
         if name == \".deck\" then
            s:ver()
            deck.dotDeck = file
         elseif #file:extension() > 1 then
            name = string.sub(name, 1, - #file:extension() - 1)
         end
         if name == basename then
            s:verb(\"  ~ \" .. name)
            deck.eponym = file
         end
      end
   end

   s:verb(\"#deck is : \" .. #deck)
   return codex
end"]
// END RANK codeblock_110

section_111 -> { header_145 prose_146 codeblock_147 codeblock_148 codeblock_149}
{rank=same; header_145 prose_146 codeblock_147 codeblock_148 codeblock_149}

header_145 [label="3 : __tostring"]

prose_146 [label="prose"]

codeblock_147 [label="code block 153-157"]

codeblock_148 [label="code block 159-175"]

codeblock_149 [label="code block 178-181"]


// END RANK section_111

header_145 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** __tostring"]
// END RANK header_145

prose_146 -> { raw_151}
{rank=same; raw_151}

raw_151 [label="raw"]


// END RANK prose_146

raw_151 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_151

codeblock_147 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Deck.__tostring(deck)
   return deck.dir.path.str
end"]
// END RANK codeblock_147

codeblock_148 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="new = function (codex, dir)
   if type(dir) == \"string\" then
      dir = Dir(dir)
   end
   if __Decks[dir] then
      return __Decks[dir]
   end
   local deck = setmetatable({}, Deck)
   deck.dir = dir
   deck.codex = codex
   deck.docs  = {}
   deck.srcs  = {}
   Deck.case(deck)
   return deck
end"]
// END RANK codeblock_148

codeblock_149 -> leaf_155
leaf_155  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Deck.idEst = new
return new"]
// END RANK codeblock_149


}
