digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 172"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-90"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6 section_7}
{rank=same; header_2 prose_3 prose_4 section_5 section_6 section_7}

header_2 [label="1 : Deck"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 10-61"]

section_6 [label="section: 62-90"]

section_7 [label="section: 91-142"]


// END RANK section_1

header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Deck"]
// END RANK header_2

prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_3

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


A Deck is the bridge-level abstraction of a directory.
"]
// END RANK raw_9

prose_4 -> { raw_11 prespace_12 literal_13 raw_14}
{rank=same; raw_11 prespace_12 literal_13 raw_14}

raw_11 [label="raw"]

prespace_12 [label="prespace"]

literal_13 [label="literal"]

raw_14 [label="raw"]


// END RANK prose_4

raw_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
From the"]
// END RANK raw_11

prespace_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_12

literal_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="orb"]
// END RANK literal_13

raw_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" perspective, this is specialized on orb files and
directories. I'll then adapt it for weaving and sorcery, once those
become more sophisticated than raw string concatenation.
"]
// END RANK raw_14

section_5 -> { header_19 prose_20 prose_21 prose_22 prose_23 prose_24 prose_25 codeblock_26 codeblock_27 codeblock_28}
{rank=same; header_19 prose_20 prose_21 prose_22 prose_23 prose_24 prose_25 codeblock_26 codeblock_27 codeblock_28}

header_19 [label="2 : Instance fields."]

prose_20 [label="prose"]

prose_21 [label="prose"]

prose_22 [label="prose"]

prose_23 [label="prose"]

prose_24 [label="prose"]

prose_25 [label="prose"]

codeblock_26 [label="code block 29-39"]

codeblock_27 [label="code block 41-45"]

codeblock_28 [label="code block 47-59"]


// END RANK section_5

header_19 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Instance fields."]
// END RANK header_19

prose_20 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


// END RANK prose_20

raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

I want to design this interace deliberately so that it supports what I'm
doing rather than getting in the way.
"]
// END RANK raw_30

prose_21 -> { raw_32}
{rank=same; raw_32}

raw_32 [label="raw"]


// END RANK prose_21

raw_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Decks have sub decks, if any, in the array portion of their table.
"]
// END RANK raw_32

prose_22 -> { raw_34 prespace_35 literal_36 raw_37}
{rank=same; raw_34 prespace_35 literal_36 raw_37}

raw_34 [label="raw"]

prespace_35 [label="prespace"]

literal_36 [label="literal"]

raw_37 [label="raw"]


// END RANK prose_22

raw_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Files are kept in the"]
// END RANK raw_34

prespace_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_35

literal_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.dir"]
// END RANK literal_36

raw_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" object, where they belong.
"]
// END RANK raw_37

prose_23 -> { raw_42 prespace_43 literal_44 raw_45}
{rank=same; raw_42 prespace_43 literal_44 raw_45}

raw_42 [label="raw"]

prespace_43 [label="prespace"]

literal_44 [label="literal"]

raw_45 [label="raw"]


// END RANK prose_23

raw_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A deck has a pointer to its codex at"]
// END RANK raw_42

prespace_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_43

literal_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.codex"]
// END RANK literal_44

raw_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", and must be created
by one.
"]
// END RANK raw_45

prose_24 -> { raw_50 prespace_51 literal_52 raw_53}
{rank=same; raw_50 prespace_51 literal_52 raw_53}

raw_50 [label="raw"]

prespace_51 [label="prespace"]

literal_52 [label="literal"]

raw_53 [label="raw"]


// END RANK prose_24

raw_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Docs go into the"]
// END RANK raw_50

prespace_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_51

literal_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="docs"]
// END RANK literal_52

raw_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" array, index in alphabetical order of base name,
and are keyed into a subtable (name tbd) by full string file path.
"]
// END RANK raw_53

prose_25 -> { raw_58 prespace_59 literal_60 raw_61 prespace_62 literal_63 raw_64 prespace_65 literal_66 raw_67 prespace_68 literal_69 raw_70}
{rank=same; raw_58 prespace_59 literal_60 raw_61 prespace_62 literal_63 raw_64 prespace_65 literal_66 raw_67 prespace_68 literal_69 raw_70}

raw_58 [label="raw"]

prespace_59 [label="prespace"]

literal_60 [label="literal"]

raw_61 [label="raw"]

prespace_62 [label="prespace"]

literal_63 [label="literal"]

raw_64 [label="raw"]

prespace_65 [label="prespace"]

literal_66 [label="literal"]

raw_67 [label="raw"]

prespace_68 [label="prespace"]

literal_69 [label="literal"]

raw_70 [label="raw"]


// END RANK prose_25

raw_58 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A Doc which has"]
// END RANK raw_58

prespace_59 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_59

literal_60 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="{basename}.org"]
// END RANK literal_60

raw_61 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", that is, the basename of the deck,
will be added to"]
// END RANK raw_61

prespace_62 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_62

literal_63 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.eponym"]
// END RANK literal_63

raw_64 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  If there is a"]
// END RANK raw_64

prespace_65 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_65

literal_66 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".deck"]
// END RANK literal_66

raw_67 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" file in the
directory, this becomes"]
// END RANK raw_67

prespace_68 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_68

literal_69 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="dec.dotDeck"]
// END RANK literal_69

raw_70 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_70

codeblock_26 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s   = require \"status\" ()
s.verbose = false
s.chatty  = true

local c   = require \"core/color\"
local cAlert = c.color.alert

local Dir = require \"walk/directory\"
local Doc = require \"Orbit/doc\""]
// END RANK codeblock_26

codeblock_27 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Deck = {}
Deck.__index = Deck
local __Decks = {}"]
// END RANK codeblock_27

codeblock_28 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- ignore a few critters that can show up
local decIgnore = {\".DS_Store\", \".git\"}

local function ignore(file)
   local willIgnore = false
   local basename = file:basename()
   for _, str in ipairs(decIgnore) do
      willIgnore = willIgnore or basename == str
   end
   return willIgnore
end"]
// END RANK codeblock_28

section_6 -> { header_87 prose_88 prose_89 codeblock_90}
{rank=same; header_87 prose_88 prose_89 codeblock_90}

header_87 [label="2 : spin(deck)"]

prose_88 [label="prose"]

prose_89 [label="prose"]

codeblock_90 [label="code block 68-88"]


// END RANK section_6

header_87 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** spin(deck)"]
// END RANK header_87

prose_88 -> { raw_92}
{rank=same; raw_92}

raw_92 [label="raw"]


// END RANK prose_88

raw_92 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If we're going to be lazy, this is where we should do it!
"]
// END RANK raw_92

prose_89 -> { raw_94}
{rank=same; raw_94}

raw_94 [label="raw"]


// END RANK prose_89

raw_94 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Right now, we're going to load all Docs into memory, willy nilly.
"]
// END RANK raw_94

codeblock_90 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function spin(deck)
   local err = {}
   local dir = deck.dir
   local codex = deck.codex
   for _, subdeck in ipairs(deck) do
      spin(subdeck)
   end
   local files = dir:getfiles()
   for _, file in ipairs(files) do
      if not ignore(file) then
         local doc = Doc(file:read())
         deck.docs[#deck.docs + 1] = doc
         codex.docs[file.path.str] = doc
      end
   end
   return deck, err
end

Deck.spin = spin"]
// END RANK codeblock_90

section_7 -> { header_97 prose_98 prose_99 prose_100 codeblock_101 section_102}
{rank=same; header_97 prose_98 prose_99 prose_100 codeblock_101 section_102}

header_97 [label="2 : case(deck)"]

prose_98 [label="prose"]

prose_99 [label="prose"]

prose_100 [label="prose"]

codeblock_101 [label="code block 103-141"]

section_102 [label="section: 143-172"]


// END RANK section_7

header_97 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** case(deck)"]
// END RANK header_97

prose_98 -> { raw_104 prespace_105 literal_106 raw_107 prespace_108 literal_109 raw_110 prespace_111 literal_112 raw_113}
{rank=same; raw_104 prespace_105 literal_106 raw_107 prespace_108 literal_109 raw_110 prespace_111 literal_112 raw_113}

raw_104 [label="raw"]

prespace_105 [label="prespace"]

literal_106 [label="literal"]

raw_107 [label="raw"]

prespace_108 [label="prespace"]

literal_109 [label="literal"]

raw_110 [label="raw"]

prespace_111 [label="prespace"]

literal_112 [label="literal"]

raw_113 [label="raw"]


// END RANK prose_98

raw_104 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Casing is what we call gathering information about a deck, its subdecks,
and associated files. "]
// END RANK raw_104

prespace_105 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_105

literal_106 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="case"]
// END RANK literal_106

raw_107 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will also pull the"]
// END RANK raw_107

prespace_108 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_108

literal_109 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".deck"]
// END RANK literal_109

raw_110 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" file into memory,
parse it into a Doc, and attach that at"]
// END RANK raw_110

prespace_111 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_111

literal_112 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.dotDeck"]
// END RANK literal_112

raw_113 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_113

prose_99 -> { raw_124}
{rank=same; raw_124}

raw_124 [label="raw"]


// END RANK prose_99

raw_124 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Casing a deck will cause its subdecks to be cased also, recursively. This is
where we will add inode comparison to keep from following cyclic references,
since it's what draws directory attributes out of the filesystem into memory.
"]
// END RANK raw_124

prose_100 -> { raw_126 link_127 raw_128}
{rank=same; raw_126 link_127 raw_128}

raw_126 [label="raw"]

link_127 [label="link"]

raw_128 [label="raw"]


// END RANK prose_100

raw_126 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
After casing a Deck is ready to be "]
// END RANK raw_126

link_127 -> { anchortext_130 url_131}
{rank=same; anchortext_130 url_131}

anchortext_130 [label="anchortext"]

url_131 [label="url"]


// END RANK link_127

anchortext_130 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spun"]
// END RANK anchortext_130

url_131 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_131

raw_128 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_128

codeblock_101 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new

function Deck.case(deck)
   s:verb(\"dir: \" .. tostring(deck.dir))
   local dir = deck.dir
   local codex = deck.codex
   local basename = dir:basename()
   assert(dir.idEst == Dir, \"dir not a directory\")
   local codexRoot = codex.root:basename()
   s:verb(\"root: \" .. tostring(codex.root) .. \" base: \" ..tostring(codexRoot))
   local subdirs = dir:getsubdirs()
   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)
   for i, sub in ipairs(subdirs) do
      s:verb(\"  - \" .. sub.path.str)
      deck[i] = new(codex, sub)
   end
   local files = dir:getfiles()
   s:verb(\"  \" .. \"# files: \" .. #files)
   for i, file in ipairs(files) do
      if not ignore(file) then
         local name = file:basename()
         if name == \".deck\" then
            s:ver()
            deck.dotDeck = file
         elseif #file:extension() > 1 then
            name = string.sub(name, 1, - #file:extension() - 1)
         end
         if name == basename then
            s:verb(\"  ~ \" .. name)
            deck.eponym = file
         end
      end
   end

   s:verb(\"#deck is : \" .. #deck)
   return codex
end"]
// END RANK codeblock_101

section_102 -> { header_136 prose_137 codeblock_138 codeblock_139 codeblock_140}
{rank=same; header_136 prose_137 codeblock_138 codeblock_139 codeblock_140}

header_136 [label="3 : __tostring"]

prose_137 [label="prose"]

codeblock_138 [label="code block 145-149"]

codeblock_139 [label="code block 151-166"]

codeblock_140 [label="code block 169-172"]


// END RANK section_102

header_136 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** __tostring"]
// END RANK header_136

prose_137 -> { raw_142}
{rank=same; raw_142}

raw_142 [label="raw"]


// END RANK prose_137

raw_142 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_142

codeblock_138 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Deck.__tostring(deck)
   return deck.dir.path.str
end"]
// END RANK codeblock_138

codeblock_139 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="new = function (codex, dir)
   if type(dir) == \"string\" then
      dir = Dir(dir)
   end
   if __Decks[dir] then
      return __Decks[dir]
   end
   local deck = setmetatable({}, Deck)
   deck.dir = dir
   deck.codex = codex
   deck.docs  = {}
   Deck.case(deck)
   return deck
end"]
// END RANK codeblock_139

codeblock_140 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Deck.idEst = new
return new"]
// END RANK codeblock_140


}
