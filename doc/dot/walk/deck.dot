digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 183"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-101"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6 section_7}
{rank=same; header_2 prose_3 prose_4 section_5 section_6 section_7}

header_2 [label="1 : Deck"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 10-65"]

section_6 [label="section: 66-101"]

section_7 [label="section: 102-153"]


// END RANK section_1

header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Deck"]
// END RANK header_2

prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_3

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


A Deck is the bridge-level abstraction of a directory.
"]
// END RANK raw_9

prose_4 -> { raw_11 prespace_12 literal_13 raw_14}
{rank=same; raw_11 prespace_12 literal_13 raw_14}

raw_11 [label="raw"]

prespace_12 [label="prespace"]

literal_13 [label="literal"]

raw_14 [label="raw"]


// END RANK prose_4

raw_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
From the"]
// END RANK raw_11

prespace_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_12

literal_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="orb"]
// END RANK literal_13

raw_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" perspective, this is specialized on orb files and
directories. I'll then adapt it for weaving and sorcery, once those
become more sophisticated than raw string concatenation.
"]
// END RANK raw_14

section_5 -> { header_19 prose_20 prose_21 prose_22 prose_23 prose_24 prose_25 prose_26 codeblock_27 codeblock_28 codeblock_29}
{rank=same; header_19 prose_20 prose_21 prose_22 prose_23 prose_24 prose_25 prose_26 codeblock_27 codeblock_28 codeblock_29}

header_19 [label="2 : Instance fields."]

prose_20 [label="prose"]

prose_21 [label="prose"]

prose_22 [label="prose"]

prose_23 [label="prose"]

prose_24 [label="prose"]

prose_25 [label="prose"]

prose_26 [label="prose"]

codeblock_27 [label="code block 32-43"]

codeblock_28 [label="code block 45-49"]

codeblock_29 [label="code block 51-63"]


// END RANK section_5

header_19 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Instance fields."]
// END RANK header_19

prose_20 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


// END RANK prose_20

raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

I want to design this interace deliberately so that it supports what I'm
doing rather than getting in the way.
"]
// END RANK raw_31

prose_21 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


// END RANK prose_21

raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Decks have sub decks, if any, in the array portion of their table.
"]
// END RANK raw_33

prose_22 -> { raw_35 prespace_36 literal_37 raw_38}
{rank=same; raw_35 prespace_36 literal_37 raw_38}

raw_35 [label="raw"]

prespace_36 [label="prespace"]

literal_37 [label="literal"]

raw_38 [label="raw"]


// END RANK prose_22

raw_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Files are kept in the"]
// END RANK raw_35

prespace_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_36

literal_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.dir"]
// END RANK literal_37

raw_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" object, where they belong.
"]
// END RANK raw_38

prose_23 -> { raw_43 prespace_44 literal_45 raw_46}
{rank=same; raw_43 prespace_44 literal_45 raw_46}

raw_43 [label="raw"]

prespace_44 [label="prespace"]

literal_45 [label="literal"]

raw_46 [label="raw"]


// END RANK prose_23

raw_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A deck has a pointer to its codex at"]
// END RANK raw_43

prespace_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_44

literal_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.codex"]
// END RANK literal_45

raw_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", and must be created
by one.
"]
// END RANK raw_46

prose_24 -> { raw_51 prespace_52 literal_53 raw_54}
{rank=same; raw_51 prespace_52 literal_53 raw_54}

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_24

raw_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Docs go into the"]
// END RANK raw_51

prespace_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_52

literal_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="docs"]
// END RANK literal_53

raw_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" array, index in alphabetical order of base name,
and are keyed into a subtable (name tbd) by full string file path.
"]
// END RANK raw_54

prose_25 -> { raw_59 prespace_60 literal_61 raw_62 prespace_63 literal_64 raw_65 prespace_66 literal_67 raw_68}
{rank=same; raw_59 prespace_60 literal_61 raw_62 prespace_63 literal_64 raw_65 prespace_66 literal_67 raw_68}

raw_59 [label="raw"]

prespace_60 [label="prespace"]

literal_61 [label="literal"]

raw_62 [label="raw"]

prespace_63 [label="prespace"]

literal_64 [label="literal"]

raw_65 [label="raw"]

prespace_66 [label="prespace"]

literal_67 [label="literal"]

raw_68 [label="raw"]


// END RANK prose_25

raw_59 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Sorcery goes into the"]
// END RANK raw_59

prespace_60 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_60

literal_61 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="srcs"]
// END RANK literal_61

raw_62 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" array. "]
// END RANK raw_62

prespace_63 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_63

literal_64 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="src"]
// END RANK literal_64

raw_65 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" decks are currently constructed
by"]
// END RANK raw_65

prespace_66 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_66

literal_67 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="knit"]
// END RANK literal_67

raw_68 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which might be correct.y
"]
// END RANK raw_68

prose_26 -> { raw_79 prespace_80 literal_81 raw_82 prespace_83 literal_84 raw_85 prespace_86 literal_87 raw_88 prespace_89 literal_90 raw_91}
{rank=same; raw_79 prespace_80 literal_81 raw_82 prespace_83 literal_84 raw_85 prespace_86 literal_87 raw_88 prespace_89 literal_90 raw_91}

raw_79 [label="raw"]

prespace_80 [label="prespace"]

literal_81 [label="literal"]

raw_82 [label="raw"]

prespace_83 [label="prespace"]

literal_84 [label="literal"]

raw_85 [label="raw"]

prespace_86 [label="prespace"]

literal_87 [label="literal"]

raw_88 [label="raw"]

prespace_89 [label="prespace"]

literal_90 [label="literal"]

raw_91 [label="raw"]


// END RANK prose_26

raw_79 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A Doc which has"]
// END RANK raw_79

prespace_80 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_80

literal_81 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="{basename}.org"]
// END RANK literal_81

raw_82 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", that is, the basename of the deck,
will be added to"]
// END RANK raw_82

prespace_83 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_83

literal_84 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.eponym"]
// END RANK literal_84

raw_85 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  If there is a"]
// END RANK raw_85

prespace_86 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_86

literal_87 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".deck"]
// END RANK literal_87

raw_88 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" file in the
directory, this becomes"]
// END RANK raw_88

prespace_89 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_89

literal_90 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="dec.dotDeck"]
// END RANK literal_90

raw_91 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_91

codeblock_27 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s   = require \"status\" ()
s.verbose = true
s.chatty  = true

local c   = require \"core/color\"
local cAlert = c.color.alert

local Dir = require \"walk/directory\"
local Doc = require \"Orbit/doc\"
local Node = require \"Node\""]
// END RANK codeblock_27

codeblock_28 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Deck = {}
Deck.__index = Deck
local __Decks = {}"]
// END RANK codeblock_28

codeblock_29 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- ignore a few critters that can show up
local decIgnore = {\".DS_Store\", \".git\"}

local function ignore(file)
   local willIgnore = false
   local basename = file:basename()
   for _, str in ipairs(decIgnore) do
      willIgnore = willIgnore or basename == str
   end
   return willIgnore
end"]
// END RANK codeblock_29

section_6 -> { header_108 prose_109 prose_110 codeblock_111}
{rank=same; header_108 prose_109 prose_110 codeblock_111}

header_108 [label="2 : spin(deck)"]

prose_109 [label="prose"]

prose_110 [label="prose"]

codeblock_111 [label="code block 72-99"]


// END RANK section_6

header_108 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** spin(deck)"]
// END RANK header_108

prose_109 -> { raw_113}
{rank=same; raw_113}

raw_113 [label="raw"]


// END RANK prose_109

raw_113 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If we're going to be lazy, this is where we should do it!
"]
// END RANK raw_113

prose_110 -> { raw_115}
{rank=same; raw_115}

raw_115 [label="raw"]


// END RANK prose_110

raw_115 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Right now, we're going to load all Docs into memory, willy nilly.
"]
// END RANK raw_115

codeblock_111 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function spin(deck)
   local err = {}
   local dir = deck.dir
   local codex = deck.codex
   for _, subdeck in ipairs(deck) do
      spin(subdeck)
   end
   local files = dir:getfiles()
   for _, file in ipairs(files) do
      if not ignore(file) then
         local doc = Doc(file:read())
         if doc.id and doc.id == \"doc\" then
            s:chat(\"made a Doc from \" .. tostring(file)
                   .. \"  #\" .. #deck.docs + 1)
            deck.docs[#deck.docs + 1] = doc
            codex.docs[file.path.str] = doc
         else
            s:complain(\"no doc\",
                       tostring(file) .. \" doesn't generate a doc\")
         end
      end
   end
   return deck, err
end

Deck.spin = spin"]
// END RANK codeblock_111

section_7 -> { header_118 prose_119 prose_120 prose_121 codeblock_122 section_123}
{rank=same; header_118 prose_119 prose_120 prose_121 codeblock_122 section_123}

header_118 [label="2 : case(deck)"]

prose_119 [label="prose"]

prose_120 [label="prose"]

prose_121 [label="prose"]

codeblock_122 [label="code block 114-152"]

section_123 [label="section: 154-183"]


// END RANK section_7

header_118 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** case(deck)"]
// END RANK header_118

prose_119 -> { raw_125 prespace_126 literal_127 raw_128 prespace_129 literal_130 raw_131 prespace_132 literal_133 raw_134}
{rank=same; raw_125 prespace_126 literal_127 raw_128 prespace_129 literal_130 raw_131 prespace_132 literal_133 raw_134}

raw_125 [label="raw"]

prespace_126 [label="prespace"]

literal_127 [label="literal"]

raw_128 [label="raw"]

prespace_129 [label="prespace"]

literal_130 [label="literal"]

raw_131 [label="raw"]

prespace_132 [label="prespace"]

literal_133 [label="literal"]

raw_134 [label="raw"]


// END RANK prose_119

raw_125 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Casing is what we call gathering information about a deck, its subdecks,
and associated files. "]
// END RANK raw_125

prespace_126 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_126

literal_127 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="case"]
// END RANK literal_127

raw_128 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will also pull the"]
// END RANK raw_128

prespace_129 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_129

literal_130 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".deck"]
// END RANK literal_130

raw_131 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" file into memory,
parse it into a Doc, and attach that at"]
// END RANK raw_131

prespace_132 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_132

literal_133 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.dotDeck"]
// END RANK literal_133

raw_134 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_134

prose_120 -> { raw_145}
{rank=same; raw_145}

raw_145 [label="raw"]


// END RANK prose_120

raw_145 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Casing a deck will cause its subdecks to be cased also, recursively. This is
where we will add inode comparison to keep from following cyclic references,
since it's what draws directory attributes out of the filesystem into memory.
"]
// END RANK raw_145

prose_121 -> { raw_147 link_148 raw_149}
{rank=same; raw_147 link_148 raw_149}

raw_147 [label="raw"]

link_148 [label="link"]

raw_149 [label="raw"]


// END RANK prose_121

raw_147 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
After casing a Deck is ready to be "]
// END RANK raw_147

link_148 -> { anchortext_151 url_152}
{rank=same; anchortext_151 url_152}

anchortext_151 [label="anchortext"]

url_152 [label="url"]


// END RANK link_148

anchortext_151 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spun"]
// END RANK anchortext_151

url_152 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_152

raw_149 -> leaf_155
leaf_155  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_149

codeblock_122 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new

function Deck.case(deck)
   s:verb(\"dir: \" .. tostring(deck.dir))
   local dir = deck.dir
   local codex = deck.codex
   local basename = dir:basename()
   assert(dir.idEst == Dir, \"dir not a directory\")
   local codexRoot = codex.root:basename()
   s:verb(\"root: \" .. tostring(codex.root) .. \" base: \" ..tostring(codexRoot))
   local subdirs = dir:getsubdirs()
   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)
   for i, sub in ipairs(subdirs) do
      s:verb(\"  - \" .. sub.path.str)
      deck[i] = new(codex, sub)
   end
   local files = dir:getfiles()
   s:verb(\"  \" .. \"# files: \" .. #files)
   for i, file in ipairs(files) do
      if not ignore(file) then
         local name = file:basename()
         if name == \".deck\" then
            s:ver()
            deck.dotDeck = file
         elseif #file:extension() > 1 then
            name = string.sub(name, 1, - #file:extension() - 1)
         end
         if name == basename then
            s:verb(\"  ~ \" .. name)
            deck.eponym = file
         end
      end
   end

   s:verb(\"#deck is : \" .. #deck)
   return codex
end"]
// END RANK codeblock_122

section_123 -> { header_157 prose_158 codeblock_159 codeblock_160 codeblock_161}
{rank=same; header_157 prose_158 codeblock_159 codeblock_160 codeblock_161}

header_157 [label="3 : __tostring"]

prose_158 [label="prose"]

codeblock_159 [label="code block 156-160"]

codeblock_160 [label="code block 162-177"]

codeblock_161 [label="code block 180-183"]


// END RANK section_123

header_157 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** __tostring"]
// END RANK header_157

prose_158 -> { raw_163}
{rank=same; raw_163}

raw_163 [label="raw"]


// END RANK prose_158

raw_163 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_163

codeblock_159 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Deck.__tostring(deck)
   return deck.dir.path.str
end"]
// END RANK codeblock_159

codeblock_160 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label="new = function (codex, dir)
   if type(dir) == \"string\" then
      dir = Dir(dir)
   end
   if __Decks[dir] then
      return __Decks[dir]
   end
   local deck = setmetatable({}, Deck)
   deck.dir = dir
   deck.codex = codex
   deck.docs  = {}
   Deck.case(deck)
   return deck
end"]
// END RANK codeblock_160

codeblock_161 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Deck.idEst = new
return new"]
// END RANK codeblock_161


}
