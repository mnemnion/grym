digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 371"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-256"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9 section_10 section_11 section_12}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9 section_10 section_11 section_12}

header_2 [label="1 : Path"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

prose_7 [label="prose"]

section_8 [label="section: 20-72"]

section_9 [label="section: 73-75"]

section_10 [label="section: 76-148"]

section_11 [label="section: 224-256"]

section_12 [label="section: 257-335"]


// END RANK section_1

header_2 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Path"]
// END RANK header_2

prose_3 -> { raw_14}
{rank=same; raw_14}

raw_14 [label="raw"]


// END RANK prose_3

raw_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


Let's make a little Path class that isn't just a string.
"]
// END RANK raw_14

prose_4 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


// END RANK prose_4

raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
They need to be:
"]
// END RANK raw_16

prose_5 -> { raw_18}
{rank=same; raw_18}

raw_18 [label="raw"]


// END RANK prose_5

raw_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
-  Immutable. Adding to a path or substituting within it
   produces a new path; a path can't be changed once it's
   established.
"]
// END RANK raw_18

prose_6 -> { raw_20 prespace_21 literal_22 raw_23}
{rank=same; raw_20 prespace_21 literal_22 raw_23}

raw_20 [label="raw"]

prespace_21 [label="prespace"]

literal_22 [label="literal"]

raw_23 [label="raw"]


// END RANK prose_6

raw_20 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
-  Stringy. "]
// END RANK raw_20

prespace_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_21

literal_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tostring"]
// END RANK literal_22

raw_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" gives us the literal string rep of
   the Path, __concat works (but immutably), and so on.
"]
// END RANK raw_23

prose_7 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


// END RANK prose_7

raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Paths are going to be heavily re-used and extended, first by Directories
and Files, and then we'll want to take a pass a making them grammatical
and extending their properties to the URI class.

"]
// END RANK raw_28

section_8 -> { header_30 prose_31 prose_32 prose_33 prose_34 prose_35 prose_36 prose_37 prose_38 prose_39 prose_40 prose_41 prose_42 codeblock_43}
{rank=same; header_30 prose_31 prose_32 prose_33 prose_34 prose_35 prose_36 prose_37 prose_38 prose_39 prose_40 prose_41 prose_42 codeblock_43}

header_30 [label="2 : Fields"]

prose_31 [label="prose"]

prose_32 [label="prose"]

prose_33 [label="prose"]

prose_34 [label="prose"]

prose_35 [label="prose"]

prose_36 [label="prose"]

prose_37 [label="prose"]

prose_38 [label="prose"]

prose_39 [label="prose"]

prose_40 [label="prose"]

prose_41 [label="prose"]

prose_42 [label="prose"]

codeblock_43 [label="code block 52-70"]


// END RANK section_8

header_30 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
// END RANK header_30

prose_31 -> { raw_45}
{rank=same; raw_45}

raw_45 [label="raw"]


// END RANK prose_31

raw_45 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The array portion of Path tables is entirely strings.
"]
// END RANK raw_45

prose_32 -> { raw_47}
{rank=same; raw_47}

raw_47 [label="raw"]


// END RANK prose_32

raw_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Special characters, notably \"/\", are represented, by themselves,
as strings.
"]
// END RANK raw_47

prose_33 -> { raw_49}
{rank=same; raw_49}

raw_49 [label="raw"]


// END RANK prose_33

raw_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- Prototype
"]
// END RANK raw_49

prose_34 -> { raw_51 prespace_52 literal_53 raw_54}
{rank=same; raw_51 prespace_52 literal_53 raw_54}

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_34

raw_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  divider:  The dividing character,"]
// END RANK raw_51

prespace_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_52

literal_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="/"]
// END RANK literal_53

raw_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" in all sensible realms.
"]
// END RANK raw_54

prose_35 -> { raw_59 prespace_60 literal_61 raw_62}
{rank=same; raw_59 prespace_60 literal_61 raw_62}

raw_59 [label="raw"]

prespace_60 [label="prespace"]

literal_61 [label="literal"]

raw_62 [label="raw"]


// END RANK prose_35

raw_59 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  div_patt:  This is"]
// END RANK raw_59

prespace_60 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_60

literal_61 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="%/"]
// END RANK literal_61

raw_62 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", in a quirk of Lua.
"]
// END RANK raw_62

prose_36 -> { raw_67}
{rank=same; raw_67}

raw_67 [label="raw"]


// END RANK prose_36

raw_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  parent_dir, same_dir:  Not currently used.
"]
// END RANK raw_67

prose_37 -> { raw_69}
{rank=same; raw_69}

raw_69 [label="raw"]


// END RANK prose_37

raw_69 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  isPath:  Always equal to the Path table.
"]
// END RANK raw_69

prose_38 -> { raw_71}
{rank=same; raw_71}

raw_71 [label="raw"]


// END RANK prose_38

raw_71 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- Instance
"]
// END RANK raw_71

prose_39 -> { raw_73 prespace_74 literal_75 raw_76}
{rank=same; raw_73 prespace_74 literal_75 raw_76}

raw_73 [label="raw"]

prespace_74 [label="prespace"]

literal_75 [label="literal"]

raw_76 [label="raw"]


// END RANK prose_39

raw_73 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  filename:  If present, the name of the file.  This will always be
               "]
// END RANK raw_73

prespace_74 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_74

literal_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nil"]
// END RANK literal_75

raw_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" for a directory.
"]
// END RANK raw_76

prose_40 -> { raw_81 prespace_82 literal_83 raw_84 prespace_85 bold_86 raw_87}
{rank=same; raw_81 prespace_82 literal_83 raw_84 prespace_85 bold_86 raw_87}

raw_81 [label="raw"]

prespace_82 [label="prespace"]

literal_83 [label="literal"]

raw_84 [label="raw"]

prespace_85 [label="prespace"]

bold_86 [label="bold"]

raw_87 [label="raw"]


// END RANK prose_40

raw_81 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  isDir:  If"]
// END RANK raw_81

prespace_82 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_82

literal_83 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
// END RANK literal_83

raw_84 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", indicates the Path is structured to be a directory.
        It does"]
// END RANK raw_84

prespace_85 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_85

bold_86 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="not"]
// END RANK bold_86

raw_87 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" indicate that there is a real directory at this path.
"]
// END RANK raw_87

prose_41 -> { raw_95 prespace_96 literal_97 raw_98}
{rank=same; raw_95 prespace_96 literal_97 raw_98}

raw_95 [label="raw"]

prespace_96 [label="prespace"]

literal_97 [label="literal"]

raw_98 [label="raw"]


// END RANK prose_41

raw_95 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  str:  The string form of the path. "]
// END RANK raw_95

prespace_96 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_96

literal_97 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__tostring"]
// END RANK literal_97

raw_98 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" simply returns this,
           it is in-contract to read from this field.  Nothing but Path
           should write to it, which we won't enforce until we can do so
           at compile time.
"]
// END RANK raw_98

prose_42 -> { raw_103 prespace_104 literal_105 raw_106 prespace_107 literal_108 raw_109}
{rank=same; raw_103 prespace_104 literal_105 raw_106 prespace_107 literal_108 raw_109}

raw_103 [label="raw"]

prespace_104 [label="prespace"]

literal_105 [label="literal"]

raw_106 [label="raw"]

prespace_107 [label="prespace"]

literal_108 [label="literal"]

raw_109 [label="raw"]


// END RANK prose_42

raw_103 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo   Check memoized"]
// END RANK raw_103

prespace_104 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_104

literal_105 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__Path"]
// END RANK literal_105

raw_106 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" table during"]
// END RANK raw_106

prespace_107 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_107

literal_108 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__concat"]
// END RANK literal_108

raw_109 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_109

codeblock_43 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local pl_path = require \"pl.path\"
local isdir = pl_path.isdir
local new
local Path = {}
Path.__index = Path

local __Paths = {} -- one Path per real Path

local s = require \"status\" ()
s.angry = false

Path.it = require \"core/check\"

Path.divider = \"/\"
Path.div_patt = \"%/\"
Path.parent_dir = \"..\"
Path.same_dir = \".\""]
// END RANK codeblock_43

section_9 -> { header_118 prose_119}
{rank=same; header_118 prose_119}

header_118 [label="2 : Methods"]

prose_119 [label="prose"]


// END RANK section_9

header_118 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
** __conca"]
// END RANK header_118

prose_119 -> { raw_121}
{rank=same; raw_121}

raw_121 [label="raw"]


// END RANK prose_119

raw_121 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_121

section_10 -> { header_123 prose_124 prose_125 prose_126 prose_127 prose_128 prose_129 prose_130 prose_131 prose_132 prose_133 section_134 section_135}
{rank=same; header_123 prose_124 prose_125 prose_126 prose_127 prose_128 prose_129 prose_130 prose_131 prose_132 prose_133 section_134 section_135}

header_123 [label="2 : __concat"]

prose_124 [label="prose"]

prose_125 [label="prose"]

prose_126 [label="prose"]

prose_127 [label="prose"]

prose_128 [label="prose"]

prose_129 [label="prose"]

prose_130 [label="prose"]

prose_131 [label="prose"]

prose_132 [label="prose"]

prose_133 [label="prose"]

section_134 [label="section: 111-126"]

section_135 [label="section: 149-223"]


// END RANK section_10

header_123 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Concat retu"]
// END RANK header_123

prose_124 -> { raw_137}
{rank=same; raw_137}

raw_137 [label="raw"]


// END RANK prose_124

raw_137 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Concat returns a new path that is the synthesis of either a
string or another path.
"]
// END RANK raw_137

prose_125 -> { raw_139}
{rank=same; raw_139}

raw_139 [label="raw"]


// END RANK prose_125

raw_139 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- params
"]
// END RANK raw_139

prose_126 -> { raw_141}
{rank=same; raw_141}

raw_141 [label="raw"]


// END RANK prose_126

raw_141 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  head_path:  A Path. Cloned before concatenation.
"]
// END RANK raw_141

prose_127 -> { raw_143}
{rank=same; raw_143}

raw_143 [label="raw"]


// END RANK prose_127

raw_143 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  tail_path:  If a String, this is concatenated.  If the result is
           not a structurally valid string, this is complained about
           and nil is returned.
"]
// END RANK raw_143

prose_128 -> { raw_145}
{rank=same; raw_145}

raw_145 [label="raw"]


// END RANK prose_128

raw_145 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           If it's another Path, we want to do the right thing, and not
           make developers guess what that might be, so:
"]
// END RANK raw_145

prose_129 -> { raw_147 prespace_148 bold_149 raw_150 prespace_151 literal_152 raw_153 prespace_154 literal_155 raw_156}
{rank=same; raw_147 prespace_148 bold_149 raw_150 prespace_151 literal_152 raw_153 prespace_154 literal_155 raw_156}

raw_147 [label="raw"]

prespace_148 [label="prespace"]

bold_149 [label="bold"]

raw_150 [label="raw"]

prespace_151 [label="prespace"]

literal_152 [label="literal"]

raw_153 [label="raw"]

prespace_154 [label="prespace"]

literal_155 [label="literal"]

raw_156 [label="raw"]


// END RANK prose_129

raw_147 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           If it's two absolute Paths, then"]
// END RANK raw_147

prespace_148 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_148

bold_149 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="iff"]
// END RANK bold_149

raw_150 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" the tail_path nests in the
           head_path, the tail_path is returned.  So"]
// END RANK raw_150

prespace_151 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_151

literal_152 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\"/usr/\" .. \"/usr/bin/\""]
// END RANK literal_152

raw_153 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           returns"]
// END RANK raw_153

prespace_154 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_154

literal_155 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\"/usr/bin\""]
// END RANK literal_155

raw_156 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_156

prose_130 -> { raw_167 prespace_168 italic_169 raw_170 prespace_171 literal_172 raw_173 prespace_174 literal_175 raw_176 prespace_177 literal_178 raw_179}
{rank=same; raw_167 prespace_168 italic_169 raw_170 prespace_171 literal_172 raw_173 prespace_174 literal_175 raw_176 prespace_177 literal_178 raw_179}

raw_167 [label="raw"]

prespace_168 [label="prespace"]

italic_169 [label="italic"]

raw_170 [label="raw"]

prespace_171 [label="prespace"]

literal_172 [label="literal"]

raw_173 [label="raw"]

prespace_174 [label="prespace"]

literal_175 [label="literal"]

raw_176 [label="raw"]

prespace_177 [label="prespace"]

literal_178 [label="literal"]

raw_179 [label="raw"]


// END RANK prose_130

raw_167 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           If the tail_path is relative, then it's flexibly applied to the
           head_path. For a path that"]
// END RANK raw_167

prespace_168 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_168

italic_169 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label="doesn't"]
// END RANK italic_169

raw_170 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" start with"]
// END RANK raw_170

prespace_171 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_171

literal_172 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="."]
// END RANK literal_172

raw_173 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label=","]
// END RANK raw_173

prespace_174 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_174

literal_175 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".."]
// END RANK literal_175

raw_176 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or"]
// END RANK raw_176

prespace_177 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_177

literal_178 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*"]
// END RANK literal_178

raw_179 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label=",
           this is simple concatenation.
"]
// END RANK raw_179

prose_131 -> { raw_193 prespace_194 literal_195 raw_196 prespace_197 literal_198 raw_199}
{rank=same; raw_193 prespace_194 literal_195 raw_196 prespace_197 literal_198 raw_199}

raw_193 [label="raw"]

prespace_194 [label="prespace"]

literal_195 [label="literal"]

raw_196 [label="raw"]

prespace_197 [label="prespace"]

literal_198 [label="literal"]

raw_199 [label="raw"]


// END RANK prose_131

raw_193 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           Note that"]
// END RANK raw_193

prespace_194 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_194

literal_195 -> leaf_202
leaf_202  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__concat"]
// END RANK literal_195

raw_196 -> leaf_203
leaf_203  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" refuses to make \"foo//bar\" from \"foo/\"
           and \"/bar\", and similarly won't make \"/foobar\" from \"/foo\" and \"bar\". Both
           of these will return"]
// END RANK raw_196

prespace_197 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_197

literal_198 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nil"]
// END RANK literal_198

raw_199 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", and the malformed string as the error. #nyi


"]
// END RANK raw_199

prose_132 -> { raw_207}
{rank=same; raw_207}

raw_207 [label="raw"]


// END RANK prose_132

raw_207 -> leaf_208
leaf_208  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- return
"]
// END RANK raw_207

prose_133 -> { raw_209}
{rank=same; raw_209}

raw_209 [label="raw"]


// END RANK prose_133

raw_209 -> leaf_210
leaf_210  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - A new Path.

"]
// END RANK raw_209

section_134 -> { header_211 prose_212 codeblock_213 section_214}
{rank=same; header_211 prose_212 codeblock_213 section_214}

header_211 [label="3 : clone(path)"]

prose_212 [label="prose"]

codeblock_213 [label="code block 115-124"]

section_214 [label="section: 127-148"]


// END RANK section_134

header_211 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ble stolen.

#!l"]
// END RANK header_211

prose_212 -> { raw_216}
{rank=same; raw_216}

raw_216 [label="raw"]


// END RANK prose_212

raw_216 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This returns a copy of the path with the metatable stolen.
"]
// END RANK raw_216

codeblock_213 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function clone(path)
  local new_path = {}
  for k,v in pairs(path) do
    new_path[k] = v
  end
  setmetatable(new_path, getmetatable(path))
  return new_path
end"]
// END RANK codeblock_213

section_214 -> { header_219 prose_220 codeblock_221}
{rank=same; header_219 prose_220 codeblock_221}

header_219 [label="4 : endsMatch(head, tail)"]

prose_220 [label="prose"]

codeblock_221 [label="code block 132-147"]


// END RANK section_214

header_219 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" heterosexual,
pathwise.

#"]
// END RANK header_219

prose_220 -> { raw_223}
{rank=same; raw_223}

raw_223 [label="raw"]


// END RANK prose_220

raw_223 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Takes two strings. Returns true if they are heterosexual,
pathwise.
"]
// END RANK raw_223

codeblock_221 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function endsMatch(head, tail)
   local div = Path.divider
   head_b = string.sub(head, -2, -1)
   tail_b = string.sub(tail, 1, 1)
   if div == head_b
      and div == tail_b then
      return false
   elseif div ~= head_b
      and div ~= tail_b then
      return false
   end

   return true
end"]
// END RANK codeblock_221

section_135 -> { header_226 prose_227 codeblock_228 codeblock_229}
{rank=same; header_226 prose_227 codeblock_228 codeblock_229}

header_226 [label="3 : stringAwk"]

prose_227 [label="prose"]

codeblock_228 [label="code block 153-187"]

codeblock_229 [label="code block 190-221"]


// END RANK section_135

header_226 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" add to them."]
// END RANK header_226

prose_227 -> { raw_231}
{rank=same; raw_231}

raw_231 [label="raw"]


// END RANK prose_227

raw_231 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is used twice, once to build new paths, and once to add to them.
"]
// END RANK raw_231

codeblock_228 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function stringAwk(path, str)
  local div, div_patt = Path.divider, Path.div_patt
  local phrase = \"\"
  local remain = str
    -- chew the string like Pac Man
  while remain  do
    local dir_index = string.find(remain, div_patt)
    if dir_index then
      -- add the handle minus div
      path[#path + 1] = string.sub(remain, 1, dir_index - 1)
      -- then the div
      path[#path + 1] = div
      local new_remain = string.sub(remain, dir_index + 1)
      assert(#new_remain < #remain, \"remain must decrease\")
      remain = new_remain
      if remain == \"\" then
        remain = nil
      end
    else
      -- file
      path[#path + 1] = remain
      path.filename = remain
      remain = nil
    end
  end
   local ps = path.str and path.str or str
  if isdir(ps) then
    path.isDir = true
      path.filename = nil
  end

  return path
end"]
// END RANK codeblock_228

codeblock_229 -> leaf_234
leaf_234  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function __concat(head_path, tail_path)
  local new_path = clone(head_path)
  if type(tail_path) == 'string' then
    -- use the stringbuilder
      if not endsMatch(head_path[#head_path], tail_path) then
         return nil
      end
    local path_parts = stringAwk({}, tail_path)
    for _, v in ipairs(path_parts) do
      new_path[#new_path + 1] = v
    end

    new_path.str = new_path.str .. tail_path
    if isdir(new_path.str) then
      new_path.isDir = true
      new_path.filename = nil
    else
      new_path.filename = path_parts.filename
    end

    if __Paths[new_path.str] then
      return __Paths[new_path.str]
    end

      __Paths[new_path.str] = new_path
    return new_path
  else
    s:complain(\"NYI\", \"can only concatenate string at present\")
  end
end"]
// END RANK codeblock_229

section_11 -> { header_235 prose_236 prose_237 prose_238 codeblock_239}
{rank=same; header_235 prose_236 prose_237 prose_238 codeblock_239}

header_235 [label="2 : Path.parentDir(path, dir)"]

prose_236 [label="prose"]

prose_237 [label="prose"]

prose_238 [label="prose"]

codeblock_239 [label="code block 234-254"]


// END RANK section_11

header_235 -> leaf_240
leaf_240  [color=Gray,shape=rectangle,fontname=Inconsolata,label="l directory.

Example: if the"]
// END RANK header_235

prose_236 -> { raw_241 prespace_242 literal_243 raw_244}
{rank=same; raw_241 prespace_242 literal_243 raw_244}

raw_241 [label="raw"]

prespace_242 [label="prespace"]

literal_243 [label="literal"]

raw_244 [label="raw"]


// END RANK prose_236

raw_241 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Currently only accepts a string for"]
// END RANK raw_241

prespace_242 -> leaf_246
leaf_246  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_242

literal_243 -> leaf_247
leaf_247  [color=Gray,shape=rectangle,fontname=Inconsolata,label="dir"]
// END RANK literal_243

raw_244 -> leaf_248
leaf_248  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_244

prose_237 -> { raw_249}
{rank=same; raw_249}

raw_249 [label="raw"]


// END RANK prose_237

raw_249 -> leaf_250
leaf_250  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It proceeds backwards looking for \"dir\".  If it finds a match, it
returns a new path that has the full directory.
"]
// END RANK raw_249

prose_238 -> { raw_251 prespace_252 literal_253 raw_254 prespace_255 literal_256 raw_257}
{rank=same; raw_251 prespace_252 literal_253 raw_254 prespace_255 literal_256 raw_257}

raw_251 [label="raw"]

prespace_252 [label="prespace"]

literal_253 [label="literal"]

raw_254 [label="raw"]

prespace_255 [label="prespace"]

literal_256 [label="literal"]

raw_257 [label="raw"]


// END RANK prose_238

raw_251 -> leaf_258
leaf_258  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Example: if the path is \"/usr/local/bin/\","]
// END RANK raw_251

prespace_252 -> leaf_259
leaf_259  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_252

literal_253 -> leaf_260
leaf_260  [color=Gray,shape=rectangle,fontname=Inconsolata,label="path:parentDir(\"local\")"]
// END RANK literal_253

raw_254 -> leaf_261
leaf_261  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will
return"]
// END RANK raw_254

prespace_255 -> leaf_262
leaf_262  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_255

literal_256 -> leaf_263
leaf_263  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Path \"/usr/local/\""]
// END RANK literal_256

raw_257 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_257

codeblock_239 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Path.parentDir(path, dir)
  if not path.isDir then
    return nil
  end

  for i = #path, 1, -1 do
    if path[i] == dir then
      local path_phrase = \"\"
      for j = 1, i do
        path_phrase = path_phrase .. path[j]
      end
      return new(path_phrase)
    end
  end

  return nil
end

"]
// END RANK codeblock_239

section_12 -> { header_266 prose_267 codeblock_268 section_269 section_270 section_271 section_272}
{rank=same; header_266 prose_267 codeblock_268 section_269 section_270 section_271 section_272}

header_266 [label="2 : __tostring"]

prose_267 [label="prose"]

codeblock_268 [label="code block 261-265"]

section_269 [label="section: 269-286"]

section_270 [label="section: 287-305"]

section_271 [label="section: 306-335"]

section_272 [label="section: 336-371"]


// END RANK section_12

header_266 -> leaf_273
leaf_273  [color=Gray,shape=rectangle,fontname=Inconsolata,label="e private.

#!"]
// END RANK header_266

prose_267 -> { raw_274}
{rank=same; raw_274}

raw_274 [label="raw"]


// END RANK prose_267

raw_274 -> leaf_275
leaf_275  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Since we always have a path as a string, we simply return it.
"]
// END RANK raw_274

codeblock_268 -> leaf_276
leaf_276  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function __tostring(path)
  return path.str
end"]
// END RANK codeblock_268

section_269 -> { header_277 prose_278 codeblock_279}
{rank=same; header_277 prose_278 codeblock_279}

header_277 [label="3 : fromString(str)"]

prose_278 [label="prose"]

codeblock_279 [label="code block 273-284"]


// END RANK section_269

header_277 -> leaf_280
leaf_280  [color=Gray,shape=rectangle,fontname=Inconsolata,label="catting then
		local"]
// END RANK header_277

prose_278 -> { raw_281}
{rank=same; raw_281}

raw_281 [label="raw"]


// END RANK prose_278

raw_281 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is a builder function and hence private.
"]
// END RANK raw_281

codeblock_279 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fromString(path, str)
  local div, div_patt = Path.divider, Path.div_patt
  if string.sub(str, 1, 1) ~= div and not catting then
    local msg = \"Paths must be absolute and start with \" .. div
    s:complain(\"validation error\", msg)
    return nil, msg
  else
    return stringAwk(path, str, div, div_patt)
  end
end"]
// END RANK codeblock_279

section_270 -> { header_284 prose_285 prose_286 codeblock_287}
{rank=same; header_284 prose_285 prose_286 codeblock_287}

header_284 [label="3 : Path.has(path, substr)"]

prose_285 [label="prose"]

prose_286 [label="prose"]

codeblock_287 [label="code block 293-303"]


// END RANK section_270

header_284 -> leaf_288
leaf_288  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" v == substr then
         "]
// END RANK header_284

prose_285 -> { raw_289 prespace_290 literal_291 raw_292 prespace_293 literal_294 raw_295}
{rank=same; raw_289 prespace_290 literal_291 raw_292 prespace_293 literal_294 raw_295}

raw_289 [label="raw"]

prespace_290 [label="prespace"]

literal_291 [label="literal"]

raw_292 [label="raw"]

prespace_293 [label="prespace"]

literal_294 [label="literal"]

raw_295 [label="raw"]


// END RANK prose_285

raw_289 -> leaf_296
leaf_296  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns"]
// END RANK raw_289

prespace_290 -> leaf_297
leaf_297  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_290

literal_291 -> leaf_298
leaf_298  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
// END RANK literal_291

raw_292 -> leaf_299
leaf_299  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" if the substring is present,"]
// END RANK raw_292

prespace_293 -> leaf_300
leaf_300  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_293

literal_294 -> leaf_301
leaf_301  [color=Gray,shape=rectangle,fontname=Inconsolata,label="false"]
// END RANK literal_294

raw_295 -> leaf_302
leaf_302  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" otherwise.
"]
// END RANK raw_295

prose_286 -> { raw_303}
{rank=same; raw_303}

raw_303 [label="raw"]


// END RANK prose_286

raw_303 -> leaf_304
leaf_304  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Does not work with globs or partial matches.
"]
// END RANK raw_303

codeblock_287 -> leaf_305
leaf_305  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Path.has(path, substr)
   for _, v in ipairs(path) do
      if v == substr then
         return true
      end
   end

   return false
end"]
// END RANK codeblock_287

section_271 -> { header_306 prose_307 prose_308 codeblock_309}
{rank=same; header_306 prose_307 prose_308 codeblock_309}

header_306 [label="3 : new"]

prose_307 [label="prose"]

prose_308 [label="prose"]

codeblock_309 [label="code block 312-333"]


// END RANK section_271

header_306 -> leaf_310
leaf_310  [color=Gray,shape=rectangle,fontname=Inconsolata,label="unction "]
// END RANK header_306

prose_307 -> { raw_311}
{rank=same; raw_311}

raw_311 [label="raw"]


// END RANK prose_307

raw_311 -> leaf_312
leaf_312  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Builds a Path from, currently, a string.
"]
// END RANK raw_311

prose_308 -> { raw_313}
{rank=same; raw_313}

raw_313 [label="raw"]


// END RANK prose_308

raw_313 -> leaf_314
leaf_314  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is the important use case.
"]
// END RANK raw_313

codeblock_309 -> leaf_315
leaf_315  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local PathMeta = {__index = Path,
                  __concat = __concat,
                  __tostring = __tostring}

new  = function (path_seed)
  if __Paths[path_seed] then
    return __Paths[path_seed]
  end
  local path = setmetatable({}, PathMeta)
  if type(path_seed) == 'string' then
    path.str = path_seed
    path =  fromString(path, path_seed)
  elseif type(path_seed) == 'table' then
    s:complain(\"NYI\", 'construction from a Path or other table is not yet implemented')
  end

  __Paths[path_seed] = path

  return path
end"]
// END RANK codeblock_309

section_272 -> { header_316 prose_317 prose_318 codeblock_319}
{rank=same; header_316 prose_317 prose_318 codeblock_319}

header_316 [label="3 : Constructor and flag"]

prose_317 [label="prose"]

prose_318 [label="prose"]

codeblock_319 [label="code block 344-349"]


// END RANK section_272

header_316 -> leaf_320
leaf_320  [color=Gray,shape=rectangle,fontname=Inconsolata,label="produced from \"require\"."]
// END RANK header_316

prose_317 -> { raw_321}
{rank=same; raw_321}

raw_321 [label="raw"]


// END RANK prose_317

raw_321 -> leaf_322
leaf_322  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

I think this does what I want for this class: it generates a Path on call,
and provides a table for reference equality.
"]
// END RANK raw_321

prose_318 -> { raw_323}
{rank=same; raw_323}

raw_323 [label="raw"]


// END RANK prose_318

raw_323 -> leaf_324
leaf_324  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The idea is that some aspect of an instance object can be compared to the
module as produced from \"require\".
"]
// END RANK raw_323

codeblock_319 -> leaf_325
leaf_325  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local PathCall = setmetatable({}, {__call = new})
Path.isPath = new
Path.idEst = new
return new"]
// END RANK codeblock_319


}
