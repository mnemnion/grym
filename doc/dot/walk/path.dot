digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 153"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-57"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 section_8 section_9}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 section_8 section_9}

header_2 [label="1 : Path #Todo"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

codeblock_7 [label="code block 14-26"]

section_8 [label="section: 29-57"]

section_9 [label="section: 58-87"]


// END RANK section_1

header_2 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Path #Todo"]
// END RANK header_2

prose_3 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_3

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Let's make a little Path class that isn't just a string.
"]
// END RANK raw_11

prose_4 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_4

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
They need to be:
"]
// END RANK raw_13

prose_5 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_5

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
-  Immutable. Adding to a path or substituting within it
   produces a new path; a path can't be changed once it's
   established. 
"]
// END RANK raw_15

prose_6 -> { raw_17 prespace_18 literal_19 raw_20}
{rank=same; raw_17 prespace_18 literal_19 raw_20}

raw_17 [label="raw"]

prespace_18 [label="prespace"]

literal_19 [label="literal"]

raw_20 [label="raw"]


// END RANK prose_6

raw_17 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
-  Stringy. "]
// END RANK raw_17

prespace_18 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_18

literal_19 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tostring"]
// END RANK literal_19

raw_20 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" gives us the literal string rep of
   the Path, __concat works (but immutably), and so on.
"]
// END RANK raw_20

codeblock_7 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Path = {}
local s = require \"status\" ()
s.angry = false

Path.__index = Path
Path.isPath = Path

Path.divider = \"/\"
Path.div_patt = \"%/\"
Path.parent_dir = \"..\"
Path.same_dir = \".\""]
// END RANK codeblock_7

section_8 -> { header_26 prose_27 codeblock_28}
{rank=same; header_26 prose_27 codeblock_28}

header_26 [label="2 : __concat"]

prose_27 [label="prose"]

codeblock_28 [label="code block 34-55"]


// END RANK section_8

header_26 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** __concat"]
// END RANK header_26

prose_27 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


// END RANK prose_27

raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Concat returns a new path that is the synthesis of either a
string or another path.
"]
// END RANK raw_30

codeblock_28 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new      -- function
local fromString -- function

local function __concat(head_path, tail_path)
    local new_path = new(Path, head_path, catting)
  if type(tail_path) == 'string' then
    new_path[#new_path + 1] = tail_path
    local phrase = new_path.str or \"\"
    new_path.str = phrase .. tail_path
    return new_path
  else
    local phrase = head_path.str or \"\"
    for _, v in ipairs(tail_path) do
      new_path[#new_path + 1] = v
      phrase = phrase .. v
    end
    new_path = fromString(new_path, new_path.str .. phrase, true)
    return new_path
  end
end"]
// END RANK codeblock_28

section_9 -> { header_33 prose_34 codeblock_35 section_36 section_37}
{rank=same; header_33 prose_34 codeblock_35 section_36 section_37}

header_33 [label="2 : __tostring"]

prose_34 [label="prose"]

codeblock_35 [label="code block 62-66"]

section_36 [label="section: 69-87"]

section_37 [label="section: 88-153"]


// END RANK section_9

header_33 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lly supply a p"]
// END RANK header_33

prose_34 -> { raw_39}
{rank=same; raw_39}

raw_39 [label="raw"]


// END RANK prose_34

raw_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Since we normally supply a path as a string, we just keep it around.
"]
// END RANK raw_39

codeblock_35 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function __tostring(path)
  return path.str
end"]
// END RANK codeblock_35

section_36 -> { header_42 prose_43 prose_44 codeblock_45}
{rank=same; header_42 prose_43 prose_44 codeblock_45}

header_42 [label="3 : toString(path_seed)"]

prose_43 [label="prose"]

prose_44 [label="prose"]

codeblock_45 [label="code block 77-85"]


// END RANK section_36

header_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nt to accept any old arr"]
// END RANK header_42

prose_43 -> { raw_47 prespace_48 literal_49 raw_50}
{rank=same; raw_47 prespace_48 literal_49 raw_50}

raw_47 [label="raw"]

prespace_48 [label="prespace"]

literal_49 [label="literal"]

raw_50 [label="raw"]


// END RANK prose_43

raw_47 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We want to accept any old array of strings whether it's a Path or not,
so we can't count on the path_seed having a"]
// END RANK raw_47

prespace_48 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_48

literal_49 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".str"]
// END RANK literal_49

raw_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field.
"]
// END RANK raw_50

prose_44 -> { raw_55}
{rank=same; raw_55}

raw_55 [label="raw"]


// END RANK prose_44

raw_55 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  This will always produce a directory, which isn't what
             we want. 
"]
// END RANK raw_55

codeblock_45 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="toString = function (path_seed)
  local phrase = \"\"
  for _, str in ipairs(path_seed) do
    phrase = Path.divider .. phrase
  end
  return phrase
end"]
// END RANK codeblock_45

section_37 -> { header_58 prose_59 codeblock_60 codeblock_61}
{rank=same; header_58 prose_59 codeblock_60 codeblock_61}

header_58 [label="3 : fromString(str)"]

prose_59 [label="prose"]

codeblock_60 [label="code block 92-120"]

codeblock_61 [label="code block 122-153"]


// END RANK section_37

header_58 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="er function and henc"]
// END RANK header_58

prose_59 -> { raw_63}
{rank=same; raw_63}

raw_63 [label="raw"]


// END RANK prose_59

raw_63 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is a builder function and hence private.
"]
// END RANK raw_63

codeblock_60 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fromString(path, str, catting)
  local div, div_patt = Path.divider, Path.div_patt
  if string.sub(str, 1, 1) ~= div and not catting then
    local msg = \"Paths must be absolute and start with \" .. div
    s:complain(\"validation error\", msg)
    return nil, msg
  else
    local phrase = \"\"
    local remain = string.sub(str, 2)
    while remain  do
      local dir_index = string.find(remain, div_patt)
      if dir_index then
        -- add the handle minus div
        path[#path + 1] = string.sub(remain, 1, dir_index - 1)
        local new_remain = string.sub(remain, dir_index + 1)
        assert(#new_remain < #remain, \"remain must decrease\")
        remain = new_remain

      else
        -- file
        path[#path + 1] = remain
        remain = nil  
      end
    end
    return path
  end
end"]
// END RANK codeblock_60

codeblock_61 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="new = function (Path, path_seed)
  local path = setmetatable({}, {__index = Path,
                               __concat = __concat,
                               __tostring = __tostring})
  if type(path_seed) == 'string' then
    path.str = path_seed
    path =  fromString(path, path_seed)
  else
      io.write(\"building from table of length \" .. #path_seed .. \"\\n\")
      if not path_seed.isPath then
        io.write(\"path_seed is Path\\n\")
      else 
        io.write(\"path_seed is not Path, instead: \" 
                .. tostring(path_seed) .. \"\\n\")
       end
      local phrase = \"\"
    for i, v in ipairs(path_seed) do
      assert(type(v) == \"string\", \"contents of Path([]) must be strings, not\"
             .. type(v) .. \" with flag .isPath: \" .. tostring(v.isPath))
      io.write(\"adding \" .. v  .. \"\\n\") 
      path[i] = path_seed
      phrase = phrase .. v
    end
    path.str = fromString(path, phrase)
  end
  
  return path
end

return setmetatable({}, {__call = new})"]
// END RANK codeblock_61


}
