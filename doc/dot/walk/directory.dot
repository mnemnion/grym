digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 169"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-63"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 codeblock_9 section_10 section_11}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 codeblock_9 section_10 section_11}

header_2 [label="1 : Directory"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

codeblock_7 [label="code block 13-25"]

codeblock_8 [label="code block 27-29"]

codeblock_9 [label="code block 31-37"]

section_10 [label="section: 39-63"]

section_11 [label="section: 64-72"]


// END RANK section_1

header_2 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Directory"]
// END RANK header_2

prose_3 -> { raw_13 prespace_14 literal_15 raw_16}
{rank=same; raw_13 prespace_14 literal_15 raw_16}

raw_13 [label="raw"]

prespace_14 [label="prespace"]

literal_15 [label="literal"]

raw_16 [label="raw"]


// END RANK prose_3

raw_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_13

prespace_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_14

literal_15 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
// END RANK literal_15

raw_16 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is going to have a certain attitude toward directories.
"]
// END RANK raw_16

prose_4 -> { raw_21 prespace_22 literal_23 raw_24}
{rank=same; raw_21 prespace_22 literal_23 raw_24}

raw_21 [label="raw"]

prespace_22 [label="prespace"]

literal_23 [label="literal"]

raw_24 [label="raw"]


// END RANK prose_4

raw_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The"]
// END RANK raw_21

prespace_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_22

literal_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="orb"]
// END RANK literal_23

raw_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" directory module will emulate and prototype that attitude.
"]
// END RANK raw_24

prose_5 -> { raw_29}
{rank=same; raw_29}

raw_29 [label="raw"]


// END RANK prose_5

raw_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add and use raw \"lfs\" dependency, since we already need it
"]
// END RANK raw_29

prose_6 -> { raw_31 prespace_32 literal_33 raw_34}
{rank=same; raw_31 prespace_32 literal_33 raw_34}

raw_31 [label="raw"]

prespace_32 [label="prespace"]

literal_33 [label="literal"]

raw_34 [label="raw"]


// END RANK prose_6

raw_31 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  And this is the wrong place to put it but, phase out penlight.
             All I use is strict and wrappers around"]
// END RANK raw_31

prespace_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_32

literal_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lfs"]
// END RANK literal_33

raw_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_34

codeblock_7 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local pl_path = require \"pl.path\"
local pl_dir  = require \"pl.dir\"
local pl_file = require \"pl.file\"
local lfs = require \"lfs\"
local attributes = lfs.attributes
local isdir  = pl_path.isdir
local getfiles = pl_dir.getfiles
local mkdir = lfs.mkdir

local Path = require \"walk/path\"
local File = require \"walk/file\""]
// END RANK codeblock_7

codeblock_8 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new"]
// END RANK codeblock_8

codeblock_9 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Dir = {}
Dir.isDir = Dir
Dir.it = require \"core/check\"

local __Dirs = {} -- Cache to keep each Dir unique by Path"]
// END RANK codeblock_9

section_10 -> { header_42 prose_43 codeblock_44 codeblock_45}
{rank=same; header_42 prose_43 codeblock_44 codeblock_45}

header_42 [label="3 : Dir:exists()"]

prose_43 [label="prose"]

codeblock_44 [label="code block 41-45"]

codeblock_45 [label="code block 47-62"]


// END RANK section_10

header_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Dir:exists()"]
// END RANK header_42

prose_43 -> { raw_47}
{rank=same; raw_47}

raw_47 [label="raw"]


// END RANK prose_43

raw_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_47

codeblock_44 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Dir.exists(dir)
  return isdir(dir.path.str)
end"]
// END RANK codeblock_44

codeblock_45 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Dir.mkdir(dir)
  if dir:exists() then
    return false, \"directory already exists\"
  else
    local success, msg, code = mkdir(dir.path.str)
    if success then
      return success
    else
      code = tostring(code)
      s:complain(\"mkdir failure # \" .. code, msg, dir)
      return false, msg
    end
  end
end"]
// END RANK codeblock_45

section_11 -> { header_51 prose_52 codeblock_53 section_54}
{rank=same; header_51 prose_52 codeblock_53 section_54}

header_51 [label="2 : Dir.parentDir(dir)"]

prose_52 [label="prose"]

codeblock_53 [label="code block 66-70"]

section_54 [label="section: 73-169"]


// END RANK section_11

header_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ua
function Dir.parent"]
// END RANK header_51

prose_52 -> { raw_56}
{rank=same; raw_56}

raw_56 [label="raw"]


// END RANK prose_52

raw_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_56

codeblock_53 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Dir.parentDir(dir)
  return new(dir.path:parentDir())
end"]
// END RANK codeblock_53

section_54 -> { header_59 prose_60 prose_61 codeblock_62 prose_63 codeblock_64 codeblock_65 codeblock_66 codeblock_67 codeblock_68 codeblock_69 codeblock_70}
{rank=same; header_59 prose_60 prose_61 codeblock_62 prose_63 codeblock_64 codeblock_65 codeblock_66 codeblock_67 codeblock_68 codeblock_69 codeblock_70}

header_59 [label="3 : Dir.swapDirFor(dir, nestDir, newNest)"]

prose_60 [label="prose"]

prose_61 [label="prose"]

codeblock_62 [label="code block 80-85"]

prose_63 [label="prose"]

codeblock_64 [label="code block 92-103"]

codeblock_65 [label="code block 106-110"]

codeblock_66 [label="code block 112-122"]

codeblock_67 [label="code block 125-129"]

codeblock_68 [label="code block 131-138"]

codeblock_69 [label="code block 141-162"]

codeblock_70 [label="code block 164-167"]


// END RANK section_54

header_59 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tDir, newNest)

The nomenclature isn't gre"]
// END RANK header_59

prose_60 -> { raw_72}
{rank=same; raw_72}

raw_72 [label="raw"]


// END RANK prose_60

raw_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The nomenclature isn't great here, which is my ignorance of
directory handling showing. But let's get through it.
"]
// END RANK raw_72

prose_61 -> { raw_74}
{rank=same; raw_74}

raw_74 [label="raw"]


// END RANK prose_61

raw_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's easiest to illustrate:
"]
// END RANK raw_74

codeblock_62 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="a = Dir \"/usr/local/bin/\"
b = a:swapDirFor(\"/usr/\", \"/tmp\")
tostring(b)
-- \"/tmp/local/bin/\""]
// END RANK codeblock_62

prose_63 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


// END RANK prose_63

raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It has to be a proper absolute path, which is currently enforced everywhere
a Path is used and will be until I start to add link resolution, since it's
the correct way to treat paths to things that happen to exist.  This is my
need at the moment.
"]
// END RANK raw_77

codeblock_64 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Dir.swapDirFor(dir, nestDir, newNest)
  local dir_str, nest_str = tostring(dir), tostring(nestDir)
  local first, last = string.find(dir_str, nest_str)
  if first == 1 then
    -- swap out
    return new(Path(tostring(newNest) .. string.sub(dir_str, last + 1)))
  else
    return nil, nest_str.. \" not found in \" .. dir_str
  end
end"]
// END RANK codeblock_64

codeblock_65 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Dir.attributes(dir)
  return attributes(dir.path.str)
end"]
// END RANK codeblock_65

codeblock_66 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Dir.getfiles(dir)
  local files = getfiles(dir.path.str)
  table.sort(files)
  for i, f in ipairs(files) do
    files[i] = File(f)
  end

  return files
end"]
// END RANK codeblock_66

codeblock_67 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function __tostring(dir)
  return dir.path.str
end"]
// END RANK codeblock_67

codeblock_68 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function __concat(dir, path)
    if type(dir) == \"string\" then

    end
    return new(dir.path .. path)
end"]
// END RANK codeblock_68

codeblock_69 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function new(path)
  if __Dirs[tostring(path)] then
    return __Dirs[tostring(path)]
  end
  local dir = setmetatable({}, {__index = Dir,
                               __tostring = __tostring,
                               __concat   = __concat})
  if type(path) == \"string\" then
    local new_path = Path(path)
    dir.path = new_path
  elseif path.idEst == Path then
    dir.path = path
  else
    assert(false, \"bad path constructor provided\")
  end

  __Dirs[tostring(path)] = dir

  return dir
end"]
// END RANK codeblock_69

codeblock_70 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Dir.idEst = new
return new"]
// END RANK codeblock_70


}
