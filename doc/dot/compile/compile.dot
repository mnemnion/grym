digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 157"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-144"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 codeblock_6 section_7 section_8 section_9 section_10}
{rank=same; header_2 prose_3 prose_4 prose_5 codeblock_6 section_7 section_8 section_9 section_10}

header_2 [label="1 : Compile"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

codeblock_6 [label="code block 12-19"]

section_7 [label="section: 21-59"]

section_8 [label="section: 60-96"]

section_9 [label="section: 97-144"]

section_10 [label="section: 145-157"]


// END RANK section_1

header_2 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Compile"]
// END RANK header_2

prose_3 -> { raw_12 prespace_13 literal_14 raw_15}
{rank=same; raw_12 prespace_13 literal_14 raw_15}

raw_12 [label="raw"]

prespace_13 [label="prespace"]

literal_14 [label="literal"]

raw_15 [label="raw"]


// END RANK prose_3

raw_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


The goal here is to make a single SQLite file containing all bytecode for"]
// END RANK raw_12

prespace_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_13

literal_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
// END RANK literal_14

raw_15 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" projects.
"]
// END RANK raw_15

prose_4 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


// END RANK prose_4

raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Eventually this can drive a general-purpose build system I guess. We've got
a long way to go with Orb before that's practical.
"]
// END RANK raw_20

prose_5 -> { raw_22}
{rank=same; raw_22}

raw_22 [label="raw"]


// END RANK prose_5

raw_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
For now it just makes LuaJIT bytecode.
"]
// END RANK raw_22

codeblock_6 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local loader = require \"compile/loader\"

local sha = require \"sha3\" . sha512

local s = require \"status\" ()
s.verbose = false"]
// END RANK codeblock_6

section_7 -> { header_25 prose_26 structure_27 prose_28 prose_29 codeblock_30}
{rank=same; header_25 prose_26 structure_27 prose_28 prose_29 codeblock_30}

header_25 [label="4 : splice(tab, index, into)"]

prose_26 [label="prose"]

structure_27 [label="structure"]

prose_28 [label="prose"]

prose_29 [label="prose"]

codeblock_30 [label="code block 34-57"]


// END RANK section_7

header_25 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** splice(tab, index, into)"]
// END RANK header_25

prose_26 -> { raw_32 prespace_33 literal_34 raw_35}
{rank=same; raw_32 prespace_33 literal_34 raw_35}

raw_32 [label="raw"]

prespace_33 [label="prespace"]

literal_34 [label="literal"]

raw_35 [label="raw"]


// END RANK prose_26

raw_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is borrowed from"]
// END RANK raw_32

prespace_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_33

literal_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto.core"]
// END RANK literal_34

raw_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and should be replaced with it once I'm
finally done sorting everything into a database
"]
// END RANK raw_35

structure_27 -> { hashline_40}
{rank=same; hashline_40}

hashline_40 [label="hashline"]


// END RANK structure_27

hashline_40 -> { hashtag_41}
{rank=same; hashtag_41}

hashtag_41 [label="hashtag"]


// END RANK hashline_40

hashtag_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="todo"]
// END RANK hashtag_41

prose_28 -> { raw_43}
{rank=same; raw_43}

raw_43 [label="raw"]


// END RANK prose_28

raw_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
compatible with existing functions and method syntax.
"]
// END RANK raw_43

prose_29 -> { raw_45 prespace_46 literal_47 raw_48 prespace_49 literal_50 raw_51 prespace_52 literal_53 raw_54}
{rank=same; raw_45 prespace_46 literal_47 raw_48 prespace_49 literal_50 raw_51 prespace_52 literal_53 raw_54}

raw_45 [label="raw"]

prespace_46 [label="prespace"]

literal_47 [label="literal"]

raw_48 [label="raw"]

prespace_49 [label="prespace"]

literal_50 [label="literal"]

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_29

raw_45 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
if"]
// END RANK raw_45

prespace_46 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_46

literal_47 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="index"]
// END RANK literal_47

raw_48 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is nil, the contents of"]
// END RANK raw_48

prespace_49 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_49

literal_50 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="into"]
// END RANK literal_50

raw_51 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will be inserted at the end of"]
// END RANK raw_51

prespace_52 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_52

literal_53 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tab"]
// END RANK literal_53

raw_54 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_54

codeblock_30 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local insert = table.insert

local sp_er = \"table<core>.splice: \"
local _e_1 = sp_er .. \"$1 must be a table\"
local _e_2 = sp_er .. \"$2 must be a number\"
local _e_3 = sp_er .. \"$3 must be a table\"

local function splice(tab, idx, into)
   assert(type(tab) == \"table\", _e_1)
   assert(type(idx) == \"number\" or idx == nil, _e_2)
   if idx == nil then
      idx = #tab + 1
   end
   assert(type(into) == \"table\", _e_3)
    idx = idx - 1
    local i = 1
    for j = 1, #into do
        insert(tab,i+idx,into[j])
        i = i + 1
    end
    return tab
end"]
// END RANK codeblock_30

section_8 -> { header_66 prose_67 prose_68 prose_69 codeblock_70}
{rank=same; header_66 prose_67 prose_68 prose_69 codeblock_70}

header_66 [label="4 : _moduleName(path, project)"]

prose_67 [label="prose"]

prose_68 [label="prose"]

prose_69 [label="prose"]

codeblock_70 [label="code block 71-94"]


// END RANK section_8

header_66 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** _moduleName(path, project)"]
// END RANK header_66

prose_67 -> { raw_72}
{rank=same; raw_72}

raw_72 [label="raw"]


// END RANK prose_67

raw_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This takes a Path and a string for the project and derives a plausible module
name from it.
"]
// END RANK raw_72

prose_68 -> { raw_74}
{rank=same; raw_74}

raw_74 [label="raw"]


// END RANK prose_68

raw_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This encodes certain assumptions which I would like to loosen, later.
"]
// END RANK raw_74

prose_69 -> { raw_76}
{rank=same; raw_76}

raw_76 [label="raw"]


// END RANK prose_69

raw_76 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Every time I work with directories I'm reminded what an awkward way to
organize information they are.  Yet here we are...

"]
// END RANK raw_76

codeblock_70 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _moduleName(path, project)
   local mod = {}
   local inMod = false
   for i, v in ipairs(path) do
      if v == project then
         inMod = true
      end
      if inMod then
         if i ~= #path then
            table.insert(mod, v)
          else
             table.insert(mod, path:barename())
         end
      end
   end
   -- drop the bits of the path we won't need
   --- awful kludge fix
   local weird_path = table.concat(mod)
   local good_path = string.gsub(weird_path, \"%.%_\", \"\")
   good_path = string.gsub(good_path, \"orb%/src%/\", \"\")
   return good_path
end"]
// END RANK codeblock_70

section_9 -> { header_79 prose_80 prose_81 codeblock_82}
{rank=same; header_79 prose_80 prose_81 codeblock_82}

header_79 [label="3 : compileDeck(deck)"]

prose_80 [label="prose"]

prose_81 [label="prose"]

codeblock_82 [label="code block 104-142"]


// END RANK section_9

header_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** compileDeck(deck)"]
// END RANK header_79

prose_80 -> { raw_84}
{rank=same; raw_84}

raw_84 [label="raw"]


// END RANK prose_80

raw_84 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Compiles a deck to bytecode. The deck must be knitted first.
"]
// END RANK raw_84

prose_81 -> { raw_86 prespace_87 literal_88 raw_89 prespace_90 literal_91 raw_92}
{rank=same; raw_86 prespace_87 literal_88 raw_89 prespace_90 literal_91 raw_92}

raw_86 [label="raw"]

prespace_87 [label="prespace"]

literal_88 [label="literal"]

raw_89 [label="raw"]

prespace_90 [label="prespace"]

literal_91 [label="literal"]

raw_92 [label="raw"]


// END RANK prose_81

raw_86 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Returns ("]
// END RANK raw_86

prespace_87 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_87

literal_88 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
// END RANK literal_88

raw_89 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or"]
// END RANK raw_89

prespace_90 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_90

literal_91 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="false"]
// END RANK literal_91

raw_92 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" ), the number of errors, and an array of strings
representing all files which didn't compile.
"]
// END RANK raw_92

codeblock_82 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Compile = {}
local dump = string.dump

local function compileDeck(deck)
   local codex = deck.codex
   s:verb (\"codex project is \" .. codex.project)
   local complete, errnum, errs = true, 0, {}
   deck.bytecodes = deck.bytecodes or {}
   for _, subdeck in ipairs(deck) do
      local deck_complete, deck_errnum, deck_errs = compileDeck(subdeck)
      complete = complete and deck_complete
      errnum = errnum + deck_errnum
      splice(errs, nil, deck_errs)
   end
   for name, src in pairs(deck.srcs) do
      local bytecode, err = load(tostring(src), tostring(name))
      if bytecode then
         -- add to srcs
         local byte_str = dump(bytecode)
         local byte_table = {binary = byte_str}
         byte_table.hash = sha(byte_str)
         byte_table.name = _moduleName(name, codex.project)
         codex.bytecodes[name] = byte_table
         deck.bytecodes[name] = byte_table
         s:verb(\"compiled: \" .. codex.project .. \":\" .. byte_table.name)
      else
         s:verb \"error:\"
         s:verb(err)
         complete = false
         errnum = errnum + 1
         errs[#errs + 1] = tostring(name)
      end
   end
   return complete, errnum, errs
end

Compile.compileDeck = compileDeck"]
// END RANK codeblock_82

section_10 -> { header_101 prose_102 codeblock_103 codeblock_104}
{rank=same; header_101 prose_102 codeblock_103 codeblock_104}

header_101 [label="3 : Compile.compileCodex(codex)"]

prose_102 [label="prose"]

codeblock_103 [label="code block 147-153"]

codeblock_104 [label="code block 155-157"]


// END RANK section_10

header_101 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Compile.compileCodex(codex)"]
// END RANK header_101

prose_102 -> { raw_106}
{rank=same; raw_106}

raw_106 [label="raw"]


// END RANK prose_102

raw_106 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_106

codeblock_103 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Compile.compileCodex(codex)
   local complete, errnum, errs = compileDeck(codex.orb)
   loader.commitCodex(loader.open(), codex):close()
   return complete, errnum, errs
end"]
// END RANK codeblock_103

codeblock_104 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Compile"]
// END RANK codeblock_104


}
