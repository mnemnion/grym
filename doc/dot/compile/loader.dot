digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 276"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-244"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6 section_7 section_8 section_9 section_10}
{rank=same; header_2 prose_3 prose_4 section_5 section_6 section_7 section_8 section_9 section_10}

header_2 [label="1 : loader"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 10-30"]

section_6 [label="section: 31-80"]

section_7 [label="section: 125-160"]

section_8 [label="section: 177-198"]

section_9 [label="section: 199-230"]

section_10 [label="section: 245-276"]


// END RANK section_1

header_2 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* loader"]
// END RANK header_2

prose_3 -> { raw_12}
{rank=same; raw_12}

raw_12 [label="raw"]


// END RANK prose_3

raw_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


I'm less than convinced that I've given this the right name.
"]
// END RANK raw_12

prose_4 -> { raw_14 prespace_15 literal_16 raw_17}
{rank=same; raw_14 prespace_15 literal_16 raw_17}

raw_14 [label="raw"]

prespace_15 [label="prespace"]

literal_16 [label="literal"]

raw_17 [label="raw"]


// END RANK prose_4

raw_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Among other things this will have a function for"]
// END RANK raw_14

prespace_15 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_15

literal_16 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="package.loaders"]
// END RANK literal_16

raw_17 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", but this
file will contain everything needed to manipulate modules, including things
needed only by the compiler.
"]
// END RANK raw_17

section_5 -> { header_22 prose_23 codeblock_24 codeblock_25}
{rank=same; header_22 prose_23 codeblock_24 codeblock_25}

header_22 [label="3 : imports"]

prose_23 [label="prose"]

codeblock_24 [label="code block 17-24"]

codeblock_25 [label="code block 26-28"]


// END RANK section_5

header_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** imports"]
// END RANK header_22

prose_23 -> { raw_27 prespace_28 literal_29 raw_30 prespace_31 literal_32 raw_33}
{rank=same; raw_27 prespace_28 literal_29 raw_30 prespace_31 literal_32 raw_33}

raw_27 [label="raw"]

prespace_28 [label="prespace"]

literal_29 [label="literal"]

raw_30 [label="raw"]

prespace_31 [label="prespace"]

literal_32 [label="literal"]

raw_33 [label="raw"]


// END RANK prose_23

raw_27 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

For now, I'm going to use a copy of the sqlite bindings currently living in"]
// END RANK raw_27

prespace_28 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_28

literal_29 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto"]
// END RANK literal_29

raw_30 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  There's a"]
// END RANK raw_30

prespace_31 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_31

literal_32 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlayer"]
// END RANK literal_32

raw_33 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" as well but I don't want to copy-paste generated
code if I can avoid it; the whole point of this exercise is to get the
codebase to where I can reuse projects across modules.
"]
// END RANK raw_33

codeblock_24 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local sql = require \"sqlayer\"
local Dir = require \"walk/directory\"

local sha = require \"sha3\" . sha512

local status = require \"status\" ()"]
// END RANK codeblock_24

codeblock_25 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Loader = {}"]
// END RANK codeblock_25

section_6 -> { header_43 prose_44 section_45 section_46}
{rank=same; header_43 prose_44 section_45 section_46}

header_43 [label="3 : SQL code"]

prose_44 [label="prose"]

section_45 [label="section: 36-80"]

section_46 [label="section: 81-124"]


// END RANK section_6

header_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** SQL code"]
// END RANK header_43

prose_44 -> { raw_48}
{rank=same; raw_48}

raw_48 [label="raw"]


// END RANK prose_44

raw_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Everything we need to create and manipulate the database.

"]
// END RANK raw_48

section_45 -> { header_50 prose_51 codeblock_52}
{rank=same; header_50 prose_51 codeblock_52}

header_50 [label="4 : SQL Loader.load()"]

prose_51 [label="prose"]

codeblock_52 [label="code block 38-78"]


// END RANK section_45

header_50 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** SQL Loader.load()"]
// END RANK header_50

prose_51 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


// END RANK prose_51

raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_54

codeblock_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local create_project_table = [[
CREATE TABLE IF NOT EXISTS project (
   project_id INTEGER PRIMARY KEY AUTOINCREMENT,
   name STRING UNIQUE NOT NULL ON CONFLICT IGNORE,
   repo STRING,
   repo_type STRING DEFAULT 'git',
   repo_alternates STRING,
   home STRING,
   website STRING
);
]]

local create_code_table = [[
CREATE TABLE IF NOT EXISTS code (
   code_id INTEGER PRIMARY KEY AUTOINCREMENT,
   hash TEXT UNIQUE ON CONFLICT IGNORE NOT NULL,
   binary BLOB NOT NULL
);
]]

local create_module_table = [[
CREATE TABLE IF NOT EXISTS module (
   module_id INTEGER PRIMARY KEY AUTOINCREMENT,
   time DATETIME DEFAULT CURRENT_TIMESTAMP,
   snapshot INTEGER DEFAULT 1,
   version STRING DEFAULT 'SNAPSHOT',
   name STRING NOT NULL,
   type STRING DEFAULT 'luaJIT-bytecode',
   branch STRING,
   vc_hash STRING,
   project_id INTEGER NOT NULL,
   code_id INTEGER,
   FOREIGN KEY (project_id)
      REFERENCES project (project_id)
      ON DELETE RESTRICT
   FOREIGN KEY (code_id)
      REFERENCES code (code_id)
);
]]"]
// END RANK codeblock_52

section_46 -> { header_57 prose_58 codeblock_59}
{rank=same; header_57 prose_58 codeblock_59}

header_57 [label="4 : SQL Loader.commitDeck(conn, deck)"]

prose_58 [label="prose"]

codeblock_59 [label="code block 83-122"]


// END RANK section_46

header_57 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** SQL Loader.commitDeck(conn, deck)"]
// END RANK header_57

prose_58 -> { raw_61}
{rank=same; raw_61}

raw_61 [label="raw"]


// END RANK prose_58

raw_61 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_61

codeblock_59 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local blip = 2
local new_project = [[
INSERT INTO project (name, repo, home, website)
VALUES (:name, :repo, :home, :website)
]]

local new_code = [[
INSERT INTO code (hash, binary)
VALUES (:hash, :binary);
]]

local add_module = [[
INSERT INTO module (snapshot, version, name,
                    branch, vc_hash, project_id, code_id)
VALUES (:snapshot, :version, :name, :branch, :vc_hash, :project_id, :code_id);
]]

local get_project_id = [[
SELECT CAST (project.project_id AS REAL) FROM project
WHERE project.name = %s;
]]

local get_code_id_by_hash = [[
SELECT CAST (code.code_id AS REAL) FROM code
WHERE code.hash = %s;
]]

local get_latest_module_code_id = [[
SELECT CAST (module.code_id AS REAL) FROM module
WHERE module.project_id = %d
   AND module.name = %s
ORDER BY module.time DESC LIMIT 1;
]]

local get_latest_module_bytecode = [[
SELECT code.binary FROM code
WHERE code.code_id = %d ;
]]"]
// END RANK codeblock_59

section_7 -> { header_64 prose_65 codeblock_66 section_67}
{rank=same; header_64 prose_65 codeblock_66 section_67}

header_64 [label="3 : Environment Variables"]

prose_65 [label="prose"]

codeblock_66 [label="code block 133-158"]

section_67 [label="section: 161-176"]


// END RANK section_7

header_64 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Environment Variables"]
// END RANK header_64

prose_65 -> { raw_69 link_70 raw_71 prespace_72 literal_73 raw_74 prespace_75 literal_76 raw_77 prespace_78 literal_79 raw_80}
{rank=same; raw_69 link_70 raw_71 prespace_72 literal_73 raw_74 prespace_75 literal_76 raw_77 prespace_78 literal_79 raw_80}

raw_69 [label="raw"]

link_70 [label="link"]

raw_71 [label="raw"]

prespace_72 [label="prespace"]

literal_73 [label="literal"]

raw_74 [label="raw"]

prespace_75 [label="prespace"]

literal_76 [label="literal"]

raw_77 [label="raw"]

prespace_78 [label="prespace"]

literal_79 [label="literal"]

raw_80 [label="raw"]


// END RANK prose_65

raw_69 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Following the "]
// END RANK raw_69

link_70 -> { anchortext_82 url_83}
{rank=same; anchortext_82 url_83}

anchortext_82 [label="anchortext"]

url_83 [label="url"]


// END RANK link_70

anchortext_82 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="XDG Standard"]
// END RANK anchortext_82

url_83 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html"]
// END RANK url_83

raw_71 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label=",
we place the"]
// END RANK raw_71

prespace_72 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_72

literal_73 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge.modules"]
// END RANK literal_73

raw_74 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" database in a place defined first by a user
environment variable, then by"]
// END RANK raw_74

prespace_75 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_75

literal_76 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="XDG_DATA_HOME"]
// END RANK literal_76

raw_77 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", and if neither is defined,
attempt to put it in the default location of"]
// END RANK raw_77

prespace_78 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_78

literal_79 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="XDG_DATA_HOME"]
// END RANK literal_79

raw_80 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", creating it if
necessary.
"]
// END RANK raw_80

codeblock_66 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local home_dir = os.getenv \"HOME\"
local bridge_modules = os.getenv \"BRIDGE_MODULES\"

if not bridge_modules then
   local xdg_data_home = os.getenv \"XDG_DATA_HOME\"
   if xdg_data_home then
      Dir(xdg_data_home .. \"/bridge/\") : mkdir()
      bridge_modules = xdg_data_home .. \"/bridge/bridge.modules\"
   else
      -- build the whole shebang from scratch, just in case
      -- =mkdir= runs =exists= as the first command so this is
      -- sufficiently clear
      Dir(home_dir .. \"/.local\") : mkdir()
      Dir(home_dir .. \"/.local/share\") : mkdir()
      Dir(home_dir .. \"/.local/share/bridge/\") : mkdir()
      bridge_modules = home_dir .. \"/.local/share/bridge/bridge.modules\"
      -- error out if we haven't made the directory
      local bridge_dir = Dir(home_dir .. \"/.local/share/bridge/\")
      if not bridge_dir:exists() then
         error (\"Could not create ~/.local/share/bridge/,\" ..
               \"consider defining $BRIDGE_MODULES\")
      end
   end
end"]
// END RANK codeblock_66

section_67 -> { header_97 prose_98 codeblock_99}
{rank=same; header_97 prose_98 codeblock_99}

header_97 [label="4 : _unwrapForeignKey(result)"]

prose_98 [label="prose"]

codeblock_99 [label="code block 166-174"]


// END RANK section_67

header_97 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** _unwrapForeignKey(result)"]
// END RANK header_97

prose_98 -> { raw_101}
{rank=same; raw_101}

raw_101 [label="raw"]


// END RANK prose_98

raw_101 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Just peeling off layers here.  I realize there are more sophisticated ways to
do almost everything but for now this will get us where we're going.
"]
// END RANK raw_101

codeblock_99 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _unwrapForeignKey(result)
   if result and result[1] and result[1][1] then
      return result[1][1]
   else
      return nil
   end
end"]
// END RANK codeblock_99

section_8 -> { header_104 prose_105 codeblock_106}
{rank=same; header_104 prose_105 codeblock_106}

header_104 [label="3 : Loader.load()"]

prose_105 [label="prose"]

codeblock_106 [label="code block 181-196"]


// END RANK section_8

header_104 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.load()"]
// END RANK header_104

prose_105 -> { raw_108 prespace_109 literal_110 raw_111}
{rank=same; raw_108 prespace_109 literal_110 raw_111}

raw_108 [label="raw"]

prespace_109 [label="prespace"]

literal_110 [label="literal"]

raw_111 [label="raw"]


// END RANK prose_105

raw_108 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Loads the"]
// END RANK raw_108

prespace_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_109

literal_110 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge.modules"]
// END RANK literal_110

raw_111 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" database and returns the SQLite connection.
"]
// END RANK raw_111

codeblock_106 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Loader.load()
   local new = not (File(bridge_modules) : exists())
   if new then
      print \"creating new bridge.modules\"
   end
   local conn = sql.open(bridge_modules)
   -- #todo: turn on foreign_keys pragma when we add sqlayer
   if new then
      conn:exec(create_project_table)
      conn:exec(create_code_table)
      conn:exec(create_module_table)
   end
   return conn
end"]
// END RANK codeblock_106

section_9 -> { header_117 prose_118 prose_119 codeblock_120 section_121}
{rank=same; header_117 prose_118 prose_119 codeblock_120 section_121}

header_117 [label="3 : Loader.commitModule(conn, bytecode, deck)"]

prose_118 [label="prose"]

prose_119 [label="prose"]

codeblock_120 [label="code block 207-228"]

section_121 [label="section: 231-244"]


// END RANK section_9

header_117 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.commitModule(conn, bytecode, deck)"]
// END RANK header_117

prose_118 -> { raw_123}
{rank=same; raw_123}

raw_123 [label="raw"]


// END RANK prose_118

raw_123 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Commits a single module and associated bytecode.
"]
// END RANK raw_123

prose_119 -> { raw_125 prespace_126 literal_127 raw_128}
{rank=same; raw_125 prespace_126 literal_127 raw_128}

raw_125 [label="raw"]

prespace_126 [label="prespace"]

literal_127 [label="literal"]

raw_128 [label="raw"]


// END RANK prose_119

raw_125 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It might be smarter to fetch all hashes associated with the project first, and
only commit ones which aren't on the list, but it's definitely easier to just
commit everything and let the"]
// END RANK raw_125

prespace_126 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_126

literal_127 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ON CONFLICT IGNORE"]
// END RANK literal_127

raw_128 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" prevent duplication.
"]
// END RANK raw_128

codeblock_120 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function commitModule(conn, bytecode, project_id)
   -- upsert code.binary and code.hash
   conn:prepare(new_code):bindkv(bytecode):step()
   -- select code_id
   local code_id = _unwrapForeignKey(conn:exec(
                                        sql.format(get_code_id_by_hash,
                                                   bytecode.hash)))
   if not code_id then
      error(\"code_id not found for \" .. bytecode.name)
   end
   local mod = { name = bytecode.name,
                    project_id = project_id,
                    code_id = code_id,
                    snapshot = 1,
                    vc_hash = \"\",
                    version = \"SNAPSHOT\" }
   conn:prepare(add_module):bindkv(mod):step()
end

Loader.commitModule = commitModule"]
// END RANK codeblock_120

section_121 -> { header_134 prose_135 codeblock_136}
{rank=same; header_134 prose_135 codeblock_136}

header_134 [label="4 : _newProject(conn, project)"]

prose_135 [label="prose"]

codeblock_136 [label="code block 233-242"]


// END RANK section_121

header_134 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** _newProject(conn, project)"]
// END RANK header_134

prose_135 -> { raw_138}
{rank=same; raw_138}

raw_138 [label="raw"]


// END RANK prose_135

raw_138 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_138

codeblock_136 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _newProject(conn, project)
   assert(project.name, \"project must have a name\")
   project.repo = project.repo or \"\"
   project.home = project.home or \"\"
   project.website = project.website or \"\"
   conn:prepare(new_project):bindkv(project):step()
   return true
end"]
// END RANK codeblock_136

section_10 -> { header_141 prose_142 codeblock_143 codeblock_144}
{rank=same; header_141 prose_142 codeblock_143 codeblock_144}

header_141 [label="3 : Loader.commitCodex(conn, codex)"]

prose_142 [label="prose"]

codeblock_143 [label="code block 247-271"]

codeblock_144 [label="code block 274-276"]


// END RANK section_10

header_141 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.commitCodex(conn, codex)"]
// END RANK header_141

prose_142 -> { raw_146}
{rank=same; raw_146}

raw_146 [label="raw"]


// END RANK prose_142

raw_146 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_146

codeblock_143 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Loader.commitCodex(conn, codex)
   -- begin transaction
   conn:exec \"BEGIN TRANSACTION;\"
   -- upsert project
   -- select project_id
   local get_proj = sql.format(get_project_id, codex.project)
   local project_id = _unwrapForeignKey(conn:exec(get_proj))
   if project_id then
      print (\"project_id is \" .. project_id)
   else
      _newProject(conn, {name = codex.project})
      project_id = _unwrapForeignKey(conn:exec(get_proj))
      if not project_id then
         error (\"failed to create project \" .. codex.project)
      end
   end
   for _, bytecode in pairs(codex.bytecodes) do
      commitModule(conn, bytecode, project_id)
   end
   -- commit transaction
   conn:exec \"COMMIT;\"
   return conn
end"]
// END RANK codeblock_143

codeblock_144 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Loader"]
// END RANK codeblock_144


}
