digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 387"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-364"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}
{rank=same; header_2 prose_3 prose_4 section_5 section_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}

header_2 [label="1 : loader"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 10-30"]

section_6 [label="section: 31-81"]

section_7 [label="section: 133-150"]

section_8 [label="section: 151-186"]

section_9 [label="section: 203-224"]

section_10 [label="section: 225-256"]

section_11 [label="section: 271-299"]

section_12 [label="section: 300-364"]

section_13 [label="section: 365-387"]


// END RANK section_1

header_2 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* loader"]
// END RANK header_2

prose_3 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_3

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


I'm less than convinced that I've given this the right name.
"]
// END RANK raw_15

prose_4 -> { raw_17 prespace_18 literal_19 raw_20}
{rank=same; raw_17 prespace_18 literal_19 raw_20}

raw_17 [label="raw"]

prespace_18 [label="prespace"]

literal_19 [label="literal"]

raw_20 [label="raw"]


// END RANK prose_4

raw_17 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Among other things this will have a function for"]
// END RANK raw_17

prespace_18 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_18

literal_19 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="package.loaders"]
// END RANK literal_19

raw_20 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", but this
file will contain everything needed to manipulate modules, including things
needed only by the compiler.
"]
// END RANK raw_20

section_5 -> { header_25 prose_26 codeblock_27 codeblock_28}
{rank=same; header_25 prose_26 codeblock_27 codeblock_28}

header_25 [label="3 : imports"]

prose_26 [label="prose"]

codeblock_27 [label="code block 17-24"]

codeblock_28 [label="code block 26-28"]


// END RANK section_5

header_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** imports"]
// END RANK header_25

prose_26 -> { raw_30 prespace_31 literal_32 raw_33 prespace_34 literal_35 raw_36}
{rank=same; raw_30 prespace_31 literal_32 raw_33 prespace_34 literal_35 raw_36}

raw_30 [label="raw"]

prespace_31 [label="prespace"]

literal_32 [label="literal"]

raw_33 [label="raw"]

prespace_34 [label="prespace"]

literal_35 [label="literal"]

raw_36 [label="raw"]


// END RANK prose_26

raw_30 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

For now, I'm going to use a copy of the sqlite bindings currently living in"]
// END RANK raw_30

prespace_31 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_31

literal_32 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto"]
// END RANK literal_32

raw_33 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  There's a"]
// END RANK raw_33

prespace_34 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_34

literal_35 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlayer"]
// END RANK literal_35

raw_36 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" as well but I don't want to copy-paste generated
code if I can avoid it; the whole point of this exercise is to get the
codebase to where I can reuse projects across modules.
"]
// END RANK raw_36

codeblock_27 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local sql = assert(sql, \"must have sql in bridge _G\")
local Dir = require \"walk/directory\"

local sha = require \"sha3\" . sha512

local status = require \"status\" ()"]
// END RANK codeblock_27

codeblock_28 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Loader = {}"]
// END RANK codeblock_28

section_6 -> { header_46 prose_47 section_48 section_49}
{rank=same; header_46 prose_47 section_48 section_49}

header_46 [label="3 : SQL code"]

prose_47 [label="prose"]

section_48 [label="section: 36-81"]

section_49 [label="section: 82-132"]


// END RANK section_6

header_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** SQL code"]
// END RANK header_46

prose_47 -> { raw_51}
{rank=same; raw_51}

raw_51 [label="raw"]


// END RANK prose_47

raw_51 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Everything we need to create and manipulate the database.

"]
// END RANK raw_51

section_48 -> { header_53 prose_54 codeblock_55}
{rank=same; header_53 prose_54 codeblock_55}

header_53 [label="4 : SQL Loader.open()"]

prose_54 [label="prose"]

codeblock_55 [label="code block 38-79"]


// END RANK section_48

header_53 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** SQL Loader.open()"]
// END RANK header_53

prose_54 -> { raw_57}
{rank=same; raw_57}

raw_57 [label="raw"]


// END RANK prose_54

raw_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_57

codeblock_55 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local create_project_table = [[
CREATE TABLE IF NOT EXISTS project (
   project_id INTEGER PRIMARY KEY AUTOINCREMENT,
   name STRING UNIQUE NOT NULL ON CONFLICT IGNORE,
   repo STRING,
   repo_type STRING DEFAULT 'git',
   repo_alternates STRING,
   home STRING,
   website STRING
);
]]

local create_code_table = [[
CREATE TABLE IF NOT EXISTS code (
   code_id INTEGER PRIMARY KEY AUTOINCREMENT,
   hash TEXT UNIQUE ON CONFLICT IGNORE NOT NULL,
   binary BLOB NOT NULL
);
]]

local create_module_table = [[
CREATE TABLE IF NOT EXISTS module (
   module_id INTEGER PRIMARY KEY AUTOINCREMENT,
   time DATETIME DEFAULT CURRENT_TIMESTAMP,
   snapshot INTEGER DEFAULT 1,
   version STRING DEFAULT 'SNAPSHOT',
   name STRING NOT NULL,
   type STRING DEFAULT 'luaJIT-bytecode',
   branch STRING,
   vc_hash STRING,
   project_id INTEGER NOT NULL,
   code_id INTEGER,
   FOREIGN KEY (project_id)
      REFERENCES project (project_id)
      ON DELETE RESTRICT
   FOREIGN KEY (code_id)
      REFERENCES code (code_id)
      ON DELETE CASCADE
);
]]"]
// END RANK codeblock_55

section_49 -> { header_60 prose_61 codeblock_62}
{rank=same; header_60 prose_61 codeblock_62}

header_60 [label="4 : SQL Loader.commitDeck(conn, deck)"]

prose_61 [label="prose"]

codeblock_62 [label="code block 84-130"]


// END RANK section_49

header_60 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** SQL Loader.commitDeck(conn, deck)"]
// END RANK header_60

prose_61 -> { raw_64}
{rank=same; raw_64}

raw_64 [label="raw"]


// END RANK prose_61

raw_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_64

codeblock_62 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new_project = [[
INSERT INTO project (name, repo, home, website)
VALUES (:name, :repo, :home, :website)
]]

local new_code = [[
INSERT INTO code (hash, binary)
VALUES (:hash, :binary);
]]

local add_module = [[
INSERT INTO module (snapshot, version, name,
                    branch, vc_hash, project_id, code_id)
VALUES (:snapshot, :version, :name, :branch, :vc_hash, :project_id, :code_id);
]]

local get_project_id = [[
SELECT CAST (project.project_id AS REAL) FROM project
WHERE project.name = %s;
]]

local get_code_id_by_hash = [[
SELECT CAST (code.code_id AS REAL) FROM code
WHERE code.hash = %s;
]]

local get_latest_module_code_id = [[
SELECT CAST (module.code_id AS REAL) FROM module
WHERE module.project_id = %d
   AND module.name = %s
ORDER BY module.time DESC LIMIT 1;
]]

local get_all_module_ids = [[
SELECT CAST (module.code_id AS REAL),
       CAST (module.project_id AS REAL)
FROM module
WHERE module.name = %s
ORDER BY module.time DESC;
]]

local get_latest_module_bytecode = [[
SELECT code.binary FROM code
WHERE code.code_id = %d ;
]]"]
// END RANK codeblock_62

section_7 -> { header_67 prose_68 codeblock_69}
{rank=same; header_67 prose_68 codeblock_69}

header_67 [label="3 : SQL loader.load(conn, mod_name)"]

prose_68 [label="prose"]

codeblock_69 [label="code block 135-148"]


// END RANK section_7

header_67 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** SQL loader.load(conn, mod_name)"]
// END RANK header_67

prose_68 -> { raw_71}
{rank=same; raw_71}

raw_71 [label="raw"]


// END RANK prose_68

raw_71 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_71

codeblock_69 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local get_code_id_for_module_project = [[
SELECT
   CAST (module.code_id AS REAL) FROM module
WHERE module.project_id = %d
   AND module.name = %s
ORDER BY module.time DESC LIMIT 1;
]]

local get_bytecode = [[
SELECT code.binary FROM code
WHERE code.code_id = %d ;
]]"]
// END RANK codeblock_69

section_8 -> { header_74 prose_75 codeblock_76 section_77}
{rank=same; header_74 prose_75 codeblock_76 section_77}

header_74 [label="3 : Environment Variables"]

prose_75 [label="prose"]

codeblock_76 [label="code block 159-184"]

section_77 [label="section: 187-202"]


// END RANK section_8

header_74 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Environment Variables"]
// END RANK header_74

prose_75 -> { raw_79 link_80 raw_81 prespace_82 literal_83 raw_84 prespace_85 literal_86 raw_87 prespace_88 literal_89 raw_90}
{rank=same; raw_79 link_80 raw_81 prespace_82 literal_83 raw_84 prespace_85 literal_86 raw_87 prespace_88 literal_89 raw_90}

raw_79 [label="raw"]

link_80 [label="link"]

raw_81 [label="raw"]

prespace_82 [label="prespace"]

literal_83 [label="literal"]

raw_84 [label="raw"]

prespace_85 [label="prespace"]

literal_86 [label="literal"]

raw_87 [label="raw"]

prespace_88 [label="prespace"]

literal_89 [label="literal"]

raw_90 [label="raw"]


// END RANK prose_75

raw_79 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Following the "]
// END RANK raw_79

link_80 -> { anchortext_92 url_93}
{rank=same; anchortext_92 url_93}

anchortext_92 [label="anchortext"]

url_93 [label="url"]


// END RANK link_80

anchortext_92 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="XDG Standard"]
// END RANK anchortext_92

url_93 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html"]
// END RANK url_93

raw_81 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label=",
we place the"]
// END RANK raw_81

prespace_82 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_82

literal_83 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge.modules"]
// END RANK literal_83

raw_84 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" database in a place defined first by a user
environment variable, then by"]
// END RANK raw_84

prespace_85 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_85

literal_86 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="XDG_DATA_HOME"]
// END RANK literal_86

raw_87 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", and if neither is defined,
attempt to put it in the default location of"]
// END RANK raw_87

prespace_88 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_88

literal_89 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="XDG_DATA_HOME"]
// END RANK literal_89

raw_90 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", creating it if
necessary.
"]
// END RANK raw_90

codeblock_76 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local home_dir = os.getenv \"HOME\"
local bridge_modules = os.getenv \"BRIDGE_MODULES\"

if not bridge_modules then
   local xdg_data_home = os.getenv \"XDG_DATA_HOME\"
   if xdg_data_home then
      Dir(xdg_data_home .. \"/bridge/\") : mkdir()
      bridge_modules = xdg_data_home .. \"/bridge/bridge.modules\"
   else
      -- build the whole shebang from scratch, just in case
      -- =mkdir= runs =exists= as the first command so this is
      -- sufficiently clear
      Dir(home_dir .. \"/.local\") : mkdir()
      Dir(home_dir .. \"/.local/share\") : mkdir()
      Dir(home_dir .. \"/.local/share/bridge/\") : mkdir()
      bridge_modules = home_dir .. \"/.local/share/bridge/bridge.modules\"
      -- error out if we haven't made the directory
      local bridge_dir = Dir(home_dir .. \"/.local/share/bridge/\")
      if not bridge_dir:exists() then
         error (\"Could not create ~/.local/share/bridge/,\" ..
               \"consider defining $BRIDGE_MODULES\")
      end
   end
end"]
// END RANK codeblock_76

section_77 -> { header_107 prose_108 codeblock_109}
{rank=same; header_107 prose_108 codeblock_109}

header_107 [label="4 : _unwrapForeignKey(result)"]

prose_108 [label="prose"]

codeblock_109 [label="code block 192-200"]


// END RANK section_77

header_107 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** _unwrapForeignKey(result)"]
// END RANK header_107

prose_108 -> { raw_111}
{rank=same; raw_111}

raw_111 [label="raw"]


// END RANK prose_108

raw_111 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Just peeling off layers here.  I realize there are more sophisticated ways to
do almost everything but for now this will get us where we're going.
"]
// END RANK raw_111

codeblock_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _unwrapForeignKey(result)
   if result and result[1] and result[1][1] then
      return result[1][1]
   else
      return nil
   end
end"]
// END RANK codeblock_109

section_9 -> { header_114 prose_115 codeblock_116}
{rank=same; header_114 prose_115 codeblock_116}

header_114 [label="3 : Loader.open()"]

prose_115 [label="prose"]

codeblock_116 [label="code block 207-222"]


// END RANK section_9

header_114 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.open()"]
// END RANK header_114

prose_115 -> { raw_118 prespace_119 literal_120 raw_121}
{rank=same; raw_118 prespace_119 literal_120 raw_121}

raw_118 [label="raw"]

prespace_119 [label="prespace"]

literal_120 [label="literal"]

raw_121 [label="raw"]


// END RANK prose_115

raw_118 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Loads the"]
// END RANK raw_118

prespace_119 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_119

literal_120 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge.modules"]
// END RANK literal_120

raw_121 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" database and returns the SQLite connection.
"]
// END RANK raw_121

codeblock_116 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Loader.open()
   local new = not (File(bridge_modules) : exists())
   if new then
      print \"creating new bridge.modules\"
   end
   local conn = sql.open(bridge_modules)
   -- #todo: turn on foreign_keys pragma when we add sqlayer
   if new then
      conn:exec(create_project_table)
      conn:exec(create_code_table)
      conn:exec(create_module_table)
   end
   return conn
end"]
// END RANK codeblock_116

section_10 -> { header_127 prose_128 prose_129 codeblock_130 section_131}
{rank=same; header_127 prose_128 prose_129 codeblock_130 section_131}

header_127 [label="3 : Loader.commitModule(conn, bytecode, deck)"]

prose_128 [label="prose"]

prose_129 [label="prose"]

codeblock_130 [label="code block 233-254"]

section_131 [label="section: 257-270"]


// END RANK section_10

header_127 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.commitModule(conn, bytecode, deck)"]
// END RANK header_127

prose_128 -> { raw_133}
{rank=same; raw_133}

raw_133 [label="raw"]


// END RANK prose_128

raw_133 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Commits a single module and associated bytecode.
"]
// END RANK raw_133

prose_129 -> { raw_135 prespace_136 literal_137 raw_138}
{rank=same; raw_135 prespace_136 literal_137 raw_138}

raw_135 [label="raw"]

prespace_136 [label="prespace"]

literal_137 [label="literal"]

raw_138 [label="raw"]


// END RANK prose_129

raw_135 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It might be smarter to fetch all hashes associated with the project first, and
only commit ones which aren't on the list, but it's definitely easier to just
commit everything and let the"]
// END RANK raw_135

prespace_136 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_136

literal_137 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ON CONFLICT IGNORE"]
// END RANK literal_137

raw_138 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" prevent duplication.
"]
// END RANK raw_138

codeblock_130 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function commitModule(conn, bytecode, project_id)
   -- upsert code.binary and code.hash
   conn:prepare(new_code):bindkv(bytecode):step()
   -- select code_id
   local code_id = _unwrapForeignKey(conn:exec(
                                        sql.format(get_code_id_by_hash,
                                                   bytecode.hash)))
   if not code_id then
      error(\"code_id not found for \" .. bytecode.name)
   end
   local mod = { name = bytecode.name,
                    project_id = project_id,
                    code_id = code_id,
                    snapshot = 1,
                    vc_hash = \"\",
                    version = \"SNAPSHOT\" }
   conn:prepare(add_module):bindkv(mod):step()
end

Loader.commitModule = commitModule"]
// END RANK codeblock_130

section_131 -> { header_144 prose_145 codeblock_146}
{rank=same; header_144 prose_145 codeblock_146}

header_144 [label="4 : _newProject(conn, project)"]

prose_145 [label="prose"]

codeblock_146 [label="code block 259-268"]


// END RANK section_131

header_144 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** _newProject(conn, project)"]
// END RANK header_144

prose_145 -> { raw_148}
{rank=same; raw_148}

raw_148 [label="raw"]


// END RANK prose_145

raw_148 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_148

codeblock_146 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _newProject(conn, project)
   assert(project.name, \"project must have a name\")
   project.repo = project.repo or \"\"
   project.home = project.home or \"\"
   project.website = project.website or \"\"
   conn:prepare(new_project):bindkv(project):step()
   return true
end"]
// END RANK codeblock_146

section_11 -> { header_151 prose_152 codeblock_153}
{rank=same; header_151 prose_152 codeblock_153}

header_151 [label="3 : Loader.commitCodex(conn, codex)"]

prose_152 [label="prose"]

codeblock_153 [label="code block 273-297"]


// END RANK section_11

header_151 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.commitCodex(conn, codex)"]
// END RANK header_151

prose_152 -> { raw_155}
{rank=same; raw_155}

raw_155 [label="raw"]


// END RANK prose_152

raw_155 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_155

codeblock_153 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Loader.commitCodex(conn, codex)
   -- begin transaction
   conn:exec \"BEGIN TRANSACTION;\"
   -- upsert project
   -- select project_id
   local get_proj = sql.format(get_project_id, codex.project)
   local project_id = _unwrapForeignKey(conn:exec(get_proj))
   if project_id then
      print (\"project_id is \" .. project_id)
   else
      _newProject(conn, {name = codex.project})
      project_id = _unwrapForeignKey(conn:exec(get_proj))
      if not project_id then
         error (\"failed to create project \" .. codex.project)
      end
   end
   for _, bytecode in pairs(codex.bytecodes) do
      commitModule(conn, bytecode, project_id)
   end
   -- commit transaction
   conn:exec \"COMMIT;\"
   return conn
end"]
// END RANK codeblock_153

section_12 -> { header_158 prose_159 codeblock_160}
{rank=same; header_158 prose_159 codeblock_160}

header_158 [label="3 : Loader.load(conn, mod_name)"]

prose_159 [label="prose"]

codeblock_160 [label="code block 304-362"]


// END RANK section_12

header_158 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.load(conn, mod_name)"]
// END RANK header_158

prose_159 -> { raw_162}
{rank=same; raw_162}

raw_162 [label="raw"]


// END RANK prose_159

raw_162 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Load a module given its name and a given database conn.
"]
// END RANK raw_162

codeblock_160 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local match = string.match

local function _loadModule(conn, mod_name)
   assert(type(mod_name) == \"string\", \"mod_name must be a string\")
   -- split the module into project and modname
   local project, mod = match(mod_name, \"(.*):(.*)\")
   if not mod then
      mod = mod_name
   end
   local code_id = nil
   if project then
      -- retrieve module name by project
      local project_id = _unwrapForeignKey(
                            conn:exec(
                            sql.format(get_project_id, project)))
      if not project_id then
         return nil
      end
      code_id = _unwrapForeignKey(
                         conn:exec(
                         sql.format(get_code_id_for_module_project,
                                    project_id, mod)))
   else
      -- retrieve by bare module name
      local foreign_keys = conn:exec(sql.format(get_all_module_ids, mod))
      if foreign_keys == nil then
         return nil
      else
         -- iterate through project_ids to check if we have more than one
         -- project with the same module name
         local p_id = foreign_keys[2][1]
         local same_project = true
         for i = 2, #foreign_keys[2] do
            same_project = same_project and p_id == foreign_keys[2][i]
         end
         if not same_project then
            package.warning = package.warning or {}
            table.insert(package.warning,
               \"warning: multiple projects contain a module called \" .. mod)
         end
         code_id = foreign_keys[1][1]
      end
   end
   if not code_id then
      return nil
   end
   local bytecode = _unwrapForeignKey(
                           conn:exec(
                           sql.format(get_bytecode, code_id)))
   if bytecode then
      return load(bytecode)
   else
      return nil
   end
end

Loader.load = _loadModule"]
// END RANK codeblock_160

section_13 -> { header_165 prose_166 structure_167 prose_168 codeblock_169 codeblock_170}
{rank=same; header_165 prose_166 structure_167 prose_168 codeblock_169 codeblock_170}

header_165 [label="3 : Loader.loaderGen()"]

prose_166 [label="prose"]

structure_167 [label="structure"]

prose_168 [label="prose"]

codeblock_169 [label="code block 376-383"]

codeblock_170 [label="code block 385-387"]


// END RANK section_13

header_165 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Loader.loaderGen()"]
// END RANK header_165

prose_166 -> { raw_172}
{rank=same; raw_172}

raw_172 [label="raw"]


// END RANK prose_166

raw_172 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Closes over the conn and returns a loader which can use it.
"]
// END RANK raw_172

structure_167 -> { hashline_174}
{rank=same; hashline_174}

hashline_174 [label="hashline"]


// END RANK structure_167

hashline_174 -> { hashtag_175}
{rank=same; hashtag_175}

hashtag_175 [label="hashtag"]


// END RANK hashline_174

hashtag_175 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Todo"]
// END RANK hashtag_175

prose_168 -> { raw_177}
{rank=same; raw_177}

raw_177 [label="raw"]


// END RANK prose_168

raw_177 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
exit, and setting this up in LuaJIT is moderately complex, so just going to
punt on this for now.
"]
// END RANK raw_177

codeblock_169 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Loader.loaderGen()
   local conn = Loader.open()
   return function(mod_name)
      return _loadModule(conn, mod_name)
   end
end"]
// END RANK codeblock_169

codeblock_170 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Loader"]
// END RANK codeblock_170


}
