digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 422"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-383"]


section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}

header_2 [label="1 : Section metatable"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

section_7 [label="section: 16-21"]

section_8 [label="section: 22-29"]

section_9 [label="section: 47-79"]

section_10 [label="section: 128-171"]

section_11 [label="section: 209-222"]

section_12 [label="section: 366-383"]

section_13 [label="section: 384-422"]


prose_3 -> { raw_14}
{rank=same; raw_14}

raw_14 [label="raw"]


raw_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


   Sections consist of a header and body.  The body may contain
 one or more blocks, followed by zero or more child sections.
"]
prose_4 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 The header and block may both be virtual, but will always be
 present.
"]
prose_5 -> { raw_18}
{rank=same; raw_18}

raw_18 [label="raw"]


raw_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 In the first pass, we fill a lines array with the raw
 contents of the section. 
"]
prose_6 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 This is subsequently refined into various blocks. 

"]
section_7 -> { header_22 prose_23}
{rank=same; header_22 prose_23}

header_22 [label="2 : Array"]

prose_23 [label="prose"]


prose_23 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   The array portion of a section starts at [1] with a header. The
 rest consists, optionally, of nodes of types Block and Section.

"]
section_8 -> { header_26 prose_27 section_28}
{rank=same; header_26 prose_27 section_28}

header_26 [label="2 : Fields"]

prose_27 [label="prose"]

section_28 [label="section: 30-46"]


prose_27 -> { raw_29}
{rank=same; raw_29}

raw_29 [label="raw"]


raw_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 - header : The header for the section.
 - level : The header level, lifted from the header for ease of use
 - lines : An array of the lines owned by the section. Note that 
           this doesn't include the header. 

"]
section_28 -> { header_31 prose_32 codeblock_33}
{rank=same; header_31 prose_32 codeblock_33}

header_31 [label="3 : Includes"]

prose_32 [label="prose"]

codeblock_33 [label="code block 32-44"]


prose_32 -> { raw_34}
{rank=same; raw_34}

raw_34 [label="raw"]


raw_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_33 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"util\"
local status = require \"status\"

local Node = require \"node/node\"

local Header = require \"grym/header\"
local Block = require \"grym/block\"
local Codeblock = require \"grym/codeblock\"
local m = require \"grym/morphemes\""]
section_9 -> { header_37 prose_38 codeblock_39 section_40 section_41 section_42}
{rank=same; header_37 prose_38 codeblock_39 section_40 section_41 section_42}

header_37 [label="2 : Metatable for sections"]

prose_38 [label="prose"]

codeblock_39 [label="code block 49-53"]

section_40 [label="section: 55-65"]

section_41 [label="section: 66-79"]

section_42 [label="section: 80-102"]


prose_38 -> { raw_43}
{rank=same; raw_43}

raw_43 [label="raw"]


raw_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_39 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Sec, sec = u.inherit(Node)
Sec.id = \"section\"
"]
section_40 -> { header_46 prose_47 codeblock_48}
{rank=same; header_46 prose_47 codeblock_48}

header_46 [label="3 : __tostring"]

prose_47 [label="prose"]

codeblock_48 [label="code block 59-63"]


prose_47 -> { raw_49}
{rank=same; raw_49}

raw_49 [label="raw"]


raw_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We just return the repr of the header.
"]
codeblock_48 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.__tostring(section)
    return tostring(section[1])
end"]
section_41 -> { header_52 prose_53 prose_54 codeblock_55}
{rank=same; header_52 prose_53 prose_54 codeblock_55}

header_52 [label="3 : dotLabel(section)"]

prose_53 [label="prose"]

prose_54 [label="prose"]

codeblock_55 [label="code block 72-77"]


prose_53 -> { raw_56}
{rank=same; raw_56}

raw_56 [label="raw"]


raw_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Produces a label for a dotfile.
"]
prose_54 -> { raw_58}
{rank=same; raw_58}

raw_58 [label="raw"]


raw_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return : string in dot format.
"]
codeblock_55 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.dotLabel(section)
    return \"section: \" .. tostring(section.line_first) 
        .. \"-\" .. tostring(section.line_last)
end"]
section_42 -> { header_61 prose_62 prose_63 prose_64 codeblock_65 section_66}
{rank=same; header_61 prose_62 prose_63 prose_64 codeblock_65 section_66}

header_61 [label="3 : toMarkdown(section)"]

prose_62 [label="prose"]

prose_63 [label="prose"]

prose_64 [label="prose"]

codeblock_65 [label="code block 88-101"]

section_66 [label="section: 103-127"]


prose_62 -> { raw_67}
{rank=same; raw_67}

raw_67 [label="raw"]


raw_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Translates the Section to markdown.
"]
prose_63 -> { raw_69}
{rank=same; raw_69}

raw_69 [label="raw"]


raw_69 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section: the Section.
"]
prose_64 -> { raw_71}
{rank=same; raw_71}

raw_71 [label="raw"]


raw_71 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return: A Markdown string.  
"]
codeblock_65 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.toMarkdown(section)
    local phrase = \"\"
    for _, node in ipairs(section) do
        if node.toMarkdown then
            phrase = phrase .. node:toMarkdown()
        else 
            u.freeze(\"no toMarkdown method in \" .. node.id)
        end
    end

    return phrase
end"]
section_66 -> { header_74 prose_75 codeblock_76}
{rank=same; header_74 prose_75 codeblock_76}

header_74 [label="4 : asserts"]

prose_75 [label="prose"]

codeblock_76 [label="code block 105-125"]


prose_75 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_76 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.check(section)
    for i, v in ipairs(section) do
        if (i == 1) then
            if section.header then
                assert(v.id == \"header\")
            end
        else
            assert(v.id == \"section\" or v.id == \"block\")
        end
    end
    assert(section.level)
    assert(section.id == \"section\")
    assert(section.first, \"no first in \" .. tostring(section))
    assert(section.last, \"no last in \" .. tostring(section))
    assert(section.str, \"no str in \" .. tostring(section))
    assert(section.lines)
    assert(section.line_first)
    assert(section.line_last)
end"]
section_10 -> { header_80 prose_81 prose_82 prose_83 codeblock_84 section_85 section_86}
{rank=same; header_80 prose_81 prose_82 prose_83 codeblock_84 section_85 section_86}

header_80 [label="2 : addLine(section, line) "]

prose_81 [label="prose"]

prose_82 [label="prose"]

prose_83 [label="prose"]

codeblock_84 [label="code block 141-146"]

section_85 [label="section: 149-171"]

section_86 [label="section: 172-246"]


prose_81 -> { raw_87}
{rank=same; raw_87}

raw_87 [label="raw"]


raw_87 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Add a line to a section.
"]
prose_82 -> { raw_89}
{rank=same; raw_89}

raw_89 [label="raw"]


raw_89 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
These lines are later translated into blocks, and when the
parser is mature, =section.line= will be set to nil before
the Doc is returned.  
 
- section: the section
- line: the line
"]
prose_83 -> { raw_91}
{rank=same; raw_91}

raw_91 [label="raw"]


raw_91 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- return : the section
"]
codeblock_84 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.addLine(section, line)
    section.lines[#section.lines + 1] = line
    return section
end"]
section_85 -> { header_94 prose_95 prose_96 prose_97 codeblock_98}
{rank=same; header_94 prose_95 prose_96 prose_97 codeblock_98}

header_94 [label="3 : addSection(section, newsection, linum)"]

prose_95 [label="prose"]

prose_96 [label="prose"]

prose_97 [label="prose"]

codeblock_98 [label="code block 159-169"]


prose_95 -> { raw_99}
{rank=same; raw_99}

raw_99 [label="raw"]


raw_99 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Adds a section to the host section
"]
prose_96 -> { raw_101}
{rank=same; raw_101}

raw_101 [label="raw"]


raw_101 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section:  Section to contain the new section.
- newsection:  The new section.
- linum:  The line number.
"]
prose_97 -> { raw_103}
{rank=same; raw_103}

raw_103 [label="raw"]


raw_103 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return: the parent section.
"]
codeblock_98 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.addSection(section, newsection, linum, finish)
    if linum > 0 then
        section.line_last = linum - 1
        assert(type(finish) == \"number\")
        section.last = finish
    end
    section[#section + 1] = newsection
    return section
end"]
section_86 -> { header_106 prose_107 codeblock_108 prose_109 prose_110 prose_111 codeblock_112 section_113 section_114 section_115 section_116}
{rank=same; header_106 prose_107 codeblock_108 prose_109 prose_110 prose_111 codeblock_112 section_113 section_114 section_115 section_116}

header_106 [label="3 : Helper Functions for Blocking"]

prose_107 [label="prose"]

codeblock_108 [label="code block 176-180"]

prose_109 [label="prose"]

prose_110 [label="prose"]

prose_111 [label="prose"]

codeblock_112 [label="code block 190-207"]

section_113 [label="section: 229-234"]

section_114 [label="section: 235-239"]

section_115 [label="section: 240-246"]

section_116 [label="section: 247-365"]


prose_107 -> { raw_117}
{rank=same; raw_117}

raw_117 [label="raw"]


raw_117 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Boolean match for a tagline
"]
codeblock_108 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function isTagline(line)
    return L.match(m.tagline_p, line)
end"]
prose_109 -> { raw_120}
{rank=same; raw_120}

raw_120 [label="raw"]


raw_120 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Lookahead, counting blank lines, return the number.
"]
prose_110 -> { raw_122}
{rank=same; raw_122}

raw_122 [label="raw"]


raw_122 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines: the full lines array of the section
- linum: current index into lines
"]
prose_111 -> { raw_124}
{rank=same; raw_124}

raw_124 [label="raw"]


raw_124 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- returns: number of blank lines forward of index
"]
codeblock_112 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fwdBlanks(lines, linum)
    local fwd = 0
    local index = linum + 1
    if index > #lines then 
        return 0
    else 
        for i = index, #lines do
            if lines[i] == \"\" then
                fwd = fwd + 1
            else
                break
            end
        end
    end
    return fwd
end"]
section_113 -> { header_127 prose_128}
{rank=same; header_127 prose_128}

header_127 [label="4 : List line"]

prose_128 [label="prose"]


prose_128 -> { raw_129}
{rank=same; raw_129}

raw_129 [label="raw"]


raw_129 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

New block unless previous line is also list,
in which case append. 

"]
section_114 -> { header_131 prose_132}
{rank=same; header_131 prose_132}

header_131 [label="4 : Table line"]

prose_132 [label="prose"]


prose_132 -> { raw_133}
{rank=same; raw_133}

raw_133 [label="raw"]


raw_133 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Same as list.

"]
section_115 -> { header_135 prose_136}
{rank=same; header_135 prose_136}

header_135 [label="4 : Tag line "]

prose_136 [label="prose"]


prose_136 -> { raw_137}
{rank=same; raw_137}

raw_137 [label="raw"]


raw_137 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A tag needs to cling, so we need to check the
number of blank lines before and after a tag line, if any.
If even, a tag line clings down.

"]
section_116 -> { header_139 prose_140 prose_141 prose_142 codeblock_143}
{rank=same; header_139 prose_140 prose_141 prose_142 codeblock_143}

header_139 [label="4 : Code block"]

prose_140 [label="prose"]

prose_141 [label="prose"]

prose_142 [label="prose"]

codeblock_143 [label="code block 256-364"]


prose_140 -> { raw_144}
{rank=same; raw_144}

raw_144 [label="raw"]


raw_144 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A code block is anything between a code header and
either a code footer or the end of a file. 
"]
prose_141 -> { raw_146}
{rank=same; raw_146}

raw_146 [label="raw"]


raw_146 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section : the Section to be blocked
"]
prose_142 -> { raw_148}
{rank=same; raw_148}

raw_148 [label="raw"]


raw_148 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- returns : the same Section, filled in with blocks
"]
codeblock_143 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.block(section)
    -- There is always a header at [1], though it may be nil
    -- If there are other Nodes, they are sections and must be appended
    -- after the blocks.
    local sub_sections = {}
    for i = 2, #section do
        sub_sections[#sub_sections + 1] = section[i]
        section[i] = nil
    end

    -- Every section gets at least one block, at [2], which may be empty.
    local latest = Block(nil, section.line_first) -- current block
    section[2] = latest

    -- State machine for blocking a section
    local back_blanks = 0
    -- first set of blank lines in a section belong to the first block
    local lead_blanks = true
    -- Track code blocks in own logic
    local code_block = false
    -- Tags also
    local tagging = false
    for i = 1, #section.lines do
        local inset = i + section.line_first
        local l = section.lines[i]
        if not code_block then
            if l == \"\" then 
                -- increment back blanks for clinging subsequent lines
                back_blanks = back_blanks + 1
                -- blank lines attach to the preceding block
                latest:addLine(l)
            else
                local isCodeHeader, level, l_trim = Codeblock.matchHead(l)
                if isCodeHeader then
                    code_block = true
                    if not tagging then
                        -- create a new block for the codeblock
                        latest.line_last = inset - 1
                        latest = Block(nil, inset)
                        latest[1] = Codeblock(level, l_trim, inset)
                        section[#section + 1] = latest
                    else
                        -- preserve existing block and add codeblock
                        tagging = false
                        latest[1] = Codeblock(level, l_trim, inset)
                    end
                elseif isTagline(l) then
                    tagging = true
                    -- apply cling rule
                    local fwd_blanks = fwdBlanks(section.lines, i)
                    if fwd_blanks > back_blanks then
                        latest:addLine(l)
                    else
                        -- new block
                        latest.line_last = inset - 1
                        latest = Block(l, inset)
                        section[#section + 1] = latest
                        back_blanks = 0
                    end                        
                else
                    if back_blanks > 0 and lead_blanks == false then
                        if not tagging then
                        -- new block
                            latest.line_last = inset - 1
                            latest = Block(l, inset)
                            section[#section + 1] = latest
                            back_blanks = 0
                        else
                            latest:addLine(l)
                            tagging = false
                        end 
                    else
                        -- continuing a block
                        lead_blanks = false
                        back_blanks = 0
                        latest:addLine(l)
                    end
                end
            end
        else
            -- Collecting a code block
            local isCodeFoot, level, l_trim = Codeblock.matchFoot(l)
            if (isCodeFoot and level == latest[1].level) then
                code_block = false
                latest[1].footer = l_trim
                latest[1].line_last = inset
            else
                latest[1].lines[#latest[1].lines + 1] = l
            end
            -- Continue in normal parse mode
            -- This may add more lines to the code block
        end
    end
    -- Auto-close a code block with no footer.
    if latest[1] and latest[1].id == \"codeblock\" and not latest[1].line_last then
        latest[1].line_last = #section.lines
    end

    -- Close last block
    latest.line_last = section.line_last

    -- Append sections, if any, which follow our blocks
    for _, v in ipairs(sub_sections) do
        section[#section + 1] = v
    end
    return section
end"]
section_11 -> { header_151 prose_152 prose_153 prose_154 section_155}
{rank=same; header_151 prose_152 prose_153 prose_154 section_155}

header_151 [label="2 : Blocking"]

prose_152 [label="prose"]

prose_153 [label="prose"]

prose_154 [label="prose"]

section_155 [label="section: 223-228"]


prose_152 -> { raw_156}
{rank=same; raw_156}

raw_156 [label="raw"]


raw_156 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Blocks a Section.
"]
prose_153 -> { raw_158}
{rank=same; raw_158}

raw_158 [label="raw"]


raw_158 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is a moderately complex state machine, which
works on a line-by-line basis with some lookahead.
"]
prose_154 -> { raw_160}
{rank=same; raw_160}

raw_160 [label="raw"]


raw_160 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
First off, we have a Header at [1], and may have one or 
more Sections The blocks go between the Header and the remaining
Sections, so we have to lift them and append after blocking.
 
Next, we parse the lines, thus:

"]
section_155 -> { header_162 prose_163}
{rank=same; header_162 prose_163}

header_162 [label="4 : Prose line"]

prose_163 [label="prose"]


prose_163 -> { raw_164}
{rank=same; raw_164}

raw_164 [label="raw"]


raw_164 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If preceded by at least one blank line,
make a new block, otherwise append to existing block.

"]
section_12 -> { header_166 prose_167 codeblock_168}
{rank=same; header_166 prose_167 codeblock_168}

header_166 [label="2 : Section:weed()"]

prose_167 [label="prose"]

codeblock_168 [label="code block 371-381"]


prose_167 -> { raw_169}
{rank=same; raw_169}

raw_169 [label="raw"]


raw_169 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This is a kludgy thing we're going to do to remove 'blocks' once they've
become either codeblocks or prose.
"]
codeblock_168 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.weed(section)
    for i, v in ipairs(section) do
        if v.id == \"block\" then
            if v[1] then
                section[i] = v[1]          
            end
        end
    end
end"]
section_13 -> { header_172 prose_173 prose_174 prose_175 codeblock_176}
{rank=same; header_172 prose_173 prose_174 prose_175 codeblock_176}

header_172 [label="2 : Section(header, linum)"]

prose_173 [label="prose"]

prose_174 [label="prose"]

prose_175 [label="prose"]

codeblock_176 [label="code block 395-421"]


prose_173 -> { raw_177}
{rank=same; raw_177}

raw_177 [label="raw"]


raw_177 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Creates a new section, given a header and the line number.
"]
prose_174 -> { raw_179}
{rank=same; raw_179}

raw_179 [label="raw"]


raw_179 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- header :  Header for the section, which may be of type Header or 
            a number.  A number means the header is virtual.
- linum  :  The line number of the header, which is the first of the
            Section.
"]
prose_175 -> { raw_181}
{rank=same; raw_181}

raw_181 [label="raw"]


raw_181 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- return :  The new Section.
"]
codeblock_176 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Section, header, linum, first, last, str)
    assert(type(first) == \"number\")
    assert(type(last) == \"number\", \"type of last is \" .. type(last))
    local section = setmetatable({}, Sec)
    if type(header) == \"number\" then
        -- We have a virtual header
        section[1] = Header(\"\", header)
        section.header = nil
        section.level = header
    else
        section[1] = header
        section.header = header
        section.level = header.level
    end
    section.str = str
    section.first = first
    section.last = last
    section.line_first = linum
    section.line_last = -1  
    section.lines = {}
    Sec.check(section)
    return section
end

return u.export(sec, new)"]

}
