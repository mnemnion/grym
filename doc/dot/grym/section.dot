digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 412"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-379"]


section_1 -> { header_2}
{rank=same; header_2}

header_2 [label="1 : Section metatable"]


section_3 -> { header_10}
{rank=same; header_10}

header_10 [label="2 : Array"]


section_4 -> { header_11}
{rank=same; header_11}

header_11 [label="2 : Fields"]


section_12 -> { header_13}
{rank=same; header_13}

header_13 [label="3 : Includes"]


codeblock_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"lib/util\"

local Node = require \"peg/node\"

local Header = require \"grym/header\"
local Block = require \"grym/block\"
local Codeblock = require \"grym/codeblock\"
local m = require \"grym/morphemes\""]
section_5 -> { header_16}
{rank=same; header_16}

header_16 [label="2 : Metatable for sections"]


codeblock_17 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local S, s = u.inherit(Node)

function S.__tostring(section)
    local phrase = \"\"
    for _,v in ipairs(section) do
        local repr = tostring(v)
        if (repr ~= \"\" and repr ~= \"\\n\") then
            io.write(\"repr: \" .. repr .. \"\\n\")
            phrase = phrase .. repr .. \"\\n\"
        end
    end

    return phrase
end"]
section_18 -> { header_21}
{rank=same; header_21}

header_21 [label="3 : dotLabel(section)"]


codeblock_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.dotLabel(section)
    return \"section: \" .. tostring(section.line_first) 
        .. \"-\" .. tostring(section.line_last)
end"]
section_19 -> { header_24}
{rank=same; header_24}

header_24 [label="3 : toMarkdown(section)"]


codeblock_25 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.toMarkdown(section)
    local phrase = \"\"
    for _, node in ipairs(section) do
        if node.toMarkdown then
            phrase = phrase .. node:toMarkdown()
        else 
            u.freeze(\"no toMarkdown method in \" .. node.id)
        end
    end

    return phrase
end"]
section_26 -> { header_28}
{rank=same; header_28}

header_28 [label="4 : asserts"]


codeblock_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.check(section)
    for i, v in ipairs(section) do
        if (i == 1) then
            if section.header then
                assert(v.id == \"header\")
            end
        else
            assert(v.id == \"section\" or v.id == \"block\")
        end
    end
    assert(section.level)
    assert(section.id)
    assert(section.lines)
    assert(section.line_first)
    assert(section.line_last)
end"]
section_6 -> { header_31}
{rank=same; header_31}

header_31 [label="2 : addLine(section, line) "]


codeblock_32 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.addLine(section, line)
    section.lines[#section.lines + 1] = line
    return section
end"]
section_33 -> { header_36}
{rank=same; header_36}

header_36 [label="3 : addSection(section, newsection, linum)"]


codeblock_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.addSection(section, newsection, linum)
    if linum > 0 then
        section.line_last = linum - 1
    end
    section[#section + 1] = newsection
    return section
end"]
section_34 -> { header_39}
{rank=same; header_39}

header_39 [label="3 : Helper Functions for Blocking"]


codeblock_40 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function isTagline(line)
    return L.match(m.tagline_p, line)
end"]
codeblock_41 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fwdBlanks(lines, linum)
    local fwd = 0
    local index = linum + 1
    if index > #lines then 
        return 0
    else 
        for i = index, #lines do
            if lines[i] == \"\" then
                fwd = fwd + 1
            else
                break
            end
        end
    end
    return fwd
end"]
section_42 -> { header_48}
{rank=same; header_48}

header_48 [label="4 : List line"]


section_43 -> { header_49}
{rank=same; header_49}

header_49 [label="4 : Table line"]


section_44 -> { header_50}
{rank=same; header_50}

header_50 [label="4 : Tag line "]


section_45 -> { header_51}
{rank=same; header_51}

header_51 [label="4 : Code block"]


codeblock_52 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.block(section)
    -- There is always a header at [1], though it may be nil
    -- If there are other Nodes, they are sections and must be appended
    -- after the blocks.
    local sub_sections = {}
    for i = 2, #section do
        sub_sections[#sub_sections + 1] = section[i]
        section[i] = nil
    end

    -- Every section gets at least one block, at [2], which may be empty.
    local latest = Block(nil, section.line_first) -- current block
    section[2] = latest

    -- State machine for blocking a section
    local back_blanks = 0
    -- first set of blank lines in a section belong to the first block
    local lead_blanks = true
    -- Track code blocks in own logic
    local code_block = false
    -- Tags also
    local tagging = false
    for i = 1, #section.lines do
        local inset = i + section.line_first
        local l = section.lines[i]
        if not code_block then
            if l == \"\" then 
                -- increment back blanks for clinging subsequent lines
                back_blanks = back_blanks + 1
                -- blank lines attach to the preceding block
                latest:addLine(l)
            else
                local isCodeHeader, level, l_trim = Codeblock.matchHead(l)
                if isCodeHeader then
                    code_block = true
                    if not tagging then
                        -- create a new block for the codeblock
                        latest.line_last = inset - 1
                        latest = Block(nil, inset)
                        latest[1] = Codeblock(level, l_trim, inset)
                        section[#section + 1] = latest
                    else
                        -- preserve existing block and add codeblock
                        tagging = false
                        latest[1] = Codeblock(level, l_trim, inset)
                    end
                elseif isTagline(l) then
                    tagging = true
                    -- apply cling rule
                    local fwd_blanks = fwdBlanks(section.lines, i)
                    if fwd_blanks > back_blanks then
                        latest:addLine(l)
                    else
                        -- new block
                        latest.line_last = inset - 1
                        latest = Block(l, inset)
                        section[#section + 1] = latest
                        back_blanks = 0
                    end                        
                else
                    if back_blanks > 0 and lead_blanks == false then
                        if not tagging then
                        -- new block
                            latest.line_last = inset - 1
                            latest = Block(l, inset)
                            section[#section + 1] = latest
                            back_blanks = 0
                        else
                            latest:addLine(l)
                            tagging = false
                        end 
                    else
                        -- continuing a block
                        lead_blanks = false
                        back_blanks = 0
                        latest:addLine(l)
                    end
                end
            end
        else
            -- Collecting a code block
            local isCodeFoot, level, l_trim = Codeblock.matchFoot(l)
            if (isCodeFoot and level == latest[1].level) then
                code_block = false
                latest[1].footer = l_trim
                latest[1].line_last = inset
            else
                latest[1].lines[#latest[1].lines + 1] = l
            end
            -- Continue in normal parse mode
            -- This may add more lines to the code block
        end
    end
    -- Auto-close a code block with no footer.
    if latest[1] and latest[1].id == \"codeblock\" and not latest[1].line_last then
        latest[1].line_last = #section.lines
    end

    -- Close last block
    latest.line_last = section.line_last

    -- Append sections, if any, which follow our blocks
    for _, v in ipairs(sub_sections) do
        section[#section + 1] = v
    end
    return section
end"]
section_7 -> { header_54}
{rank=same; header_54}

header_54 [label="2 : Blocking"]


section_55 -> { header_56}
{rank=same; header_56}

header_56 [label="4 : Prose line"]


section_8 -> { header_57}
{rank=same; header_57}

header_57 [label="2 : Section:weed()"]


codeblock_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.weed(section)
    for i, v in ipairs(section) do
        if v.id == \"block\" then
            if v[1] and v[1].id == \"codeblock\" 
                or v[1].id == \"prose\" then
                section[i] = v[1]          
            end
        end
    end
end"]
section_9 -> { header_60}
{rank=same; header_60}

header_60 [label="2 : Section(header, linum)"]


codeblock_61 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(section, header, linum)
    local section = setmetatable({}, S)
    if type(header) == \"number\" then
        -- We have a virtual header
        section[1] = Header(\"\", header)
        section.header = nil
        section.level = header
    else
        section[1] = header
        section.header = header
        section.level = header.level
    end
    section.line_first = linum
    section.lines = {}
    section.id = \"section\"
    return section
end

return u.export(s, new)"]

}
