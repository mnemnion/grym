digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 412"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-379"]


section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}

header_2 [label="1 : Section metatable"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

section_7 [label="section: 16-21"]

section_8 [label="section: 22-29"]

section_9 [label="section: 46-79"]

section_10 [label="section: 125-166"]

section_11 [label="section: 204-217"]

section_12 [label="section: 361-379"]

section_13 [label="section: 380-412"]


prose_3 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


   Sections consist of a header and body.  The body may contain
 one or more blocks, followed by zero or more child sections.
"]
prose_4 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 The header and block may both be virtual, but will always be
 present.
"]
prose_5 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 In the first pass, we fill a lines array with the raw
 contents of the section. 
"]
prose_6 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 This is subsequently refined into various blocks. 

"]
section_7 -> { header_18 prose_19}
{rank=same; header_18 prose_19}

header_18 [label="2 : Array"]

prose_19 [label="prose"]


prose_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   The array portion of a section starts at [1] with a header. The
 rest consists, optionally, of nodes of types Block and Section.

"]
section_8 -> { header_21 prose_22 section_23}
{rank=same; header_21 prose_22 section_23}

header_21 [label="2 : Fields"]

prose_22 [label="prose"]

section_23 [label="section: 30-45"]


prose_22 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 - header : The header for the section.
 - level : The header level, lifted from the header for ease of use
 - lines : An array of the lines owned by the section. Note that 
           this doesn't include the header. 

"]
section_23 -> { header_25 prose_26 codeblock_27}
{rank=same; header_25 prose_26 codeblock_27}

header_25 [label="3 : Includes"]

prose_26 [label="prose"]

codeblock_27 [label="code block 32-43"]


prose_26 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_27 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"lib/util\"

local Node = require \"peg/node\"

local Header = require \"grym/header\"
local Block = require \"grym/block\"
local Codeblock = require \"grym/codeblock\"
local m = require \"grym/morphemes\""]
section_9 -> { header_30 prose_31 codeblock_32 section_33 section_34}
{rank=same; header_30 prose_31 codeblock_32 section_33 section_34}

header_30 [label="2 : Metatable for sections"]

prose_31 [label="prose"]

codeblock_32 [label="code block 48-63"]

section_33 [label="section: 66-79"]

section_34 [label="section: 80-102"]


prose_31 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local S, s = u.inherit(Node)

function S.__tostring(section)
    local phrase = \"\"
    for _,v in ipairs(section) do
        local repr = tostring(v)
        if (repr ~= \"\" and repr ~= \"\\n\") then
            io.write(\"repr: \" .. repr .. \"\\n\")
            phrase = phrase .. repr .. \"\\n\"
        end
    end

    return phrase
end"]
section_33 -> { header_37 prose_38 prose_39 codeblock_40}
{rank=same; header_37 prose_38 prose_39 codeblock_40}

header_37 [label="3 : dotLabel(section)"]

prose_38 [label="prose"]

prose_39 [label="prose"]

codeblock_40 [label="code block 72-77"]


prose_38 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Produces a label for a dotfile.
"]
prose_39 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return : string in dot format.
"]
codeblock_40 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.dotLabel(section)
    return \"section: \" .. tostring(section.line_first) 
        .. \"-\" .. tostring(section.line_last)
end"]
section_34 -> { header_44 prose_45 prose_46 prose_47 codeblock_48 section_49}
{rank=same; header_44 prose_45 prose_46 prose_47 codeblock_48 section_49}

header_44 [label="3 : toMarkdown(section)"]

prose_45 [label="prose"]

prose_46 [label="prose"]

prose_47 [label="prose"]

codeblock_48 [label="code block 88-101"]

section_49 [label="section: 103-124"]


prose_45 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Translates the Section to markdown.
"]
prose_46 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section: the Section.
"]
prose_47 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return: A Markdown string.  
"]
codeblock_48 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.toMarkdown(section)
    local phrase = \"\"
    for _, node in ipairs(section) do
        if node.toMarkdown then
            phrase = phrase .. node:toMarkdown()
        else 
            u.freeze(\"no toMarkdown method in \" .. block.id)
        end
    end

    return phrase
end"]
section_49 -> { header_54 prose_55 codeblock_56}
{rank=same; header_54 prose_55 codeblock_56}

header_54 [label="4 : asserts"]

prose_55 [label="prose"]

codeblock_56 [label="code block 105-122"]


prose_55 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_56 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.check(section)
    for i, v in ipairs(section) do
        if (i == 1) then
            if section.header then
                assert(v.id == \"header\")
            end
        else
            assert(v.id == \"section\" or v.id == \"block\")
        end
    end
    assert(section.level)
    assert(section.id)
    assert(section.lines)
    assert(section.line_first)
    assert(section.line_last)
end"]
section_10 -> { header_59 prose_60 prose_61 prose_62 codeblock_63 section_64 section_65}
{rank=same; header_59 prose_60 prose_61 prose_62 codeblock_63 section_64 section_65}

header_59 [label="2 : addLine(section, line) "]

prose_60 [label="prose"]

prose_61 [label="prose"]

prose_62 [label="prose"]

codeblock_63 [label="code block 138-143"]

section_64 [label="section: 146-166"]

section_65 [label="section: 167-241"]


prose_60 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Add a line to a section.
"]
prose_61 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
These lines are later translated into blocks, and when the
parser is mature, =section.line= will be set to nil before
the Doc is returned.  
 
- section: the section
- line: the line
"]
prose_62 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- return : the section
"]
codeblock_63 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.addLine(section, line)
    section.lines[#section.lines + 1] = line
    return section
end"]
section_64 -> { header_70 prose_71 prose_72 prose_73 codeblock_74}
{rank=same; header_70 prose_71 prose_72 prose_73 codeblock_74}

header_70 [label="3 : addSection(section, newsection, linum)"]

prose_71 [label="prose"]

prose_72 [label="prose"]

prose_73 [label="prose"]

codeblock_74 [label="code block 156-164"]


prose_71 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Adds a section to the host section
"]
prose_72 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section:  Section to contain the new section.
- newsection:  The new section.
- linum:  The line number.
"]
prose_73 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return: the parent section.
"]
codeblock_74 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.addSection(section, newsection, linum)
    if linum > 0 then
        section.line_last = linum - 1
    end
    section[#section + 1] = newsection
    return section
end"]
section_65 -> { header_79 prose_80 codeblock_81 prose_82 prose_83 prose_84 codeblock_85 section_86 section_87 section_88 section_89}
{rank=same; header_79 prose_80 codeblock_81 prose_82 prose_83 prose_84 codeblock_85 section_86 section_87 section_88 section_89}

header_79 [label="3 : Helper Functions for Blocking"]

prose_80 [label="prose"]

codeblock_81 [label="code block 171-175"]

prose_82 [label="prose"]

prose_83 [label="prose"]

prose_84 [label="prose"]

codeblock_85 [label="code block 185-202"]

section_86 [label="section: 224-229"]

section_87 [label="section: 230-234"]

section_88 [label="section: 235-241"]

section_89 [label="section: 242-360"]


prose_80 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Boolean match for a tagline
"]
codeblock_81 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function isTagline(line)
    return L.match(m.tagline_p, line)
end"]
prose_82 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Lookahead, counting blank lines, return the number.
"]
prose_83 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines: the full lines array of the section
- linum: current index into lines
"]
prose_84 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- returns: number of blank lines forward of index
"]
codeblock_85 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fwdBlanks(lines, linum)
    local fwd = 0
    local index = linum + 1
    if index > #lines then 
        return 0
    else 
        for i = index, #lines do
            if lines[i] == \"\" then
                fwd = fwd + 1
            else
                break
            end
        end
    end
    return fwd
end"]
section_86 -> { header_96 prose_97}
{rank=same; header_96 prose_97}

header_96 [label="4 : List line"]

prose_97 [label="prose"]


prose_97 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

New block unless previous line is also list,
in which case append. 

"]
section_87 -> { header_99 prose_100}
{rank=same; header_99 prose_100}

header_99 [label="4 : Table line"]

prose_100 [label="prose"]


prose_100 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Same as list.

"]
section_88 -> { header_102 prose_103}
{rank=same; header_102 prose_103}

header_102 [label="4 : Tag line "]

prose_103 [label="prose"]


prose_103 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A tag needs to cling, so we need to check the
number of blank lines before and after a tag line, if any.
If even, a tag line clings down.

"]
section_89 -> { header_105 prose_106 prose_107 prose_108 codeblock_109}
{rank=same; header_105 prose_106 prose_107 prose_108 codeblock_109}

header_105 [label="4 : Code block"]

prose_106 [label="prose"]

prose_107 [label="prose"]

prose_108 [label="prose"]

codeblock_109 [label="code block 251-359"]


prose_106 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A code block is anything between a code header and
either a code footer or the end of a file. 
"]
prose_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section : the Section to be blocked
"]
prose_108 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- returns : the same Section, filled in with blocks
"]
codeblock_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.block(section)
    -- There is always a header at [1], though it may be nil
    -- If there are other Nodes, they are sections and must be appended
    -- after the blocks.
    local sub_sections = {}
    for i = 2, #section do
        sub_sections[#sub_sections + 1] = section[i]
        section[i] = nil
    end

    -- Every section gets at least one block, at [2], which may be empty.
    local latest = Block(nil, section.line_first) -- current block
    section[2] = latest

    -- State machine for blocking a section
    local back_blanks = 0
    -- first set of blank lines in a section belong to the first block
    local lead_blanks = true
    -- Track code blocks in own logic
    local code_block = false
    -- Tags also
    local tagging = false
    for i = 1, #section.lines do
        local inset = i + section.line_first
        local l = section.lines[i]
        if not code_block then
            if l == \"\" then 
                -- increment back blanks for clinging subsequent lines
                back_blanks = back_blanks + 1
                -- blank lines attach to the preceding block
                latest:addLine(l)
            else
                local isCodeHeader, level, l_trim = Codeblock.matchHead(l)
                if isCodeHeader then
                    code_block = true
                    if not tagging then
                        -- create a new block for the codeblock
                        latest.line_last = inset - 1
                        latest = Block(nil, inset)
                        latest[1] = Codeblock(level, l_trim, inset)
                        section[#section + 1] = latest
                    else
                        -- preserve existing block and add codeblock
                        tagging = false
                        latest[1] = Codeblock(level, l_trim, inset)
                    end
                elseif isTagline(l) then
                    tagging = true
                    -- apply cling rule
                    local fwd_blanks = fwdBlanks(section.lines, i)
                    if fwd_blanks > back_blanks then
                        latest:addLine(l)
                    else
                        -- new block
                        latest.line_last = inset - 1
                        latest = Block(l, inset)
                        section[#section + 1] = latest
                        back_blanks = 0
                    end                        
                else
                    if back_blanks > 0 and lead_blanks == false then
                        if not tagging then
                        -- new block
                            latest.line_last = inset - 1
                            latest = Block(l, inset)
                            section[#section + 1] = latest
                            back_blanks = 0
                        else
                            latest:addLine(l)
                            tagging = false
                        end 
                    else
                        -- continuing a block
                        lead_blanks = false
                        back_blanks = 0
                        latest:addLine(l)
                    end
                end
            end
        else
            -- Collecting a code block
            local isCodeFoot, level, l_trim = Codeblock.matchFoot(l)
            if (isCodeFoot and level == latest[1].level) then
                code_block = false
                latest[1].footer = l_trim
                latest[1].line_last = inset
            else
                latest[1].lines[#latest[1].lines + 1] = l
            end
            -- Continue in normal parse mode
            -- This may add more lines to the code block
        end
    end
    -- Auto-close a code block with no footer.
    if latest[1] and latest[1].id == \"codeblock\" and not latest[1].line_last then
        latest[1].line_last = #section.lines
    end

    -- Close last block
    latest.line_last = section.line_last

    -- Append sections, if any, which follow our blocks
    for _, v in ipairs(sub_sections) do
        section[#section + 1] = v
    end
    return section
end"]
section_11 -> { header_114 prose_115 prose_116 prose_117 section_118}
{rank=same; header_114 prose_115 prose_116 prose_117 section_118}

header_114 [label="2 : Blocking"]

prose_115 [label="prose"]

prose_116 [label="prose"]

prose_117 [label="prose"]

section_118 [label="section: 218-223"]


prose_115 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Blocks a Section.
"]
prose_116 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is a moderately complex state machine, which
works on a line-by-line basis with some lookahead.
"]
prose_117 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
First off, we have a Header at [1], and may have one or 
more Sections The blocks go between the Header and the remaining
Sections, so we have to lift them and append after blocking.
 
Next, we parse the lines, thus:

"]
section_118 -> { header_122 prose_123}
{rank=same; header_122 prose_123}

header_122 [label="4 : Prose line"]

prose_123 [label="prose"]


prose_123 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If preceded by at least one blank line,
make a new block, otherwise append to existing block.

"]
section_12 -> { header_125 prose_126 codeblock_127}
{rank=same; header_125 prose_126 codeblock_127}

header_125 [label="2 : Section:weed()"]

prose_126 [label="prose"]

codeblock_127 [label="code block 366-377"]


prose_126 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This is a kludgy thing we're going to do to remove 'blocks' once they've
become either codeblocks or prose.
"]
codeblock_127 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.weed(section)
    for i, v in ipairs(section) do
        if v.id == \"block\" then
            if v[1] and v[1].id == \"codeblock\" 
                or v[1].id == \"prose\" then
                section[i] = v[1]          
            end
        end
    end
end"]
section_13 -> { header_130 prose_131 prose_132 prose_133 codeblock_134}
{rank=same; header_130 prose_131 prose_132 prose_133 codeblock_134}

header_130 [label="2 : Section(header, linum)"]

prose_131 [label="prose"]

prose_132 [label="prose"]

prose_133 [label="prose"]

codeblock_134 [label="code block 391-411"]


prose_131 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Creates a new section, given a header and the line number.
"]
prose_132 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- header :  Header for the section, which may be of type Header or 
            a number.  A number means the header is virtual.
- linum  :  The line number of the header, which is the first of the
            Section.
"]
prose_133 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- return :  The new Section.
"]
codeblock_134 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(section, header, linum)
    local section = setmetatable({}, S)
    if type(header) == \"number\" then
        -- We have a virtual header
        section[1] = Header(\"\", header)
        section.header = nil
        section.level = header
    else
        section[1] = header
        section.header = header
        section.level = header.level
    end
    section.line_first = linum
    section.lines = {}
    section.id = \"section\"
    return section
end

return u.export(s, new)"]

}
