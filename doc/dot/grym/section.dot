digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 417"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-382"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}
{rank=same; header_2 block_3 block_4 block_5 block_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}

header_2 [label="1 : Section metatable"]

block_3 [label="block 1-6"]

block_4 [label="block 7-9"]

block_5 [label="block 10-12"]

block_6 [label="block 13-382"]

section_7 [label="section: 16-21"]

section_8 [label="section: 22-29"]

section_9 [label="section: 47-80"]

section_10 [label="section: 127-169"]

section_11 [label="section: 207-220"]

section_12 [label="section: 364-382"]

section_13 [label="section: 383-417"]


block_3 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   Sections consist of a header and body.  The body may contain
 one or more blocks, followed by zero or more child sections.
"]
block_4 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" The header and block may both be virtual, but will always be
 present.
"]
block_5 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" In the first pass, we fill a lines array with the raw
 contents of the section. 
"]
block_6 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" This is subsequently refined into various blocks. 

"]
section_7 -> { header_18 block_19}
{rank=same; header_18 block_19}

header_18 [label="2 : Array"]

block_19 [label="block 16-21"]


block_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   The array portion of a section starts at [1] with a header. The
 rest consists, optionally, of nodes of types Block and Section.

"]
section_8 -> { header_21 block_22 section_23}
{rank=same; header_21 block_22 section_23}

header_21 [label="2 : Fields"]

block_22 [label="block 22-29"]

section_23 [label="section: 30-46"]


block_22 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - header : The header for the section.
 - level : The header level, lifted from the header for ease of use
 - lines : An array of the lines owned by the section. Note that 
           this doesn't include the header. 

"]
section_23 -> { header_25 block_26 block_27}
{rank=same; header_25 block_26 block_27}

header_25 [label="3 : Includes"]

block_26 [label="block 30-31"]

block_27 [label="block 32-46"]


block_26 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_27 -> { codeblock_29}
{rank=same; codeblock_29}

codeblock_29 [label="code block 32-44"]


codeblock_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"util\"
local status = require \"status\"

local Node = require \"peg/node\"

local Header = require \"grym/header\"
local Block = require \"grym/block\"
local Codeblock = require \"grym/codeblock\"
local m = require \"grym/morphemes\""]
block_27 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_9 -> { header_32 block_33 block_34 section_35 section_36}
{rank=same; header_32 block_33 block_34 section_35 section_36}

header_32 [label="2 : Metatable for sections"]

block_33 [label="block 47-48"]

block_34 [label="block 49-80"]

section_35 [label="section: 67-80"]

section_36 [label="section: 81-103"]


block_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_34 -> { codeblock_38}
{rank=same; codeblock_38}

codeblock_38 [label="code block 49-64"]


codeblock_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local S, s = u.inherit(Node)
S.id = \"section\"

function S.__tostring(section)
    local phrase = \"\"
    for _,v in ipairs(section) do
        local repr = tostring(v)
        if (repr ~= \"\" and repr ~= \"\\n\") then
            phrase = phrase .. repr .. \"\\n\"
        end
    end

    return phrase
end"]
block_34 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_35 -> { header_41 block_42 block_43 block_44}
{rank=same; header_41 block_42 block_43 block_44}

header_41 [label="3 : dotLabel(section)"]

block_42 [label="block 67-70"]

block_43 [label="block 71-72"]

block_44 [label="block 73-80"]


block_42 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Produces a label for a dotfile.
"]
block_43 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- #return : string in dot format.
"]
block_44 -> { codeblock_47}
{rank=same; codeblock_47}

codeblock_47 [label="code block 73-78"]


codeblock_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.dotLabel(section)
    return \"section: \" .. tostring(section.line_first) 
        .. \"-\" .. tostring(section.line_last)
end"]
block_44 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_36 -> { header_50 block_51 block_52 block_53 block_54 section_55}
{rank=same; header_50 block_51 block_52 block_53 block_54 section_55}

header_50 [label="3 : toMarkdown(section)"]

block_51 [label="block 81-84"]

block_52 [label="block 85-86"]

block_53 [label="block 87-88"]

block_54 [label="block 89-103"]

section_55 [label="section: 104-126"]


block_51 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Translates the Section to markdown.
"]
block_52 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- section: the Section.
"]
block_53 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- #return: A Markdown string.  
"]
block_54 -> { codeblock_59}
{rank=same; codeblock_59}

codeblock_59 [label="code block 89-102"]


codeblock_59 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.toMarkdown(section)
    local phrase = \"\"
    for _, node in ipairs(section) do
        if node.toMarkdown then
            phrase = phrase .. node:toMarkdown()
        else 
            u.freeze(\"no toMarkdown method in \" .. node.id)
        end
    end

    return phrase
end"]
block_54 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_55 -> { header_62 block_63 block_64}
{rank=same; header_62 block_63 block_64}

header_62 [label="4 : asserts"]

block_63 [label="block 104-105"]

block_64 [label="block 106-126"]


block_63 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_64 -> { codeblock_66}
{rank=same; codeblock_66}

codeblock_66 [label="code block 106-124"]


codeblock_66 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.check(section)
    for i, v in ipairs(section) do
        if (i == 1) then
            if section.header then
                assert(v.id == \"header\")
            end
        else
            assert(v.id == \"section\" or v.id == \"block\")
        end
    end
    assert(section.level)
    assert(section.id)
    assert(section.first, \"no first in \" .. tostring(section))
    assert(section.lines)
    assert(section.line_first)
    assert(section.line_last)
end"]
block_64 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_10 -> { header_69 block_70 block_71 block_72 block_73 section_74 section_75}
{rank=same; header_69 block_70 block_71 block_72 block_73 section_74 section_75}

header_69 [label="2 : addLine(section, line) "]

block_70 [label="block 127-130"]

block_71 [label="block 131-137"]

block_72 [label="block 138-139"]

block_73 [label="block 140-169"]

section_74 [label="section: 148-169"]

section_75 [label="section: 170-244"]


block_70 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Add a line to a section.
"]
block_71 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="These lines are later translated into blocks, and when the
parser is mature, =section.line= will be set to nil before
the Doc is returned.  
 
- section: the section
- line: the line
"]
block_72 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- return : the section
"]
block_73 -> { codeblock_79}
{rank=same; codeblock_79}

codeblock_79 [label="code block 140-145"]


codeblock_79 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.addLine(section, line)
    section.lines[#section.lines + 1] = line
    return section
end"]
block_73 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_74 -> { header_82 block_83 block_84 block_85 block_86}
{rank=same; header_82 block_83 block_84 block_85 block_86}

header_82 [label="3 : addSection(section, newsection, linum)"]

block_83 [label="block 148-151"]

block_84 [label="block 152-155"]

block_85 [label="block 156-157"]

block_86 [label="block 158-169"]


block_83 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Adds a section to the host section
"]
block_84 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- section:  Section to contain the new section.
- newsection:  The new section.
- linum:  The line number.
"]
block_85 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- #return: the parent section.
"]
block_86 -> { codeblock_90}
{rank=same; codeblock_90}

codeblock_90 [label="code block 158-167"]


codeblock_90 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.addSection(section, newsection, linum, start, finish)
    if linum > 0 then
        section.line_last = linum - 1
        section.last = finish
    end
    section[#section + 1] = newsection
    return section
end"]
block_86 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_75 -> { header_93 block_94 block_95 block_96 block_97 block_98 block_99 section_100 section_101 section_102 section_103}
{rank=same; header_93 block_94 block_95 block_96 block_97 block_98 block_99 section_100 section_101 section_102 section_103}

header_93 [label="3 : Helper Functions for Blocking"]

block_94 [label="block 170-173"]

block_95 [label="block 174-180"]

block_96 [label="block 181-182"]

block_97 [label="block 183-185"]

block_98 [label="block 186-187"]

block_99 [label="block 188-244"]

section_100 [label="section: 227-232"]

section_101 [label="section: 233-237"]

section_102 [label="section: 238-244"]

section_103 [label="section: 245-363"]


block_94 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Boolean match for a tagline
"]
block_95 -> { codeblock_105}
{rank=same; codeblock_105}

codeblock_105 [label="code block 174-178"]


codeblock_105 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function isTagline(line)
    return L.match(m.tagline_p, line)
end"]
block_95 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_96 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Lookahead, counting blank lines, return the number.
"]
block_97 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- lines: the full lines array of the section
- linum: current index into lines
"]
block_98 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- returns: number of blank lines forward of index
"]
block_99 -> { codeblock_111}
{rank=same; codeblock_111}

codeblock_111 [label="code block 188-205"]


codeblock_111 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fwdBlanks(lines, linum)
    local fwd = 0
    local index = linum + 1
    if index > #lines then 
        return 0
    else 
        for i = index, #lines do
            if lines[i] == \"\" then
                fwd = fwd + 1
            else
                break
            end
        end
    end
    return fwd
end"]
block_99 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_100 -> { header_114 block_115}
{rank=same; header_114 block_115}

header_114 [label="4 : List line"]

block_115 [label="block 227-232"]


block_115 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
New block unless previous line is also list,
in which case append. 

"]
section_101 -> { header_117 block_118}
{rank=same; header_117 block_118}

header_117 [label="4 : Table line"]

block_118 [label="block 233-237"]


block_118 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Same as list.

"]
section_102 -> { header_120 block_121}
{rank=same; header_120 block_121}

header_120 [label="4 : Tag line "]

block_121 [label="block 238-244"]


block_121 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A tag needs to cling, so we need to check the
number of blank lines before and after a tag line, if any.
If even, a tag line clings down.

"]
section_103 -> { header_123 block_124 block_125 block_126 block_127}
{rank=same; header_123 block_124 block_125 block_126 block_127}

header_123 [label="4 : Code block"]

block_124 [label="block 245-249"]

block_125 [label="block 250-251"]

block_126 [label="block 252-253"]

block_127 [label="block 254-363"]


block_124 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A code block is anything between a code header and
either a code footer or the end of a file. 
"]
block_125 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- section : the Section to be blocked
"]
block_126 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- returns : the same Section, filled in with blocks
"]
block_127 -> { codeblock_131}
{rank=same; codeblock_131}

codeblock_131 [label="code block 254-362"]


codeblock_131 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.block(section)
    -- There is always a header at [1], though it may be nil
    -- If there are other Nodes, they are sections and must be appended
    -- after the blocks.
    local sub_sections = {}
    for i = 2, #section do
        sub_sections[#sub_sections + 1] = section[i]
        section[i] = nil
    end

    -- Every section gets at least one block, at [2], which may be empty.
    local latest = Block(nil, section.line_first) -- current block
    section[2] = latest

    -- State machine for blocking a section
    local back_blanks = 0
    -- first set of blank lines in a section belong to the first block
    local lead_blanks = true
    -- Track code blocks in own logic
    local code_block = false
    -- Tags also
    local tagging = false
    for i = 1, #section.lines do
        local inset = i + section.line_first
        local l = section.lines[i]
        if not code_block then
            if l == \"\" then 
                -- increment back blanks for clinging subsequent lines
                back_blanks = back_blanks + 1
                -- blank lines attach to the preceding block
                latest:addLine(l)
            else
                local isCodeHeader, level, l_trim = Codeblock.matchHead(l)
                if isCodeHeader then
                    code_block = true
                    if not tagging then
                        -- create a new block for the codeblock
                        latest.line_last = inset - 1
                        latest = Block(nil, inset)
                        latest[1] = Codeblock(level, l_trim, inset)
                        section[#section + 1] = latest
                    else
                        -- preserve existing block and add codeblock
                        tagging = false
                        latest[1] = Codeblock(level, l_trim, inset)
                    end
                elseif isTagline(l) then
                    tagging = true
                    -- apply cling rule
                    local fwd_blanks = fwdBlanks(section.lines, i)
                    if fwd_blanks > back_blanks then
                        latest:addLine(l)
                    else
                        -- new block
                        latest.line_last = inset - 1
                        latest = Block(l, inset)
                        section[#section + 1] = latest
                        back_blanks = 0
                    end                        
                else
                    if back_blanks > 0 and lead_blanks == false then
                        if not tagging then
                        -- new block
                            latest.line_last = inset - 1
                            latest = Block(l, inset)
                            section[#section + 1] = latest
                            back_blanks = 0
                        else
                            latest:addLine(l)
                            tagging = false
                        end 
                    else
                        -- continuing a block
                        lead_blanks = false
                        back_blanks = 0
                        latest:addLine(l)
                    end
                end
            end
        else
            -- Collecting a code block
            local isCodeFoot, level, l_trim = Codeblock.matchFoot(l)
            if (isCodeFoot and level == latest[1].level) then
                code_block = false
                latest[1].footer = l_trim
                latest[1].line_last = inset
            else
                latest[1].lines[#latest[1].lines + 1] = l
            end
            -- Continue in normal parse mode
            -- This may add more lines to the code block
        end
    end
    -- Auto-close a code block with no footer.
    if latest[1] and latest[1].id == \"codeblock\" and not latest[1].line_last then
        latest[1].line_last = #section.lines
    end

    -- Close last block
    latest.line_last = section.line_last

    -- Append sections, if any, which follow our blocks
    for _, v in ipairs(sub_sections) do
        section[#section + 1] = v
    end
    return section
end"]
block_127 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_11 -> { header_134 block_135 block_136 block_137 section_138}
{rank=same; header_134 block_135 block_136 block_137 section_138}

header_134 [label="2 : Blocking"]

block_135 [label="block 207-210"]

block_136 [label="block 211-213"]

block_137 [label="block 214-220"]

section_138 [label="section: 221-226"]


block_135 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Blocks a Section.
"]
block_136 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This is a moderately complex state machine, which
works on a line-by-line basis with some lookahead.
"]
block_137 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="First off, we have a Header at [1], and may have one or 
more Sections The blocks go between the Header and the remaining
Sections, so we have to lift them and append after blocking.
 
Next, we parse the lines, thus:

"]
section_138 -> { header_142 block_143}
{rank=same; header_142 block_143}

header_142 [label="4 : Prose line"]

block_143 [label="block 221-226"]


block_143 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If preceded by at least one blank line,
make a new block, otherwise append to existing block.

"]
section_12 -> { header_145 block_146 block_147}
{rank=same; header_145 block_146 block_147}

header_145 [label="2 : Section:weed()"]

block_146 [label="block 364-368"]

block_147 [label="block 369-382"]


block_146 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  This is a kludgy thing we're going to do to remove 'blocks' once they've
become either codeblocks or prose.
"]
block_147 -> { codeblock_149}
{rank=same; codeblock_149}

codeblock_149 [label="code block 369-380"]


codeblock_149 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function S.weed(section)
    for i, v in ipairs(section) do
        if v.id == \"block\" then
            if v[1] and v[1].id == \"codeblock\" 
                or v[1].id == \"prose\" then
                section[i] = v[1]          
            end
        end
    end
end"]
block_147 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_13 -> { header_152 block_153 block_154 block_155 block_156}
{rank=same; header_152 block_153 block_154 block_155 block_156}

header_152 [label="2 : Section(header, linum)"]

block_153 [label="block 383-386"]

block_154 [label="block 387-391"]

block_155 [label="block 392-393"]

block_156 [label="block 394-417"]


block_153 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Creates a new section, given a header and the line number.
"]
block_154 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- header :  Header for the section, which may be of type Header or 
            a number.  A number means the header is virtual.
- linum  :  The line number of the header, which is the first of the
            Section.
"]
block_155 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- return :  The new Section.
"]
block_156 -> { codeblock_160}
{rank=same; codeblock_160}

codeblock_160 [label="code block 394-416"]


codeblock_160 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Section, header, linum, first, last)
    local section = setmetatable({}, S)
    if type(header) == \"number\" then
        -- We have a virtual header
        status:verb(\"creating virtual header\")
        section[1] = Header(\"\", header)
        section.header = nil
        section.level = header
    else
        section[1] = header
        section.header = header
        section.level = header.level
    end
    section.first = first
    section.last = last
    section.line_first = linum
    section.lines = {}
    return section
end

return u.export(s, new)"]
block_156 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

}
