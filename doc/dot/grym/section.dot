digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 438"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-399"]


section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}

header_2 [label="1 : Section metatable"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

section_7 [label="section: 16-21"]

section_8 [label="section: 22-29"]

section_9 [label="section: 47-79"]

section_10 [label="section: 128-186"]

section_11 [label="section: 224-237"]

section_12 [label="section: 382-399"]

section_13 [label="section: 400-438"]


header_2 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Section metatable"]
prose_3 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


   Sections consist of a header and body.  The body may contain
 one or more blocks, followed by zero or more child sections.
"]
prose_4 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 The header and block may both be virtual, but will always be
 present.
"]
prose_5 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 In the first pass, we fill a lines array with the raw
 contents of the section. 
"]
prose_6 -> { raw_21}
{rank=same; raw_21}

raw_21 [label="raw"]


raw_21 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 This is subsequently refined into various blocks. 

"]
section_7 -> { header_23 prose_24}
{rank=same; header_23 prose_24}

header_23 [label="2 : Array"]

prose_24 [label="prose"]


header_23 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" ** Array"]
prose_24 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   The array portion of a section starts at [1] with a header. The
 rest consists, optionally, of nodes of types Block and Section.

"]
section_8 -> { header_28 prose_29 section_30}
{rank=same; header_28 prose_29 section_30}

header_28 [label="2 : Fields"]

prose_29 [label="prose"]

section_30 [label="section: 30-46"]


header_28 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" ** Fields"]
prose_29 -> { raw_32}
{rank=same; raw_32}

raw_32 [label="raw"]


raw_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 - header : The header for the section.
 - level : The header level, lifted from the header for ease of use
 - lines : An array of the lines owned by the section. Note that 
           this doesn't include the header. 

"]
section_30 -> { header_34 prose_35 codeblock_36}
{rank=same; header_34 prose_35 codeblock_36}

header_34 [label="3 : Includes"]

prose_35 [label="prose"]

codeblock_36 [label="code block 32-44"]


header_34 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Includes"]
prose_35 -> { raw_38}
{rank=same; raw_38}

raw_38 [label="raw"]


raw_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"util\"
local status = require \"status\"

local Node = require \"node/node\"

local Header = require \"grym/header\"
local Block = require \"grym/block\"
local Codeblock = require \"grym/codeblock\"
local m = require \"grym/morphemes\""]
section_9 -> { header_41 prose_42 codeblock_43 section_44 section_45 section_46}
{rank=same; header_41 prose_42 codeblock_43 section_44 section_45 section_46}

header_41 [label="2 : Metatable for sections"]

prose_42 [label="prose"]

codeblock_43 [label="code block 49-53"]

section_44 [label="section: 55-65"]

section_45 [label="section: 66-79"]

section_46 [label="section: 80-102"]


header_41 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Metatable for sections"]
prose_42 -> { raw_48}
{rank=same; raw_48}

raw_48 [label="raw"]


raw_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_43 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Sec, sec = u.inherit(Node)
Sec.id = \"section\"
"]
section_44 -> { header_51 prose_52 codeblock_53}
{rank=same; header_51 prose_52 codeblock_53}

header_51 [label="3 : __tostring"]

prose_52 [label="prose"]

codeblock_53 [label="code block 59-63"]


header_51 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** __tostring"]
prose_52 -> { raw_55}
{rank=same; raw_55}

raw_55 [label="raw"]


raw_55 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We just return the repr of the header.
"]
codeblock_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.__tostring(section)
    return tostring(section[1])
end"]
section_45 -> { header_58 prose_59 prose_60 codeblock_61}
{rank=same; header_58 prose_59 prose_60 codeblock_61}

header_58 [label="3 : dotLabel(section)"]

prose_59 [label="prose"]

prose_60 [label="prose"]

codeblock_61 [label="code block 72-77"]


header_58 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** dotLabel(section)"]
prose_59 -> { raw_63}
{rank=same; raw_63}

raw_63 [label="raw"]


raw_63 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Produces a label for a dotfile.
"]
prose_60 -> { raw_65}
{rank=same; raw_65}

raw_65 [label="raw"]


raw_65 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return : string in dot format.
"]
codeblock_61 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.dotLabel(section)
    return \"section: \" .. tostring(section.line_first) 
        .. \"-\" .. tostring(section.line_last)
end"]
section_46 -> { header_68 prose_69 prose_70 prose_71 codeblock_72 section_73}
{rank=same; header_68 prose_69 prose_70 prose_71 codeblock_72 section_73}

header_68 [label="3 : toMarkdown(section)"]

prose_69 [label="prose"]

prose_70 [label="prose"]

prose_71 [label="prose"]

codeblock_72 [label="code block 88-101"]

section_73 [label="section: 103-127"]


header_68 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** toMarkdown(section)"]
prose_69 -> { raw_75}
{rank=same; raw_75}

raw_75 [label="raw"]


raw_75 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Translates the Section to markdown.
"]
prose_70 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section: the Section.
"]
prose_71 -> { raw_79}
{rank=same; raw_79}

raw_79 [label="raw"]


raw_79 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return: A Markdown string.  
"]
codeblock_72 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.toMarkdown(section)
    local phrase = \"\"
    for _, node in ipairs(section) do
        if node.toMarkdown then
            phrase = phrase .. node:toMarkdown()
        else 
            u.freeze(\"no toMarkdown method in \" .. node.id)
        end
    end

    return phrase
end"]
section_73 -> { header_82 prose_83 codeblock_84}
{rank=same; header_82 prose_83 codeblock_84}

header_82 [label="4 : asserts"]

prose_83 [label="prose"]

codeblock_84 [label="code block 105-125"]


header_82 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** asserts"]
prose_83 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_84 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.check(section)
    for i, v in ipairs(section) do
        if (i == 1) then
            if section.header then
                assert(v.id == \"header\")
            end
        else
            assert(v.id == \"section\" or v.id == \"block\")
        end
    end
    assert(section.level)
    assert(section.id == \"section\")
    assert(section.first, \"no first in \" .. tostring(section))
    assert(section.last, \"no last in \" .. tostring(section))
    assert(section.str, \"no str in \" .. tostring(section))
    assert(section.lines)
    assert(section.line_first)
    assert(section.line_last)
end"]
section_10 -> { header_89 prose_90 prose_91 prose_92 codeblock_93 section_94 section_95}
{rank=same; header_89 prose_90 prose_91 prose_92 codeblock_93 section_94 section_95}

header_89 [label="2 : addLine(section, line) "]

prose_90 [label="prose"]

prose_91 [label="prose"]

prose_92 [label="prose"]

codeblock_93 [label="code block 141-146"]

section_94 [label="section: 149-186"]

section_95 [label="section: 187-261"]


header_89 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** addLine(section, line) "]
prose_90 -> { raw_97}
{rank=same; raw_97}

raw_97 [label="raw"]


raw_97 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Add a line to a section.
"]
prose_91 -> { raw_99 literal_100 raw_101}
{rank=same; raw_99 literal_100 raw_101}

raw_99 [label="raw"]

literal_100 [label="literal"]

raw_101 [label="raw"]


raw_99 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
These lines are later translated into blocks, and when the
parser is mature, "]
literal_100 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="section.line"]
raw_101 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will be set to nil before
the Doc is returned.  
 
- section: the section
- line: the line
"]
prose_92 -> { raw_105}
{rank=same; raw_105}

raw_105 [label="raw"]


raw_105 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- return : the section
"]
codeblock_93 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.addLine(section, line)
    section.lines[#section.lines + 1] = line
    return section
end"]
section_94 -> { header_108 prose_109 prose_110 prose_111 prose_112 prose_113 prose_114 codeblock_115}
{rank=same; header_108 prose_109 prose_110 prose_111 prose_112 prose_113 prose_114 codeblock_115}

header_108 [label="3 : addSection(section, newsection, linum)"]

prose_109 [label="prose"]

prose_110 [label="prose"]

prose_111 [label="prose"]

prose_112 [label="prose"]

prose_113 [label="prose"]

prose_114 [label="prose"]

codeblock_115 [label="code block 169-184"]


header_108 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** addSection(section, newsection, linum)"]
prose_109 -> { raw_117}
{rank=same; raw_117}

raw_117 [label="raw"]


raw_117 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Adds a section to the host section
"]
prose_110 -> { raw_119}
{rank=same; raw_119}

raw_119 [label="raw"]


raw_119 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section:  Section to contain the new section.
- newsection:  The new section.
- linum:  The line number.
"]
prose_111 -> { raw_121}
{rank=same; raw_121}

raw_121 [label="raw"]


raw_121 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #return: the parent section.
"]
prose_112 -> { raw_123}
{rank=same; raw_123}

raw_123 [label="raw"]


raw_123 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - [ ] #todo  The absence of a virtual section between, say,
               level 2 and level 4, causes section loss under 
               some conditions. Fix.
"]
prose_113 -> { raw_125}
{rank=same; raw_125}

raw_125 [label="raw"]


raw_125 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
               I have a pretty good notion as to why: the parentOf
               array isn't getting updated, so if we have 1:2:3, then
               2, then 4, it's retrieving the 3 as a parent. 
"]
prose_114 -> { raw_127}
{rank=same; raw_127}

raw_127 [label="raw"]


raw_127 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
               That would inded screw up all the things.
"]
codeblock_115 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.addSection(section, newsection, linum, finish)
    -- Conclude the current section
    if linum > 0 then
        section.line_last = linum - 1
        assert(type(finish) == \"number\")
        section.last = finish
    end
    if section.level + 1 == newsection.level then
        section[#section + 1] = newsection
    else
        section[#section + 1] = newsection
    end
    return section
end"]
section_95 -> { header_130 prose_131 codeblock_132 prose_133 prose_134 prose_135 codeblock_136 section_137 section_138 section_139 section_140}
{rank=same; header_130 prose_131 codeblock_132 prose_133 prose_134 prose_135 codeblock_136 section_137 section_138 section_139 section_140}

header_130 [label="3 : Helper Functions for Blocking"]

prose_131 [label="prose"]

codeblock_132 [label="code block 191-195"]

prose_133 [label="prose"]

prose_134 [label="prose"]

prose_135 [label="prose"]

codeblock_136 [label="code block 205-222"]

section_137 [label="section: 244-249"]

section_138 [label="section: 250-254"]

section_139 [label="section: 255-261"]

section_140 [label="section: 262-381"]


header_130 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Helper Functions for Blocking"]
prose_131 -> { raw_142}
{rank=same; raw_142}

raw_142 [label="raw"]


raw_142 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Boolean match for a tagline
"]
codeblock_132 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function isTagline(line)
    return L.match(m.tagline_p, line)
end"]
prose_133 -> { raw_145}
{rank=same; raw_145}

raw_145 [label="raw"]


raw_145 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Lookahead, counting blank lines, return the number.
"]
prose_134 -> { raw_147}
{rank=same; raw_147}

raw_147 [label="raw"]


raw_147 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines: the full lines array of the section
- linum: current index into lines
"]
prose_135 -> { raw_149}
{rank=same; raw_149}

raw_149 [label="raw"]


raw_149 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- returns: number of blank lines forward of index
"]
codeblock_136 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fwdBlanks(lines, linum)
    local fwd = 0
    local index = linum + 1
    if index > #lines then 
        return 0
    else 
        for i = index, #lines do
            if lines[i] == \"\" then
                fwd = fwd + 1
            else
                break
            end
        end
    end
    return fwd
end"]
section_137 -> { header_152 prose_153}
{rank=same; header_152 prose_153}

header_152 [label="4 : List line"]

prose_153 [label="prose"]


header_152 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** List line"]
prose_153 -> { raw_155}
{rank=same; raw_155}

raw_155 [label="raw"]


raw_155 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

New block unless previous line is also list,
in which case append. 

"]
section_138 -> { header_157 prose_158}
{rank=same; header_157 prose_158}

header_157 [label="4 : Table line"]

prose_158 [label="prose"]


header_157 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Table line"]
prose_158 -> { raw_160}
{rank=same; raw_160}

raw_160 [label="raw"]


raw_160 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Same as list.

"]
section_139 -> { header_162 prose_163}
{rank=same; header_162 prose_163}

header_162 [label="4 : Tag line "]

prose_163 [label="prose"]


header_162 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Tag line "]
prose_163 -> { raw_165}
{rank=same; raw_165}

raw_165 [label="raw"]


raw_165 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A tag needs to cling, so we need to check the
number of blank lines before and after a tag line, if any.
If even, a tag line clings down.

"]
section_140 -> { header_167 prose_168 prose_169 prose_170 codeblock_171}
{rank=same; header_167 prose_168 prose_169 prose_170 codeblock_171}

header_167 [label="4 : Code block"]

prose_168 [label="prose"]

prose_169 [label="prose"]

prose_170 [label="prose"]

codeblock_171 [label="code block 271-380"]


header_167 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Code block"]
prose_168 -> { raw_173}
{rank=same; raw_173}

raw_173 [label="raw"]


raw_173 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A code block is anything between a code header and
either a code footer or the end of a file. 
"]
prose_169 -> { raw_175}
{rank=same; raw_175}

raw_175 [label="raw"]


raw_175 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- section : the Section to be blocked
"]
prose_170 -> { raw_177}
{rank=same; raw_177}

raw_177 [label="raw"]


raw_177 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- returns : the same Section, filled in with blocks
"]
codeblock_171 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.block(section)
    local str = section.str
    -- There is always a header at [1], though it may be nil
    -- If there are other Nodes, they are sections and must be appended
    -- after the blocks.
    local sub_sections = {}
    for i = 2, #section do
        sub_sections[#sub_sections + 1] = section[i]
        section[i] = nil
    end

    -- Every section gets at least one block, at [2], which may be empty.
    local latest = Block(nil, section.line_first, str) -- current block
    section[2] = latest

    -- State machine for blocking a section
    local back_blanks = 0
    -- first set of blank lines in a section belong to the first block
    local lead_blanks = true
    -- Track code blocks in own logic
    local code_block = false
    -- Tags also
    local tagging = false
    for i = 1, #section.lines do
        local inset = i + section.line_first
        local l = section.lines[i]
        if not code_block then
            if l == \"\" then 
                -- increment back blanks for clinging subsequent lines
                back_blanks = back_blanks + 1
                -- blank lines attach to the preceding block
                latest:addLine(l)
            else
                local isCodeHeader, level, l_trim = Codeblock.matchHead(l)
                if isCodeHeader then
                    code_block = true
                    if not tagging then
                        -- create a new block for the codeblock
                        latest.line_last = inset - 1
                        latest = Block(nil, inset, str)
                        latest[1] = Codeblock(level, l_trim, inset, str)
                        section[#section + 1] = latest
                    else
                        -- preserve existing block and add codeblock
                        tagging = false
                        latest[1] = Codeblock(level, l_trim, inset, str)
                    end
                elseif isTagline(l) then
                    tagging = true
                    -- apply cling rule
                    local fwd_blanks = fwdBlanks(section.lines, i)
                    if fwd_blanks > back_blanks then
                        latest:addLine(l)
                    else
                        -- new block
                        latest.line_last = inset - 1
                        latest = Block(l, inset, str)
                        section[#section + 1] = latest
                        back_blanks = 0
                    end                        
                else
                    if back_blanks > 0 and lead_blanks == false then
                        if not tagging then
                        -- new block
                            latest.line_last = inset - 1
                            latest = Block(l, inset, str)
                            section[#section + 1] = latest
                            back_blanks = 0
                        else
                            latest:addLine(l)
                            tagging = false
                        end 
                    else
                        -- continuing a block
                        lead_blanks = false
                        back_blanks = 0
                        latest:addLine(l)
                    end
                end
            end
        else
            -- Collecting a code block
            local isCodeFoot, level, l_trim = Codeblock.matchFoot(l)
            if (isCodeFoot and level == latest[1].level) then
                code_block = false
                latest[1].footer = l_trim
                latest[1].line_last = inset
            else
                latest[1].lines[#latest[1].lines + 1] = l
            end
            -- Continue in normal parse mode
            -- This may add more lines to the code block
        end
    end
    -- Auto-close a code block with no footer.
    if latest[1] and latest[1].id == \"codeblock\" and not latest[1].line_last then
        latest[1].line_last = #section.lines
    end

    -- Close last block
    latest.line_last = section.line_last

    -- Append sections, if any, which follow our blocks
    for _, v in ipairs(sub_sections) do
        section[#section + 1] = v
    end
    return section
end"]
section_11 -> { header_180 prose_181 prose_182 prose_183 section_184}
{rank=same; header_180 prose_181 prose_182 prose_183 section_184}

header_180 [label="2 : Blocking"]

prose_181 [label="prose"]

prose_182 [label="prose"]

prose_183 [label="prose"]

section_184 [label="section: 238-243"]


header_180 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Blocking"]
prose_181 -> { raw_186}
{rank=same; raw_186}

raw_186 [label="raw"]


raw_186 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Blocks a Section.
"]
prose_182 -> { raw_188}
{rank=same; raw_188}

raw_188 [label="raw"]


raw_188 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is a moderately complex state machine, which
works on a line-by-line basis with some lookahead.
"]
prose_183 -> { raw_190}
{rank=same; raw_190}

raw_190 [label="raw"]


raw_190 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
First off, we have a Header at [1], and may have one or 
more Sections The blocks go between the Header and the remaining
Sections, so we have to lift them and append after blocking.
 
Next, we parse the lines, thus:

"]
section_184 -> { header_192 prose_193}
{rank=same; header_192 prose_193}

header_192 [label="4 : Prose line"]

prose_193 [label="prose"]


header_192 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Prose line"]
prose_193 -> { raw_195}
{rank=same; raw_195}

raw_195 [label="raw"]


raw_195 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If preceded by at least one blank line,
make a new block, otherwise append to existing block.

"]
section_12 -> { header_197 prose_198 codeblock_199}
{rank=same; header_197 prose_198 codeblock_199}

header_197 [label="2 : Section:weed()"]

prose_198 [label="prose"]

codeblock_199 [label="code block 387-397"]


header_197 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Section:weed()"]
prose_198 -> { raw_201}
{rank=same; raw_201}

raw_201 [label="raw"]


raw_201 -> leaf_202
leaf_202  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This is a kludgy thing we're going to do to remove 'blocks' once they've
become either codeblocks or prose.
"]
codeblock_199 -> leaf_203
leaf_203  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.weed(section)
    for i, v in ipairs(section) do
        if v.id == \"block\" then
            if v[1] then
                section[i] = v[1]          
            end
        end
    end
end"]
section_13 -> { header_204 prose_205 prose_206 prose_207 codeblock_208}
{rank=same; header_204 prose_205 prose_206 prose_207 codeblock_208}

header_204 [label="2 : Section(header, linum)"]

prose_205 [label="prose"]

prose_206 [label="prose"]

prose_207 [label="prose"]

codeblock_208 [label="code block 411-437"]


header_204 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Section(header, linum)"]
prose_205 -> { raw_210}
{rank=same; raw_210}

raw_210 [label="raw"]


raw_210 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Creates a new section, given a header and the line number.
"]
prose_206 -> { raw_212}
{rank=same; raw_212}

raw_212 [label="raw"]


raw_212 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- header :  Header for the section, which may be of type Header or 
            a number.  A number means the header is virtual.
- linum  :  The line number of the header, which is the first of the
            Section.
"]
prose_207 -> { raw_214}
{rank=same; raw_214}

raw_214 [label="raw"]


raw_214 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- return :  The new Section.
"]
codeblock_208 -> leaf_216
leaf_216  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Section, header, linum, first, last, str)
    assert(type(first) == \"number\")
    assert(type(last) == \"number\", \"type of last is \" .. type(last))
    local section = setmetatable({}, Sec)
    if type(header) == \"number\" then
        -- We have a virtual header
        section[1] = Header(\"\", header, first, last, str)
        section.header = nil
        section.level = header
    else
        section[1] = header
        section.header = header
        section.level = header.level
    end
    section.str = str
    section.first = first
    section.last = last
    section.line_first = linum
    section.line_last = -1  
    section.lines = {}
    Sec.check(section)
    return section
end

return u.export(sec, new)"]

}
