digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 423"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-384"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}
{rank=same; header_2 block_3 block_4 block_5 block_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13}

header_2 [label="1 : Section metatable"]

block_3 [label="block 1-6"]

block_4 [label="block 7-9"]

block_5 [label="block 10-12"]

block_6 [label="block 13-384"]

section_7 [label="section: 16-21"]

section_8 [label="section: 22-29"]

section_9 [label="section: 47-80"]

section_10 [label="section: 129-172"]

section_11 [label="section: 210-223"]

section_12 [label="section: 367-384"]

section_13 [label="section: 385-423"]


header_2 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_3 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   Sections consist of a header and body.  The body may contain
 one or more blocks, followed by zero or more child sections.
"]
block_4 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" The header and block may both be virtual, but will always be
 present.
"]
block_5 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" In the first pass, we fill a lines array with the raw
 contents of the section. 
"]
block_6 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" This is subsequently refined into various blocks. 

"]
section_7 -> { header_19 block_20}
{rank=same; header_19 block_20}

header_19 [label="2 : Array"]

block_20 [label="block 16-21"]


header_19 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_20 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   The array portion of a section starts at [1] with a header. The
 rest consists, optionally, of nodes of types Block and Section.

"]
section_8 -> { header_23 block_24 section_25}
{rank=same; header_23 block_24 section_25}

header_23 [label="2 : Fields"]

block_24 [label="block 22-29"]

section_25 [label="section: 30-46"]


header_23 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_24 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - header : The header for the section.
 - level : The header level, lifted from the header for ease of use
 - lines : An array of the lines owned by the section. Note that 
           this doesn't include the header. 

"]
section_25 -> { header_28 block_29 codeblock_30}
{rank=same; header_28 block_29 codeblock_30}

header_28 [label="3 : Includes"]

block_29 [label="block 30-31"]

codeblock_30 [label="code block 32-44"]


header_28 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_29 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
codeblock_30 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"util\"
local status = require \"status\"

local Node = require \"node/node\"

local Header = require \"grym/header\"
local Block = require \"grym/block\"
local Codeblock = require \"grym/codeblock\"
local m = require \"grym/morphemes\""]
section_9 -> { header_34 block_35 codeblock_36 section_37 section_38}
{rank=same; header_34 block_35 codeblock_36 section_37 section_38}

header_34 [label="2 : Metatable for sections"]

block_35 [label="block 47-48"]

codeblock_36 [label="code block 49-64"]

section_37 [label="section: 67-80"]

section_38 [label="section: 81-103"]


header_34 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_35 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
codeblock_36 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Sec, sec = u.inherit(Node)
Sec.id = \"section\"

function Sec.__tostring(section)
    local phrase = \"\"
    for _,v in ipairs(section) do
        local repr = tostring(v)
        if (repr ~= \"\" and repr ~= \"\\n\") then
            phrase = phrase .. repr .. \"\\n\"
        end
    end

    return phrase
end"]
section_37 -> { header_42 block_43 block_44 codeblock_45}
{rank=same; header_42 block_43 block_44 codeblock_45}

header_42 [label="3 : dotLabel(section)"]

block_43 [label="block 67-70"]

block_44 [label="block 71-72"]

codeblock_45 [label="code block 73-78"]


header_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Produces a label for a dotfile.
"]
block_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- #return : string in dot format.
"]
codeblock_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.dotLabel(section)
    return \"section: \" .. tostring(section.line_first) 
        .. \"-\" .. tostring(section.line_last)
end"]
section_38 -> { header_50 block_51 block_52 block_53 codeblock_54 section_55}
{rank=same; header_50 block_51 block_52 block_53 codeblock_54 section_55}

header_50 [label="3 : toMarkdown(section)"]

block_51 [label="block 81-84"]

block_52 [label="block 85-86"]

block_53 [label="block 87-88"]

codeblock_54 [label="code block 89-102"]

section_55 [label="section: 104-128"]


header_50 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_51 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Translates the Section to markdown.
"]
block_52 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- section: the Section.
"]
block_53 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- #return: A Markdown string.  
"]
codeblock_54 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.toMarkdown(section)
    local phrase = \"\"
    for _, node in ipairs(section) do
        if node.toMarkdown then
            phrase = phrase .. node:toMarkdown()
        else 
            u.freeze(\"no toMarkdown method in \" .. node.id)
        end
    end

    return phrase
end"]
section_55 -> { header_61 block_62 codeblock_63}
{rank=same; header_61 block_62 codeblock_63}

header_61 [label="4 : asserts"]

block_62 [label="block 104-105"]

codeblock_63 [label="code block 106-126"]


header_61 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_62 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
codeblock_63 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.check(section)
    for i, v in ipairs(section) do
        if (i == 1) then
            if section.header then
                assert(v.id == \"header\")
            end
        else
            assert(v.id == \"section\" or v.id == \"block\")
        end
    end
    assert(section.level)
    assert(section.id == \"section\")
    assert(section.first, \"no first in \" .. tostring(section))
    assert(section.last, \"no last in \" .. tostring(section))
    assert(section.str, \"no str in \" .. tostring(section))
    assert(section.lines)
    assert(section.line_first)
    assert(section.line_last)
end"]
section_10 -> { header_67 block_68 block_69 block_70 codeblock_71 section_72 section_73}
{rank=same; header_67 block_68 block_69 block_70 codeblock_71 section_72 section_73}

header_67 [label="2 : addLine(section, line) "]

block_68 [label="block 129-132"]

block_69 [label="block 133-139"]

block_70 [label="block 140-141"]

codeblock_71 [label="code block 142-147"]

section_72 [label="section: 150-172"]

section_73 [label="section: 173-247"]


header_67 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_68 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Add a line to a section.
"]
block_69 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="These lines are later translated into blocks, and when the
parser is mature, =section.line= will be set to nil before
the Doc is returned.  
 
- section: the section
- line: the line
"]
block_70 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- return : the section
"]
codeblock_71 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.addLine(section, line)
    section.lines[#section.lines + 1] = line
    return section
end"]
section_72 -> { header_79 block_80 block_81 block_82 codeblock_83}
{rank=same; header_79 block_80 block_81 block_82 codeblock_83}

header_79 [label="3 : addSection(section, newsection, linum)"]

block_80 [label="block 150-153"]

block_81 [label="block 154-157"]

block_82 [label="block 158-159"]

codeblock_83 [label="code block 160-170"]


header_79 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_80 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Adds a section to the host section
"]
block_81 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- section:  Section to contain the new section.
- newsection:  The new section.
- linum:  The line number.
"]
block_82 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- #return: the parent section.
"]
codeblock_83 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.addSection(section, newsection, linum, finish)
    if linum > 0 then
        section.line_last = linum - 1
        assert(type(finish) == \"number\")
        section.last = finish
    end
    section[#section + 1] = newsection
    return section
end"]
section_73 -> { header_89 block_90 codeblock_91 block_92 block_93 block_94 codeblock_95 section_96 section_97 section_98 section_99}
{rank=same; header_89 block_90 codeblock_91 block_92 block_93 block_94 codeblock_95 section_96 section_97 section_98 section_99}

header_89 [label="3 : Helper Functions for Blocking"]

block_90 [label="block 173-176"]

codeblock_91 [label="code block 177-181"]

block_92 [label="block 184-185"]

block_93 [label="block 186-188"]

block_94 [label="block 189-190"]

codeblock_95 [label="code block 191-208"]

section_96 [label="section: 230-235"]

section_97 [label="section: 236-240"]

section_98 [label="section: 241-247"]

section_99 [label="section: 248-366"]


header_89 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_90 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Boolean match for a tagline
"]
codeblock_91 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function isTagline(line)
    return L.match(m.tagline_p, line)
end"]
block_92 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Lookahead, counting blank lines, return the number.
"]
block_93 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- lines: the full lines array of the section
- linum: current index into lines
"]
block_94 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- returns: number of blank lines forward of index
"]
codeblock_95 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function fwdBlanks(lines, linum)
    local fwd = 0
    local index = linum + 1
    if index > #lines then 
        return 0
    else 
        for i = index, #lines do
            if lines[i] == \"\" then
                fwd = fwd + 1
            else
                break
            end
        end
    end
    return fwd
end"]
section_96 -> { header_107 block_108}
{rank=same; header_107 block_108}

header_107 [label="4 : List line"]

block_108 [label="block 230-235"]


header_107 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_108 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
New block unless previous line is also list,
in which case append. 

"]
section_97 -> { header_111 block_112}
{rank=same; header_111 block_112}

header_111 [label="4 : Table line"]

block_112 [label="block 236-240"]


header_111 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_112 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Same as list.

"]
section_98 -> { header_115 block_116}
{rank=same; header_115 block_116}

header_115 [label="4 : Tag line "]

block_116 [label="block 241-247"]


header_115 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_116 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A tag needs to cling, so we need to check the
number of blank lines before and after a tag line, if any.
If even, a tag line clings down.

"]
section_99 -> { header_119 block_120 block_121 block_122 codeblock_123}
{rank=same; header_119 block_120 block_121 block_122 codeblock_123}

header_119 [label="4 : Code block"]

block_120 [label="block 248-252"]

block_121 [label="block 253-254"]

block_122 [label="block 255-256"]

codeblock_123 [label="code block 257-365"]


header_119 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_120 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A code block is anything between a code header and
either a code footer or the end of a file. 
"]
block_121 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- section : the Section to be blocked
"]
block_122 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- returns : the same Section, filled in with blocks
"]
codeblock_123 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.block(section)
    -- There is always a header at [1], though it may be nil
    -- If there are other Nodes, they are sections and must be appended
    -- after the blocks.
    local sub_sections = {}
    for i = 2, #section do
        sub_sections[#sub_sections + 1] = section[i]
        section[i] = nil
    end

    -- Every section gets at least one block, at [2], which may be empty.
    local latest = Block(nil, section.line_first) -- current block
    section[2] = latest

    -- State machine for blocking a section
    local back_blanks = 0
    -- first set of blank lines in a section belong to the first block
    local lead_blanks = true
    -- Track code blocks in own logic
    local code_block = false
    -- Tags also
    local tagging = false
    for i = 1, #section.lines do
        local inset = i + section.line_first
        local l = section.lines[i]
        if not code_block then
            if l == \"\" then 
                -- increment back blanks for clinging subsequent lines
                back_blanks = back_blanks + 1
                -- blank lines attach to the preceding block
                latest:addLine(l)
            else
                local isCodeHeader, level, l_trim = Codeblock.matchHead(l)
                if isCodeHeader then
                    code_block = true
                    if not tagging then
                        -- create a new block for the codeblock
                        latest.line_last = inset - 1
                        latest = Block(nil, inset)
                        latest[1] = Codeblock(level, l_trim, inset)
                        section[#section + 1] = latest
                    else
                        -- preserve existing block and add codeblock
                        tagging = false
                        latest[1] = Codeblock(level, l_trim, inset)
                    end
                elseif isTagline(l) then
                    tagging = true
                    -- apply cling rule
                    local fwd_blanks = fwdBlanks(section.lines, i)
                    if fwd_blanks > back_blanks then
                        latest:addLine(l)
                    else
                        -- new block
                        latest.line_last = inset - 1
                        latest = Block(l, inset)
                        section[#section + 1] = latest
                        back_blanks = 0
                    end                        
                else
                    if back_blanks > 0 and lead_blanks == false then
                        if not tagging then
                        -- new block
                            latest.line_last = inset - 1
                            latest = Block(l, inset)
                            section[#section + 1] = latest
                            back_blanks = 0
                        else
                            latest:addLine(l)
                            tagging = false
                        end 
                    else
                        -- continuing a block
                        lead_blanks = false
                        back_blanks = 0
                        latest:addLine(l)
                    end
                end
            end
        else
            -- Collecting a code block
            local isCodeFoot, level, l_trim = Codeblock.matchFoot(l)
            if (isCodeFoot and level == latest[1].level) then
                code_block = false
                latest[1].footer = l_trim
                latest[1].line_last = inset
            else
                latest[1].lines[#latest[1].lines + 1] = l
            end
            -- Continue in normal parse mode
            -- This may add more lines to the code block
        end
    end
    -- Auto-close a code block with no footer.
    if latest[1] and latest[1].id == \"codeblock\" and not latest[1].line_last then
        latest[1].line_last = #section.lines
    end

    -- Close last block
    latest.line_last = section.line_last

    -- Append sections, if any, which follow our blocks
    for _, v in ipairs(sub_sections) do
        section[#section + 1] = v
    end
    return section
end"]
section_11 -> { header_129 block_130 block_131 block_132 section_133}
{rank=same; header_129 block_130 block_131 block_132 section_133}

header_129 [label="2 : Blocking"]

block_130 [label="block 210-213"]

block_131 [label="block 214-216"]

block_132 [label="block 217-223"]

section_133 [label="section: 224-229"]


header_129 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_130 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Blocks a Section.
"]
block_131 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This is a moderately complex state machine, which
works on a line-by-line basis with some lookahead.
"]
block_132 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="First off, we have a Header at [1], and may have one or 
more Sections The blocks go between the Header and the remaining
Sections, so we have to lift them and append after blocking.
 
Next, we parse the lines, thus:

"]
section_133 -> { header_138 block_139}
{rank=same; header_138 block_139}

header_138 [label="4 : Prose line"]

block_139 [label="block 224-229"]


header_138 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_139 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If preceded by at least one blank line,
make a new block, otherwise append to existing block.

"]
section_12 -> { header_142 block_143 codeblock_144}
{rank=same; header_142 block_143 codeblock_144}

header_142 [label="2 : Section:weed()"]

block_143 [label="block 367-371"]

codeblock_144 [label="code block 372-382"]


header_142 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_143 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  This is a kludgy thing we're going to do to remove 'blocks' once they've
become either codeblocks or prose.
"]
codeblock_144 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Sec.weed(section)
    for i, v in ipairs(section) do
        if v.id == \"block\" then
            if v[1] then
                section[i] = v[1]          
            end
        end
    end
end"]
section_13 -> { header_148 block_149 block_150 block_151 codeblock_152}
{rank=same; header_148 block_149 block_150 block_151 codeblock_152}

header_148 [label="2 : Section(header, linum)"]

block_149 [label="block 385-388"]

block_150 [label="block 389-393"]

block_151 [label="block 394-395"]

codeblock_152 [label="code block 396-422"]


header_148 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_149 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Creates a new section, given a header and the line number.
"]
block_150 -> leaf_155
leaf_155  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- header :  Header for the section, which may be of type Header or 
            a number.  A number means the header is virtual.
- linum  :  The line number of the header, which is the first of the
            Section.
"]
block_151 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="- return :  The new Section.
"]
codeblock_152 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Section, header, linum, first, last, str)
    assert(type(first) == \"number\")
    assert(type(last) == \"number\", \"type of last is \" .. type(last))
    local section = setmetatable({}, Sec)
    if type(header) == \"number\" then
        -- We have a virtual header
        section[1] = Header(\"\", header)
        section.header = nil
        section.level = header
    else
        section[1] = header
        section.header = header
        section.level = header.level
    end
    section.str = str
    section.first = first
    section.last = last
    section.line_first = linum
    section.line_last = -1  
    section.lines = {}
    Sec.check(section)
    return section
end

return u.export(sec, new)"]

}
