digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 175"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-10"]


section_1 -> { header_2 block_3 block_4 block_5 section_6}
{rank=same; header_2 block_3 block_4 block_5 section_6}

header_2 [label="1 : Doc module"]

block_3 [label="block 1-4"]

block_4 [label="block 5-6"]

block_5 [label="block 7-10"]

section_6 [label="section: 11-175"]


block_3 -> { prose_7}
{rank=same; prose_7}

prose_7 [label="prose"]


prose_7 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Represents a Document, which is generally the same as a file, at first.
"]
block_4 -> { prose_9}
{rank=same; prose_9}

prose_9 [label="prose"]


prose_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" A document contains an array of blocks. 
"]
block_5 -> { prose_11}
{rank=same; prose_11}

prose_11 [label="prose"]


prose_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" At some point documents can also contain documents, this is not
 currently supported.

"]
section_6 -> { header_13 block_14 block_15 block_16 block_17 block_18 block_19 block_20 block_21 block_22 block_23 block_24 block_25 block_26 block_27}
{rank=same; header_13 block_14 block_15 block_16 block_17 block_18 block_19 block_20 block_21 block_22 block_23 block_24 block_25 block_26 block_27}

header_13 [label="2 : Fields"]

block_14 [label="block 11-21"]

block_15 [label="block 22-29"]

block_16 [label="block 30-32"]

block_17 [label="block 33-68"]

block_18 [label="block 69-71"]

block_19 [label="block 72-91"]

block_20 [label="block 92-93"]

block_21 [label="block 94-99"]

block_22 [label="block 100-102"]

block_23 [label="block 103-147"]

block_24 [label="block 148-149"]

block_25 [label="block 150-152"]

block_26 [label="block 153-155"]

block_27 [label="block 156-175"]


block_14 -> { prose_28}
{rank=same; prose_28}

prose_28 [label="prose"]


prose_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 In addition to the standard Node fields, a doc has:
 
 - latest: The current block.  This will be in `doc[#doc]` but may
           be several layers deep.
 - lastOf: An array containing references to the last block of a
           given level.

"]
block_15 -> { codeblock_30}
{rank=same; codeblock_30}

codeblock_30 [label="code block 22-28"]


codeblock_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local u = require \"lib/util\"

local Node = require \"peg/node\"
local Block = require \"grym/section\"
local own = require \"grym/own\""]
block_16 -> { prose_32}
{rank=same; prose_32}

prose_32 [label="prose"]


prose_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Metatable for Docs.

"]
block_17 -> { codeblock_34}
{rank=same; codeblock_34}

codeblock_34 [label="code block 33-67"]


codeblock_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local D = setmetatable({}, { __index = Node })

D.__tostring = function (doc)
    local phrase = \"\"
    for _,v in ipairs(doc) do
        local repr = tostring(v)
        if repr ~= \"\" and repr ~= \"\\n\" then
            phrase = phrase .. repr .. \"\\n\"
        end
    end

    return phrase 
end

D.__index = D

D.own = own

function D.dotLabel(doc)
    return \"doc - \" .. tostring(doc.linum)
end 

function D.toMarkdown(doc)
    local phrase = \"\"
    for _, node in ipairs(doc) do
        if node.toMarkdown then
            phrase = phrase .. node:toMarkdown()
        else 
            u.freeze(\"no toMarkdown method for \" .. node.id)
        end
    end
    return phrase
end"]
block_18 -> { prose_36}
{rank=same; prose_36}

prose_36 [label="prose"]


prose_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Doc constructor.

"]
block_19 -> { codeblock_38}
{rank=same; codeblock_38}

codeblock_38 [label="code block 72-90"]


codeblock_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local d = {}


function D.parentOf(doc, level)
    local i = level - 1
    local parent = nil
    while i > 0 do
        parent = doc.lastOf[i]
        if parent then
            return parent
        else
            i = i - 1
        end
    end

    return doc
end"]
block_20 -> { prose_40}
{rank=same; prose_40}

prose_40 [label="prose"]


prose_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Adds a block to a document.
"]
block_21 -> { prose_42}
{rank=same; prose_42}

prose_42 [label="prose"]


prose_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" This function looks at document level and places the block
 accordingly.
 
 - doc : the document
 - block : block to be appended
"]
block_22 -> { prose_44}
{rank=same; prose_44}

prose_44 [label="prose"]


prose_44 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" returns: the document

"]
block_23 -> { codeblock_46}
{rank=same; codeblock_46}

codeblock_46 [label="code block 103-145"]


codeblock_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function D.addSection(doc, section, linum)
    if not doc.latest then
        doc[1] =  section
    else
        if linum > 0 then
            doc.latest.line_last = linum - 1
        end
        local atLevel = doc.latest.level 
        if atLevel < section.level then
            -- add the section under the latest section
            doc.latest:addSection(section, linum)
        else
            local parentis = doc:parentOf(section.level)
            if parentis.id == \"doc\" then
                if section.level == 1 and doc.latest.level == 1 then
                    doc[#doc + 1] = section
                else
                    doc.latest:addSection(section, linum)
                end
            else
                parentis:addSection(section, linum)
            end
        end
    end
    doc.latest = section
    doc.lastOf[section.level] = section
    return doc
end

function D.addLine(doc, line, linum)
    if doc.latest then
        doc.latest:addLine(line)
    else
        -- a virtual zero block
        doc[1] = Block(0, linum)
        doc.latest = doc[1]
        doc.latest:addLine(line)
    end

    return doc
end"]
block_24 -> { prose_48}
{rank=same; prose_48}

prose_48 [label="prose"]


prose_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Creates a Doc Node.
"]
block_25 -> { structure_50 structure_51}
{rank=same; structure_50 structure_51}

structure_50 [label="structure"]

structure_51 [label="structure"]


structure_50 -> { handleline_52}
{rank=same; handleline_52}

handleline_52 [label="handleline"]


handleline_52 -> { handle_53}
{rank=same; handle_53}

handle_53 [label="handle"]


handle_53 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_51 -> { handleline_55}
{rank=same; handleline_55}

handleline_55 [label="handleline"]


handleline_55 -> { handle_56}
{rank=same; handle_56}

handle_56 [label="handle"]


handle_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_26 -> { structure_58}
{rank=same; structure_58}

structure_58 [label="structure"]


structure_58 -> { handleline_59}
{rank=same; handleline_59}

handleline_59 [label="handleline"]


handleline_59 -> { handle_60}
{rank=same; handle_60}

handle_60 [label="handle"]


handle_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_27 -> { codeblock_62}
{rank=same; codeblock_62}

codeblock_62 [label="code block 156-174"]


codeblock_62 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Doc, str)
    local doc = setmetatable({}, D)
    doc.str = str
    doc.id = \"doc\"
    doc.latest = nil
    doc.lines = {}
    doc.lastOf = {}
    -- for now lets set root to 'false'
    doc.root = false
    return doc:own(str)
end

setmetatable(D, Node)

d[\"__call\"] = new

return setmetatable({}, d)"]

}
