digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 169"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-139"]


section_1 -> { header_2 prose_3 codeblock_4 codeblock_5 section_6 section_7}
{rank=same; header_2 prose_3 codeblock_4 codeblock_5 section_6 section_7}

header_2 [label="1 : Prose module"]

prose_3 [label="prose"]

codeblock_4 [label="code block 5-22"]

codeblock_5 [label="code block 24-26"]

section_6 [label="section: 28-92"]

section_7 [label="section: 140-169"]


header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Prose module"]
prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Here we need a proper recursive parser.  Eventually.
"]
codeblock_4 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"util\"
local s = require (\"status\")()
local epeg = require \"epeg\"
local Csp = epeg.Csp
local Node = require \"node/node\"

local m = require \"grym/morphemes\"
local Link = require \"grym/link\"
local Richtext = require \"grym/richtext\"
local Grammar = require \"node/grammar\"


local Pr, pr = u.inherit(Node)
Pr.id = \"prose\""]
codeblock_5 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s.chatty = false  "]
section_6 -> { header_13 prose_14 prose_15 prose_16 prose_17 prose_18 prose_19 codeblock_20 codeblock_21 section_22}
{rank=same; header_13 prose_14 prose_15 prose_16 prose_17 prose_18 prose_19 codeblock_20 codeblock_21 section_22}

header_13 [label="2 : Bookend parsing"]

prose_14 [label="prose"]

prose_15 [label="prose"]

prose_16 [label="prose"]

prose_17 [label="prose"]

prose_18 [label="prose"]

prose_19 [label="prose"]

codeblock_20 [label="code block 54-76"]

codeblock_21 [label="code block 78-90"]

section_22 [label="section: 93-139"]


header_13 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Bookend parsing"]
prose_14 -> { raw_24 bold_25 raw_26 bold_27 raw_28 bold_29 raw_30}
{rank=same; raw_24 bold_25 raw_26 bold_27 raw_28 bold_29 raw_30}

raw_24 [label="raw"]

bold_25 [label="bold"]

raw_26 [label="raw"]

bold_27 [label="bold"]

raw_28 [label="raw"]

bold_29 [label="bold"]

raw_30 [label="raw"]


raw_24 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  We need to generate parsers to match sequences of single characters, so
that "]
bold_25 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bold"]
raw_26 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", "]
bold_27 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bold"]
raw_28 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", "]
bold_29 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bold"]
raw_30 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" etc all work correctly.
"]
prose_15 -> { raw_38 link_39 raw_40}
{rank=same; raw_38 link_39 raw_40}

raw_38 [label="raw"]

link_39 [label="link"]

raw_40 [label="raw"]


raw_38 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Bookends are a fun construct borrowed from the "]
link_39 -> { anchortext_42 url_43}
{rank=same; anchortext_42 url_43}

anchortext_42 [label="anchortext"]

url_43 [label="url"]


anchortext_42 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="LPEG manual"]
url_43 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_40 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="]]
model for Lua long strings.  The GGG/Pegylator form of a bookend construct
is 
"]
prose_16 -> { raw_47}
{rank=same; raw_47}

raw_47 [label="raw"]


raw_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
~#!peg
    bookend = \"`\":a !\"`\":a pattern  \"`\":a
~#/peg
"]
prose_17 -> { raw_49 literal_50 raw_51 literal_52 raw_53 literal_54 raw_55 literal_56 raw_57}
{rank=same; raw_49 literal_50 raw_51 literal_52 raw_53 literal_54 raw_55 literal_56 raw_57}

raw_49 [label="raw"]

literal_50 [label="literal"]

raw_51 [label="raw"]

literal_52 [label="literal"]

raw_53 [label="raw"]

literal_54 [label="literal"]

raw_55 [label="raw"]

literal_56 [label="literal"]

raw_57 [label="raw"]


raw_49 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The "]
literal_50 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
raw_51 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" engine doesn't model this directly but it's possible to provide
it.  We only need the subset of this where "]
literal_52 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="a"]
raw_53 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is unique, that is, "]
literal_54 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pattern"]
raw_55 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
does not contain "]
literal_56 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bookend"]
raw_57 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" at any level of expansion. 
"]
prose_18 -> { raw_67 bold_68 raw_69}
{rank=same; raw_67 bold_68 raw_69}

raw_67 [label="raw"]

bold_68 [label="bold"]

raw_69 [label="raw"]


raw_67 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
GGG being a specification format needn't respect this limitation.  Orb
does so by design.  It is a simple consquence of the sort of markup we are
using; there is no need to parse "]
bold_68 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bold **inside bold** still bold"]
raw_69 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" twice,
and this generalizes to all text styles. 
"]
prose_19 -> { raw_73}
{rank=same; raw_73}

raw_73 [label="raw"]


raw_73 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We do have to wire them up so that we don't cross the streams.  Sans macros.
By hand. 

"]
codeblock_20 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function equal_strings(s, i, a, b)
   -- Returns true if a and b are equal.
   -- s and i are not used, provided because expected by Cb.
   return a == b
end

local function bookends(sigil)
  local Cg, C, P, Cmt, Cb = L.Cg, L.C, L.P, L.Cmt, L.Cb
   -- Returns a pair of patterns, _open and _close,
   -- which will match a brace of sigil.
   -- sigil must be a string. 
   local _open = Cg(C(P(sigil)^1), sigil .. \"_init\")
   local _close =  Cmt(C(P(sigil)^1) * Cb(sigil .. \"_init\"), equal_strings)
   return _open, _close
end

local bold_open, bold_close     =  bookends(\"*\")
local italic_open, italic_close =  bookends(\"/\")
local under_open, under_close   =  bookends(\"_\")
local strike_open, strike_close =  bookends(\"-\")
local lit_open, lit_close       =  bookends(\"=\")"]
codeblock_21 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Pr.toMarkdown(prose)
   local phrase = \"\"
   for _, node in ipairs(prose) do
      if node.toMarkdown then
        phrase = phrase .. node:toMarkdown()
      elseif node.id == \"raw\" then
         phrase = phrase  .. node:toValue()
      end
   end
   return phrase
end"]
section_22 -> { header_77 prose_78 codeblock_79}
{rank=same; header_77 prose_78 codeblock_79}

header_77 [label="3 : prose grammar"]

prose_78 [label="prose"]

codeblock_79 [label="code block 98-137"]


header_77 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** prose grammar"]
prose_78 -> { raw_81}
{rank=same; raw_81}

raw_81 [label="raw"]


raw_81 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Prose module is the first one to use our shiny-new Node module.  Which
finally works the way I intend it to and I'm pretty happy about this. 
"]
codeblock_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function prose_gm(_ENV)
   START \"prose\"
   
   SUPPRESS (\"anchorboxed\", \"urlboxed\", \"richtext\",
             \"literalwrap\", \"boldwrap\")

   prose = (V\"link\" + V\"richtext\" + V\"raw\")^1

   link = m.sel * m.WS * V\"anchorboxed\" * m.WS * V\"urlboxed\" * m.ser
   anchorboxed = m.sel * m.WS * V\"anchortext\" * m.ser
   urlboxed = m.sel * m.WS * V\"url\" * m.WS * m.ser
   anchortext = m.anchor_text
   url = m.url

   richtext = V\"literalwrap\" + V\"boldwrap\" -- + V\"italic\" + V\"underlined\"
   literalwrap = lit_open * V\"literal\" * lit_close
   literal = (P(1) - lit_close)^1 -- This is not even close
   boldwrap = bold_open * V\"bold\" * bold_close
   bold = (P(1) - bold_close)^1

   -- This is the catch bucket.
   raw = (P(1) - (V\"link\" + V\"richtext\"))^1
end

local function proseBuild(prose, str)
   return setmetatable(prose, {__index = Pr})
end

local proseMetas = { prose = proseBuild,
                     link  = Link }

for k, v in pairs(Richtext) do
  proseMetas[k] = v
end

local parse = Grammar(prose_gm, proseMetas)  

"]
section_7 -> { header_84 prose_85 codeblock_86 codeblock_87}
{rank=same; header_84 prose_85 codeblock_86 codeblock_87}

header_84 [label="2 : Constructor"]

prose_85 [label="prose"]

codeblock_86 [label="code block 144-153"]

codeblock_87 [label="code block 155-157"]


header_84 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Constructor"]
prose_85 -> { raw_89 literal_90 raw_91}
{rank=same; raw_89 literal_90 raw_91}

raw_89 [label="raw"]

literal_90 [label="literal"]

raw_91 [label="raw"]


raw_89 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

- [ ] #todo smuggle in that offset in "]
literal_90 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="parse"]
raw_91 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_86 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Prose, block)
    local phrase = \"\\n\"
    for _,l in ipairs(block.lines) do
      phrase = phrase .. l .. \"\\n\"
    end
    local prose = parse(phrase, 0) 
    return prose
end"]
codeblock_87 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return u.export(pr, new)"]

}
