digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 150"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-120"]


section_1 -> { header_2 block_3 block_4 block_5 section_6 section_7}
{rank=same; header_2 block_3 block_4 block_5 section_6 section_7}

header_2 [label="1 : Prose module"]

block_3 [label="block 1-4"]

block_4 [label="block 5-25"]

block_5 [label="block 26-120"]

section_6 [label="section: 30-94"]

section_7 [label="section: 121-150"]


block_3 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Here we need a proper recursive parser.  Eventually.
"]
block_4 -> { codeblock_9}
{rank=same; codeblock_9}

codeblock_9 [label="code block 5-24"]


codeblock_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"util\"
local s = require (\"status\")()
local epnf = require \"peg/epnf\"
local epeg = require \"peg/epeg\"
local Csp = epeg.Csp
local Node = require \"node/node\"

local m = require \"grym/morphemes\"

local Link = require \"grym/link\"
assert(type(Link) == 'function')
local Grammar = require \"node/grammar\"


local Pr, pr = u.inherit(Node)
Pr.id = \"prose\""]
block_4 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_5 -> { codeblock_12}
{rank=same; codeblock_12}

codeblock_12 [label="code block 26-28"]


codeblock_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s.chatty = false  "]
block_5 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_6 -> { header_15 block_16 block_17 block_18 block_19 block_20 block_21 block_22 block_23 section_24}
{rank=same; header_15 block_16 block_17 block_18 block_19 block_20 block_21 block_22 block_23 section_24}

header_15 [label="2 : Bookend parsing"]

block_16 [label="block 30-34"]

block_17 [label="block 35-38"]

block_18 [label="block 39-42"]

block_19 [label="block 43-46"]

block_20 [label="block 47-51"]

block_21 [label="block 52-55"]

block_22 [label="block 56-79"]

block_23 [label="block 80-94"]

section_24 [label="section: 95-120"]


block_16 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  We need to generate parsers to match sequences of single characters, so
that *bold*, **bold**, ***bold*** etc all work correctly.
"]
block_17 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Bookends are a fun construct borrowed from the [[LPEG manual][httk://]]]]
model for Lua long strings.  The GGG/Pegylator form of a bookend construct
is 
"]
block_18 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="~#!peg
    bookend = \"`\":a !\"`\":a pattern  \"`\":a
~#/peg
"]
block_19 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="The =lpeg= engine doesn't model this directly but it's possible to provide
it.  We only need the subset of this where =a= is unique, that is, =pattern=
does not contain =bookend= at any level of expansion. 
"]
block_20 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="GGG being a specification format needn't respect this limitation.  Orb
does so by design.  It is a simple consquence of the sort of markup we are
using; there is no need to parse ***bold **inside bold** still bold*** twice,
and this generalizes to all text styles. 
"]
block_21 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="We do have to wire them up so that we don't cross the streams.  Sans macros.
By hand. 

"]
block_22 -> { codeblock_31}
{rank=same; codeblock_31}

codeblock_31 [label="code block 56-78"]


codeblock_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function equal_strings(s, i, a, b)
   -- Returns true if a and b are equal.
   -- s and i are not used, provided because expected by Cb.
   return a == b
end

local function bookends(sigil)
  local Cg, C, P, Cmt, Cb = L.Cg, L.C, L.P, L.Cmt, L.Cb
   -- Returns a pair of patterns, _open and _close,
   -- which will match a brace of sigil.
   -- sigil must be a string. 
   local _open = Cg(C(P(sigil)^1), sigil .. \"_init\")
   local _close =  Cmt(C(P(sigil)^1) * Cb(sigil .. \"_init\"), equal_strings)
   return _open, _close
end

local bold_open, bold_close     =  bookends(\"*\")
local italic_open, italic_close =  bookends(\"/\")
local under_open, under_close   =  bookends(\"_\")
local strike_open, strike_close =  bookends(\"-\")
local lit_open, lit_close       =  bookends(\"=\")"]
block_22 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_23 -> { codeblock_34}
{rank=same; codeblock_34}

codeblock_34 [label="code block 80-92"]


codeblock_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Pr.toMarkdown(prose)
   local phrase = \"\"
   for _, node in ipairs(prose) do
      if node.toMarkdown then
        phrase = phrase .. node:toMarkdown()
      elseif node.id == \"raw\" then
         phrase = phrase  .. node:toValue()
      end
   end
   return phrase
end"]
block_23 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_24 -> { header_37 block_38 block_39 block_40}
{rank=same; header_37 block_38 block_39 block_40}

header_37 [label="3 : prose grammar"]

block_38 [label="block 95-99"]

block_39 [label="block 100-101"]

block_40 [label="block 102-120"]


block_38 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  The Prose module is the first one to use our shiny-new Node module.  Which
finally works the way I intend it to and I'm pretty happy about this. 
"]
block_39 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="It's pure link-or-raw, but it has everything it needs to be so much more.
"]
block_40 -> { codeblock_43}
{rank=same; codeblock_43}

codeblock_43 [label="code block 102-118"]


codeblock_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function prose_gm(_ENV)
   START \"prose\"
   prose = (V\"link\" + V\"raw\")^1
   link = m.link
   raw = (P(1) - m.link)^1
end

local function proseBuild(prose, str)
   return setmetatable(prose, {__index = Pr })
end

local parse = Grammar(prose_gm, { prose = proseBuild,
                                  link  = Link })  

"]
block_40 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_7 -> { header_46 block_47 block_48 block_49}
{rank=same; header_46 block_47 block_48 block_49}

header_46 [label="2 : Constructor"]

block_47 [label="block 121-124"]

block_48 [label="block 125-135"]

block_49 [label="block 136-150"]


block_47 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo smuggle in that offset in =parse=
"]
block_48 -> { codeblock_51}
{rank=same; codeblock_51}

codeblock_51 [label="code block 125-134"]


codeblock_51 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Prose, block)
    local phrase = \"\\n\"
    for _,l in ipairs(block.lines) do
      phrase = phrase .. l .. \"\\n\"
    end
    local prose = parse(phrase, 0) 
    return prose
end"]
block_48 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_49 -> { codeblock_54}
{rank=same; codeblock_54}

codeblock_54 [label="code block 136-138"]


codeblock_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return u.export(pr, new)"]
block_49 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="










"]

}
