digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 148"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-118"]


section_1 -> { header_2}
{rank=same; header_2}

header_2 [label="1 : Prose module"]


codeblock_3 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local u = require \"util\"
local s = require (\"status\")()
local epnf = require \"peg/epnf\"
local epeg = require \"peg/epeg\"
local Csp = epeg.Csp
local Node = require \"node/node\"

local m = require \"grym/morphemes\"

local Link = require \"grym/link\"
local Grammar = require \"node/grammar\"


local Pr, pr = u.inherit(Node)
Pr.id = \"prose\""]
codeblock_4 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s.chatty = false  "]
section_5 -> { header_9}
{rank=same; header_9}

header_9 [label="2 : Bookend parsing"]


codeblock_10 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function equal_strings(s, i, a, b)
   -- Returns true if a and b are equal.
   -- s and i are not used, provided because expected by Cb.
   return a == b
end

local function bookends(sigil)
  local Cg, C, P, Cmt, Cb = L.Cg, L.C, L.P, L.Cmt, L.Cb
   -- Returns a pair of patterns, _open and _close,
   -- which will match a brace of sigil.
   -- sigil must be a string. 
   local _open = Cg(C(P(sigil)^1), sigil .. \"_init\")
   local _close =  Cmt(C(P(sigil)^1) * Cb(sigil .. \"_init\"), equal_strings)
   return _open, _close
end

local bold_open, bold_close     =  bookends(\"*\")
local italic_open, italic_close =  bookends(\"/\")
local under_open, under_close   =  bookends(\"_\")
local strike_open, strike_close =  bookends(\"-\")
local lit_open, lit_close       =  bookends(\"=\")"]
codeblock_11 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Pr.toMarkdown(prose)
   local phrase = \"\"
   for node in prose:walk() do
      if node.id == \"link\" then
         phrase = phrase .. \"~~\" .. node:toValue()
      elseif node.id == \"raw\" then
         phrase = phrase  .. node:toValue()
      end
   end
   return phrase
end"]
section_12 -> { header_15}
{rank=same; header_15}

header_15 [label="3 : prose grammar"]


codeblock_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function prose_gm(_ENV)
   START \"prose\"
   prose = (V\"link\" + V\"raw\")^1
   link = m.link
   raw = (P(1) - m.link)^1
end

local function proseBuild(prose, str)
   return setmetatable(prose, Pr)
end

local parse = Grammar(prose_gm, { prose = proseBuild})  

"]
section_6 -> { header_18}
{rank=same; header_18}

header_18 [label="2 : Constructor"]


codeblock_19 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Prose, block)
    local phrase = \"\\n\"
    for _,l in ipairs(block.lines) do
      phrase = phrase .. l .. \"\\n\"
    end
    local prose = parse(phrase, 0) 
    return prose
end"]
codeblock_20 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return u.export(pr, new)"]

}
