digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 125"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-125"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9}

header_2 [label="1 : Grimoire Grammar"]

block_3 [label="block 1-3"]

block_4 [label="block 4-28"]

block_5 [label="block 29-32"]

block_6 [label="block 33-35"]

block_7 [label="block 36-58"]

block_8 [label="block 59-64"]

block_9 [label="block 65-125"]


block_3 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_4 -> { codeblock_11}
{rank=same; codeblock_11}

codeblock_11 [label="code block 4-24"]


codeblock_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local lpeg = require \"lpeg\"
local epeg = require \"../peg/epeg\"
local epnf = require \"../peg/epnf\"

local match = lpeg.match -- match a pattern against a string
local P = lpeg.P -- match a string literally
local S = lpeg.S  -- match anything in a set
local R = epeg.R  -- match anything in a range
local B = lpeg.B  -- match iff the pattern precedes the use of B
local C = lpeg.C  -- captures a match
local Csp = epeg.Csp -- captures start and end position of match
local Cg = lpeg.Cg -- named capture group (for **balanced highlighting**)
local Cb = lpeg.Cb -- Back capture
local Cmt = lpeg.Cmt -- match-time capture
local Ct = lpeg.Ct -- a table with all captures from the pattern
local V = lpeg.V -- create a variable within a grammar

local letter = R\"AZ\" + R\"az\"   
local digit = R\"09\""]
block_4 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Punctuation is valid inside of prose blocks, even with leading
 whitespace
"]
block_5 -> { codeblock_14}
{rank=same; codeblock_14}

codeblock_14 [label="code block 29-31"]


codeblock_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local punctuation = S\"!?,.:;\\\\^%~\""]
block_5 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_6 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Interior symbols are valid within a prose word, but not if 
 preceded by whitespace
"]
block_7 -> { codeblock_18}
{rank=same; codeblock_18}

codeblock_18 [label="code block 36-57"]


codeblock_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local interior = S\"*_-/@#\"
local sym = letter + digit + punctuation + interior
local first_letter = letter + digit + punctuation
local WS = P' ' + P',' + P'\\09' -- Not accurate, refine (needs Unicode spaces)
local NL = P\"\\n\"

local function equal_strings(s, i, a, b)
   -- Returns true if a and b are equal.
   -- s and i are not used, provided because expected by Cb.
   return a == b
end

local function bookends(sigil)
   -- Returns a pair of patterns, _open and _close,
   -- which will match a brace of sigil.
   -- sigil must be a string. 
   local _open = Cg(C(P(sigil)^1), sigil .. \"_init\")
   local _close =  Cmt(C(P(sigil)^1) * Cb(sigil .. \"_init\"), equal_strings)
   return _open, _close
end"]
block_7 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_8 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" The Grimoire grammar is a specially-massaged closure to be executed
 in the epnf context. 
 
 The advantage of this approach is that we can make it look much like an
 actual grammar. This should aid in porting to target languages. 
"]
block_9 -> { codeblock_22}
{rank=same; codeblock_22}

codeblock_22 [label="code block 65-124"]


codeblock_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local _grym_fn = function ()
   local function grymmyr (_ENV)
      START \"grym\"
      SUPPRESS (\"structure\", \"structured\")

      local prose_word = first_letter * (sym^1)^0
      local prose_span = (prose_word + WS^1)^1
      local NEOL = NL + -P(1)
      local LS = B(\"\\n\") + -B(1)

      grym      =  V\"section\"^1 * V\"unparsed\"^0

      section   =  (V\"header\" * V\"block\"^0) + V\"block\"^1

      structure =  V\"blank_line\" -- list, table, json, comment...

      header     =  LS * V\"lead_ws\" * V\"lead_tar\" * V\"prose_line\"
      lead_ws    =  Csp(P\" \"^0)
      lead_tar   =  Csp(P\"*\"^-6 * P\" \")
      prose_line =  Csp(prose_span * NEOL)

      block =  (V\"structure\"^1 + V\"prose\"^1)^1 * #V\"block_end\"

      prose        =  (V\"structured\" + V\"unstructured\")^1
      unstructured =  Csp(V\"prose_line\"^1 * prose_span + V\"prose_line\"^1
                     + prose_span -V\"header\")
      structured   =  V\"bold\" + V\"italic\" + V\"underscore\" + V\"strikethrough\"
                     + V\"literal\" + V\"quoted\"

      unparsed = Csp(P(1)^1)

      -- Highlighting
      -- These inner blocks will need to be re-parsed to render, e.g., links
      -- or multiple layers of highlight. 
      local bold_open, bold_close     =  bookends(\"*\")
      local italic_open, italic_close =  bookends(\"/\")
      local under_open, under_close   =  bookends(\"_\")
      local strike_open, strike_close =  bookends(\"-\")
      local lit_open, lit_close       =  bookends(\"=\")
      bold   =  Csp(bold_open * (P(1) - bold_close)^0 * bold_close / 1) - V\"header\"
      italic =  Csp(italic_open * (P(1) - italic_close)^0 * italic_close / 1)
      underscore = Csp(under_open * (P(1) - under_close)^0 * under_close / 1)
      strikethrough = Csp(strike_open * (P(1) - strike_close)^0 * strike_close / 1)
      literal = Csp(lit_open * (P(1) - lit_close)^0 * lit_close / 1)

      local quoted_open = Cg(C(P(\"\\\"\")^2), \"quoted_init\")
      local quoted_close = Cmt(C(P(\"\\\"\")^1) * Cb(\"quoted_init\"), equal_strings)
      quoted = Csp(quoted_open * (P(1) - quoted_close)^0 * quoted_close / 1)

      block_end = V\"blank_line\"^1 + -P(1) + #V\"header\"

      blank_line = Csp((WS^0 * NL)^1)
   end

   return grymmyr
end

return epnf.define(_grym_fn(), nil, false)"]
block_9 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

}
