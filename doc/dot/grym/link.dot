digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 79"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-17"]


section_1 -> { header_2 block_3 block_4 block_5 section_6}
{rank=same; header_2 block_3 block_4 block_5 section_6}

header_2 [label="1 : Link module"]

block_3 [label="block 1-2"]

block_4 [label="block 3-12"]

block_5 [label="block 13-17"]

section_6 [label="section: 18-74"]


block_3 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_4 -> { codeblock_8}
{rank=same; codeblock_8}

codeblock_8 [label="code block 3-10"]


codeblock_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local m = require \"grym/morphemes\"
local u = require \"util\"

local Node = require \"node/node\""]
block_4 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_5 -> { codeblock_11}
{rank=same; codeblock_11}

codeblock_11 [label="code block 13-16"]


codeblock_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Li, li = u.inherit(Node)
Li.id = \"link\""]
block_5 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_6 -> { header_14 block_15 section_16 section_17 section_18}
{rank=same; header_14 block_15 section_16 section_17 section_18}

header_14 [label="2 : Transformers"]

block_15 [label="block 18-74"]

section_16 [label="section: 20-30"]

section_17 [label="section: 31-74"]

section_18 [label="section: 75-79"]


block_15 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_16 -> { header_20 block_21 block_22}
{rank=same; header_20 block_21 block_22}

header_20 [label="3 : toMarkdown"]

block_21 [label="block 20-21"]

block_22 [label="block 22-30"]


block_21 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_22 -> { codeblock_24}
{rank=same; codeblock_24}

codeblock_24 [label="code block 22-29"]


codeblock_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Li.toMarkdown(link)
  url = link.url or \"\"
  prose = link.prose or \"\"
  return \"[\" .. prose .. \"]\"
      .. \"(\" .. url .. \")\"
end"]
block_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_16 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** toMarkdown

#!lua
function Li.toMarkdown(link)
	url = link.url or \"\"
	prose = link.prose or \"\"
	return \"[\" .. prose .. \"]\"
			.. \"(\" .. url .. \")\"
end
#/lua

*** dot"]
section_17 -> { header_28 block_29 block_30 block_31 block_32 block_33}
{rank=same; header_28 block_29 block_30 block_31 block_32 block_33}

header_28 [label="3 : dotLabel"]

block_29 [label="block 31-32"]

block_30 [label="block 33-38"]

block_31 [label="block 39-55"]

block_32 [label="block 56-66"]

block_33 [label="block 67-74"]


block_29 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_30 -> { codeblock_35}
{rank=same; codeblock_35}

codeblock_35 [label="code block 33-37"]


codeblock_35 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Li.dotLabel(link)
  return \"link: \" .. link.prose
end"]
block_30 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_31 -> { codeblock_38}
{rank=same; codeblock_38}

codeblock_38 [label="code block 39-52"]


codeblock_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Li.parse(link, line)
  -- This only parses double links, expand
  local WS, sel, ser = m.WS, m.sel, m.ser
  local link_content = L.match(L.Ct(sel * WS * sel * L.C(m.link_prose)
                * ser * WS * sel * L.C(m.url) * WS * ser * WS * ser),
                line)
  if link_content then
    link.prose = link_content[1] or \"\"
    link.url   = link_content[2] or \"\"
  end
  return link
end"]
block_31 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
block_32 -> { codeblock_41}
{rank=same; codeblock_41}

codeblock_41 [label="code block 56-64"]


codeblock_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Link, line)
  local link = setmetatable({},Li)
  link.id = \"link\"
  link.val = line -- refine this
  link:parse(line)
  return link
end"]
block_32 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_33 -> { codeblock_44}
{rank=same; codeblock_44}

codeblock_44 [label="code block 67-73"]


codeblock_44 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function linkbuild(link, str)
  io.write(\"   ~~ built a link\\n\")
  setmetatable(link, Li)
  return Li.parse(link, str:sub(link.first, link.last))
end"]
block_33 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_17 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tLabel

#!lua
function Li.dotLabel(link)
	return \"link: \" .. link.prose
end
#/lua

#!lua
function Li.parse(link, line)
	-- This only parses double links, expand
	local WS, sel, ser = m.WS, m.sel, m.ser
	local link_content = L.match(L.Ct(sel * WS * sel * L.C(m.link_prose)
								* ser * WS * sel * L.C(m.url) * WS * ser * WS * ser),
								line)
	if link_content then
		link.prose = link_content[1] or \"\"
		link.url   = link_content[2] or \"\"
	end
	return link
end
#/lua



#!lua
local function new(Link, line)
	local link = setmetatable({},Li)
	link.id = \"link\"
	link.val = line -- refine this
	link:parse(line)
	return link
end
#/lua


#!lua
local function linkbuild(link, str)
	io.write(\"   ~~ built a link\\n\")
	setmetatable(link, Li)
	return Li.parse(link, str:sub(link.first, link.last))
end
#/lua

*** export

#!lua
return linkbuild
#/lua"]
section_18 -> { header_48 block_49 block_50}
{rank=same; header_48 block_49 block_50}

header_48 [label="3 : export"]

block_49 [label="block 75-76"]

block_50 [label="block 77-79"]


block_49 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_50 -> { codeblock_52}
{rank=same; codeblock_52}

codeblock_52 [label="code block 77-79"]


codeblock_52 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return linkbuild"]
block_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_18 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_6 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Transformers

*** toMarkdown

#!lua
function Li.toMarkdown(link)
	url = link.url or \"\"
	prose = link.prose or \"\"
	return \"[\" .. prose .. \"]\"
			.. \"(\" .. url .. \")\"
end
#/lua

*** dotLabel

#!lua
function Li.dotLabel(link)
	return \"link: \" .. link.prose
end
#/lua

#!lua
function Li.parse(link, line)
	-- This only parses double links, expand
	local WS, sel, ser = m.WS, m.sel, m.ser
	local link_content = L.match(L.Ct(sel * WS * sel * L.C(m.link_prose)
								* ser * WS * sel * L.C(m.url) * WS * ser * WS * ser),
								line)
	if link_content then
		link.prose = link_content[1] or \"\"
		link.url   = link_content[2] or \"\"
	end
	return link
end
#/lua



#!lua
local function new(Link, line)
	local link = setmetatable({},Li)
	link.id = \"link\"
	link.val = line -- refine this
	link:parse(line)
	return link
end
#/lua


#!lua
local function linkbuild(link, str)
	io.write(\"   ~~ built a link\\n\")
	setmetatable(link, Li)
	return Li.parse(link, str:sub(link.first, link.last))
end
#/lua

*** export

#!lua
return linkbuild
#/lua"]
section_1 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Link module

#!lua
local L = require \"lpeg\"

local m = require \"grym/morphemes\"
local u = require \"util\"

local Node = require \"node/node\"
#/lua


#!lua
local Li, li = u.inherit(Node)
Li.id = \"link\"
#/lua

*"]

}
