digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 150"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-48"]


section_1 -> { header_2 block_3 block_4 block_5 codeblock_6 section_7}
{rank=same; header_2 block_3 block_4 block_5 codeblock_6 section_7}

header_2 [label="1 : Ownership function"]

block_3 [label="block 1-5"]

block_4 [label="block 6-8"]

block_5 [label="block 9-13"]

codeblock_6 [label="code block 14-46"]

section_7 [label="section: 49-150"]


header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_3 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Taking a multi-pass approach to this Grimoire instance will benefit us 
in a few ways. 
"]
block_4 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="First, Grimoire itself is structured in a certain fashion. The 
straightforward thing is to mirror that fashion in code.
"]
block_5 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Second, the critical path right now is simple code generation from 
Grimoire documents. Parsing prose gets useful later, for now I simply
wish to unravel some existing code into Grimoire format and start working
on it accordingly. 
"]
codeblock_6 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local epeg = require \"peg/epeg\"

local util = require \"../lib/util\"
local freeze = util.freeze

local Csp = epeg.Csp

local a = require \"../lib/ansi\"
local u = require \"lib/util\"


local ast = require \"peg/ast\"

local Node = require \"peg/node\"

local m = require \"grym/morphemes\"

local Header = require \"grym/header\"
local Section = require \"grym/section\"
local Block = require \"grym/block\"
local Codeblock = require \"grym/codeblock\"

local own = {}

local blue = tostring(a.blue)
local red = tostring(a.red)
local dim = tostring(a.dim)
local green = tostring(a.green)
local cl   = tostring(a.clear)"]
section_7 -> { header_13 block_14 codeblock_15 block_16 codeblock_17}
{rank=same; header_13 block_14 codeblock_15 block_16 codeblock_17}

header_13 [label="3 : Helper functions for own.parse"]

block_14 [label="block 49-54"]

codeblock_15 [label="code block 55-65"]

block_16 [label="block 68-71"]

codeblock_17 [label="code block 72-149"]


header_13 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_14 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Trims leading whitespace, returning the amount taken and
the trimmed string.
 
"]
codeblock_15 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function lead_whitespace(str)
    local lead_ws = L.match(m.WS, str)
    if lead_ws > 1 then
        --  io.write(green..(\"%\"):rep(lead_ws - 1)..cl)
        return lead_ws, str:sub(lead_ws)
    else
        return 0, str
    end
end"]
block_16 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Takes a string, parsing ownership.
 Returns a Doc.

"]
codeblock_17 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function own(doc, str)
    local linum = 1
    local doc_level = 0
    local start = 1
    local num_lines = #(epeg.split(str,\"\\n\"))
    -- Track code blocks separately to avoid `* A` type collisions in code
    local code_block = false
    for _, line in ipairs(epeg.split(str, \"\\n\")) do
        
        -- tab and return filtration
        local l, err = line:gsub(\"\\t\", \"  \"):gsub(\"\\r\", \"\") 
        local finish = start + #l
        -- We should always have a string but..
        if l then
            if not code_block then
                local indent, l_trim = lead_whitespace(l)
                local code_head = Codeblock.matchHead(l)
                if code_head then 
                    code_block = true 
                end
                local isHeader, level, bareline = Header.match(l_trim) 

                if isHeader then              
                    local header = Header(bareline, level, start, finish, doc)

                    -- make new block and append to doc
                    doc:addSection(Section(header, linum, start, finish, doc.str), 
                                      linum, start)

                else 
                    doc:addLine(l, linum, finish)
                end
            else 
                -- code block logic, including restarts
                --
                -- NOTE that this will choke on unmatched code headers,
                -- which I intend to fix. But it's fiddly.
                local code_foot = Codeblock.matchFoot(l)
                if code_foot then 
                    code_block = false
                end
                doc:addLine(l, linum, finish)
            end
        elseif ER then
            freeze(\"HUH?\")
        end
        linum = linum + 1
        start = finish
        if linum < num_lines then start = start + 1 end
    end
    if (doc.latest) then
        doc.latest.line_last = linum - 1
        assert(type(start) == 'number')
        doc.latest.last = start
    else
        assert(false, \"no doc.latest\")
    end
    local sections = doc:select(\"section\")
    for _, s in ipairs(sections) do
        s:check()
        s:block()
        s:weed()
    end
    local blocks = doc:select(\"block\")
    for _, v in ipairs(blocks) do
        v:toValue()
    end
    local cbs = doc:select(\"codeblock\")
    for _, v in ipairs(cbs) do
        v:toValue()
    end
    doc.linum = linum - 1
    return doc
end

return own"]

}
