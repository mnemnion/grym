digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 157"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-15"]


section_1 -> { header_2 prose_3 prose_4 section_5}
{rank=same; header_2 prose_3 prose_4 section_5}

header_2 [label="1 : Code Block Module"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 16-76"]


prose_3 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


   Code blocks are the motivating object for Grimoire.  Perforce they
 will do a lot of the heavy lifting.
"]
prose_4 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 From the compiler's perspective, Code, Structure, and Prose are the
 three basic genres of Grimmorian text.  In this implementation,
 you may think of Code as a clade diverged early from both Structure
 and Prose, with some later convergence toward the former. 
 
 Specifically, Structure and Prose will actually inherit from Block, and
 Code block, name notwithstanding, merely imitates some behaviours.
 
"]
section_5 -> { header_8 prose_9 prose_10 codeblock_11 prose_12 codeblock_13 section_14}
{rank=same; header_8 prose_9 prose_10 codeblock_11 prose_12 codeblock_13 section_14}

header_8 [label="2 : Fields"]

prose_9 [label="prose"]

prose_10 [label="prose"]

codeblock_11 [label="code block 36-48"]

prose_12 [label="prose"]

codeblock_13 [label="code block 53-75"]

section_14 [label="section: 77-157"]


prose_9 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


   Codeblock inherits from Node directly, and is born with these 
 additional fields:
"]
prose_10 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - level  :  The number of !s, which is the number of / needed to close
             the block.
 - header :  The line after # and at least one !.
 - footer :  The line closing the block. Optional, as a code block may
             end a file without a closing line.
 - lines  :  Array containing the lines of code.  Header and footer
             are not included.
 - line_first :  The first (header) line of the block. 
 - line_last  :  The closing line of the block. Note that code blocks also
                 collect blank lines and may have a clinging tag. 
 
 To be added:
 - [ ] lang : The language, derived from the header line.
"]
codeblock_11 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"peg/node\"

local m = require \"grym/morphemes\"

local CB = setmetatable({}, Node)

CB.__index = CB

CB.__tostring = function() return \"codeblock\" end"]
prose_12 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Adds a .val field which is the union of all lines.
 Useful in visualization. 
"]
codeblock_13 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function CB.toValue(codeblock)
    codeblock.val = \"\"
    for _,v in ipairs(codeblock.lines) do
        codeblock.val = codeblock.val .. v .. \"\\n\"
    end

    return codeblock.val
end

function CB.toMarkdown(codeblock)
  -- hardcode lua
  return \"```\" .. codeblock.lang .. \"\\n\" 
         .. codeblock:toValue() .. \"```\\n\"
end

function CB.dotLabel(codeblock)
    return \"code block \" .. tostring(codeblock.line_first)
        .. \"-\" .. tostring(codeblock.line_last)
end

local cb = {}"]
section_14 -> { header_20 prose_21 codeblock_22 prose_23 codeblock_24 prose_25 prose_26 codeblock_27 prose_28 codeblock_29}
{rank=same; header_20 prose_21 codeblock_22 prose_23 codeblock_24 prose_25 prose_26 codeblock_27 prose_28 codeblock_29}

header_20 [label="3 : asserts"]

prose_21 [label="prose"]

codeblock_22 [label="code block 79-84"]

prose_23 [label="prose"]

codeblock_24 [label="code block 97-108"]

prose_25 [label="prose"]

prose_26 [label="prose"]

codeblock_27 [label="code block 122-133"]

prose_28 [label="prose"]

codeblock_29 [label="code block 137-156"]


prose_21 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_22 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function CB.check(codeblock)
  assert(codeblock.line_first)
  assert(codeblock.line_last)
end"]
prose_23 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - #args
   - str :  The string to match against.
 
 - #return 3
   - boolean :  For header match
   - number  :  Level of header
   - string  :  Header stripped of left whitespace and tars

"]
codeblock_24 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function cb.matchHead(str)
    if str ~= \"\" and L.match(m.codestart, str) then
        local trimmed = str:sub(L.match(m.WS * m.hax, str))
        local level = L.match(m.zaps, trimmed) - 1
        local bareline = trimmed:sub(L.match(m.zaps, trimmed))
        return true, level, bareline
    else 
        return false, 0, \"\"
    end
end"]
prose_25 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Matches a code block footer line.
"]
prose_26 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - #args
   - str   :  The string to match against.
   - level :  Required level for a match.
 
 - #return 3
   - boolean :  For footer match
   - number  :  Level of header
   - string  :  Header stripped of left whitespace and tars

"]
codeblock_27 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function cb.matchFoot(str)
    if str ~= \"\" and L.match(m.codefinish, str) then
        local trimmed = str:sub(L.match(m.WS * m.hax    , str))
        local level = L.match(m.fass, trimmed) - 1
        local bareline = trimmed:sub(L.match(m.fass, trimmed))
        return true, level, bareline
    else 
        return false, 0, \"\"
    end
end"]
prose_28 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Constructor
"]
codeblock_29 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Codeblock, level, headline, linum)
    local codeblock = setmetatable({}, CB)
    codeblock.id = \"codeblock\"
    codeblock.level = level
    codeblock.header = headline
    codeblock.lang = L.match(L.C(m.symbol), headline) or \"\"
    codeblock.footer = \"\"
    codeblock.line_first = linum
    codeblock.lines = {}

    return codeblock
end


cb.__call = new
cb.__index = cb

return setmetatable({}, cb)"]

}
