digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 157"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-15"]


section_1 -> { header_2 block_3 block_4 section_5}
{rank=same; header_2 block_3 block_4 section_5}

header_2 [label="1 : Code Block Module"]

block_3 [label="block 1-6"]

block_4 [label="block 7-15"]

section_5 [label="section: 16-76"]


block_3 -> { prose_6}
{rank=same; prose_6}

prose_6 [label="prose"]


prose_6 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   Code blocks are the motivating object for Grimoire.  Perforce they
 will do a lot of the heavy lifting.
"]
block_4 -> { prose_8}
{rank=same; prose_8}

prose_8 [label="prose"]


prose_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" From the compiler's perspective, Code, Structure, and Prose are the
 three basic genres of Grimmorian text.  In this implementation,
 you may think of Code as a clade diverged early from both Structure
 and Prose, with some later convergence toward the former. 
 
 Specifically, Structure and Prose will actually inherit from Block, and
 Code block, name notwithstanding, merely imitates some behaviours.
 
"]
section_5 -> { header_10 block_11 block_12 block_13 block_14 block_15 section_16}
{rank=same; header_10 block_11 block_12 block_13 block_14 block_15 section_16}

header_10 [label="2 : Fields"]

block_11 [label="block 16-21"]

block_12 [label="block 22-35"]

block_13 [label="block 36-49"]

block_14 [label="block 50-52"]

block_15 [label="block 53-76"]

section_16 [label="section: 77-157"]


block_11 -> { prose_17}
{rank=same; prose_17}

prose_17 [label="prose"]


prose_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   Codeblock inherits from Node directly, and is born with these 
 additional fields:
"]
block_12 -> { prose_19}
{rank=same; prose_19}

prose_19 [label="prose"]


prose_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - level  :  The number of !s, which is the number of / needed to close
             the block.
 - header :  The line after # and at least one !.
 - footer :  The line closing the block. Optional, as a code block may
             end a file without a closing line.
 - lines  :  Array containing the lines of code.  Header and footer
             are not included.
 - line_first :  The first (header) line of the block. 
 - line_last  :  The closing line of the block. Note that code blocks also
                 collect blank lines and may have a clinging tag. 
 
 To be added:
 - [ ] lang : The language, derived from the header line.
"]
block_13 -> { codeblock_21}
{rank=same; codeblock_21}

codeblock_21 [label="code block 36-48"]


codeblock_21 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"peg/node\"

local m = require \"grym/morphemes\"

local CB = setmetatable({}, Node)

CB.__index = CB

CB.__tostring = function() return \"codeblock\" end"]
block_14 -> { prose_23}
{rank=same; prose_23}

prose_23 [label="prose"]


prose_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Adds a .val field which is the union of all lines.
 Useful in visualization. 
"]
block_15 -> { codeblock_25}
{rank=same; codeblock_25}

codeblock_25 [label="code block 53-75"]


codeblock_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function CB.toValue(codeblock)
    codeblock.val = \"\"
    for _,v in ipairs(codeblock.lines) do
        codeblock.val = codeblock.val .. v .. \"\\n\"
    end

    return codeblock.val
end

function CB.toMarkdown(codeblock)
  -- hardcode lua
  return \"```\" .. codeblock.lang .. \"\\n\" 
         .. codeblock:toValue() .. \"```\\n\"
end

function CB.dotLabel(codeblock)
    return \"code block \" .. tostring(codeblock.line_first)
        .. \"-\" .. tostring(codeblock.line_last)
end

local cb = {}"]
section_16 -> { header_27 block_28 block_29 block_30 block_31 block_32 block_33 block_34 block_35 block_36}
{rank=same; header_27 block_28 block_29 block_30 block_31 block_32 block_33 block_34 block_35 block_36}

header_27 [label="3 : asserts"]

block_28 [label="block 77-78"]

block_29 [label="block 79-87"]

block_30 [label="block 88-96"]

block_31 [label="block 97-109"]

block_32 [label="block 110-111"]

block_33 [label="block 112-121"]

block_34 [label="block 122-134"]

block_35 [label="block 135-136"]

block_36 [label="block 137-157"]


block_28 -> { prose_37}
{rank=same; prose_37}

prose_37 [label="prose"]


prose_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_29 -> { codeblock_39}
{rank=same; codeblock_39}

codeblock_39 [label="code block 79-84"]


codeblock_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function CB.check(codeblock)
  assert(codeblock.line_first)
  assert(codeblock.line_last)
end"]
block_30 -> { prose_41}
{rank=same; prose_41}

prose_41 [label="prose"]


prose_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - #args
   - str :  The string to match against.
 
 - #return 3
   - boolean :  For header match
   - number  :  Level of header
   - string  :  Header stripped of left whitespace and tars

"]
block_31 -> { codeblock_43}
{rank=same; codeblock_43}

codeblock_43 [label="code block 97-108"]


codeblock_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function cb.matchHead(str)
    if str ~= \"\" and L.match(m.codestart, str) then
        local trimmed = str:sub(L.match(m.WS * m.hax, str))
        local level = L.match(m.zaps, trimmed) - 1
        local bareline = trimmed:sub(L.match(m.zaps, trimmed))
        return true, level, bareline
    else 
        return false, 0, \"\"
    end
end"]
block_32 -> { prose_45}
{rank=same; prose_45}

prose_45 [label="prose"]


prose_45 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Matches a code block footer line.
"]
block_33 -> { prose_47}
{rank=same; prose_47}

prose_47 [label="prose"]


prose_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - #args
   - str   :  The string to match against.
   - level :  Required level for a match.
 
 - #return 3
   - boolean :  For footer match
   - number  :  Level of header
   - string  :  Header stripped of left whitespace and tars

"]
block_34 -> { codeblock_49}
{rank=same; codeblock_49}

codeblock_49 [label="code block 122-133"]


codeblock_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function cb.matchFoot(str)
    if str ~= \"\" and L.match(m.codefinish, str) then
        local trimmed = str:sub(L.match(m.WS * m.hax    , str))
        local level = L.match(m.fass, trimmed) - 1
        local bareline = trimmed:sub(L.match(m.fass, trimmed))
        return true, level, bareline
    else 
        return false, 0, \"\"
    end
end"]
block_35 -> { prose_51}
{rank=same; prose_51}

prose_51 [label="prose"]


prose_51 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Constructor
"]
block_36 -> { codeblock_53}
{rank=same; codeblock_53}

codeblock_53 [label="code block 137-156"]


codeblock_53 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Codeblock, level, headline, linum)
    local codeblock = setmetatable({}, CB)
    codeblock.id = \"codeblock\"
    codeblock.level = level
    codeblock.header = headline
    codeblock.lang = L.match(L.C(m.symbol), headline) or \"\"
    codeblock.footer = \"\"
    codeblock.line_first = linum
    codeblock.lines = {}

    return codeblock
end


cb.__call = new
cb.__index = cb

return setmetatable({}, cb)"]

}
