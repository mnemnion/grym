digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 154"]

doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-5"]

section_1 -> { header_2 block_3 section_4 section_5 section_6 section_7}
{rank=same; header_2 block_3 section_4 section_5 section_6 section_7}

header_2 [label="Morphemes"]
block_3 [label="block 1-nil"]
section_4 [label="section: 6-26"]
section_5 [label="section: 27-32"]
section_6 [label="section: 73-80"]
section_7 [label="section: 140-142"]


block_3 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Morphemes are the basic structures of any language.


"]section_4 -> { header_9 block_10 block_11}
{rank=same; header_9 block_10 block_11}

header_9 [label="Includes"]
block_10 [label="block 6-7"]
block_11 [label="block 8-nil"]


block_10 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_11 -> { codeblock_13}
{rank=same; codeblock_13}

codeblock_13 [label="code block 8-25"]


codeblock_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local lpeg = require \"lpeg\"
local epeg = require \"../peg/epeg\"
local epnf = require \"../peg/epnf\"

local match = lpeg.match -- match a pattern against a string
local P = lpeg.P -- match a string literally
local S = lpeg.S  -- match anything in a set
local R = epeg.R  -- match anything in a range
local B = lpeg.B  -- match iff the pattern precedes the use of B
local C = lpeg.C  -- captures a match
local Csp = epeg.Csp -- captures start and end position of match
local Cg = lpeg.Cg -- named capture group (for **balanced highlighting**)
local Cb = lpeg.Cb -- Mysterious! TODO make not mysterious
local Cmt = lpeg.Cmt -- match-time capture
local Ct = lpeg.Ct -- a table with all captures from the pattern
local V = lpeg.V -- create a variable within a grammar
"]
block_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]section_5 -> { header_16 block_17 block_18 section_19}
{rank=same; header_16 block_17 block_18 section_19}

header_16 [label="Morpheme module"]
block_17 [label="block 27-28"]
block_18 [label="block 29-nil"]
section_19 [label="section: 33-52"]


block_17 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_18 -> { codeblock_21}
{rank=same; codeblock_21}

codeblock_21 [label="code block 29-31"]


codeblock_21 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local m = {}
"]
block_18 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]section_19 -> { header_24 block_25 block_26 section_27}
{rank=same; header_24 block_25 block_26 section_27}

header_24 [label="Fundamentals"]
block_25 [label="block 33-37"]
block_26 [label="block 38-nil"]
section_27 [label="section: 53-72"]


block_25 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These sequences are designed to be fundamental to several languages, Clu
in particular.

"]block_26 -> { codeblock_29}
{rank=same; codeblock_29}

codeblock_29 [label="code block 38-50"]


codeblock_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.letter = R\"AZ\" + R\"az\"

m.digit = R\"09\"

m._ = P\" \"

m.WS = m._^0

m.NL = P\"\n\"

m.__TAB__ = P\"\t\" -- First thing we do is eliminate these
"]
block_26 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]section_27 -> { header_32 block_33 block_34}
{rank=same; header_32 block_33 block_34}

header_32 [label="Hoon layer"]
block_33 [label="block 53-54"]
block_34 [label="block 55-nil"]


block_33 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_34 -> { codeblock_36}
{rank=same; codeblock_36}

codeblock_36 [label="code block 55-70"]


codeblock_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tar = P\"*\"
m.tars = P\"*\"^1
m.hax = P\"#\"
m.pat = P\"@\"
m.hep = P\"-\"
m.bar = P\"|\"
m.zap = P\"!\"
m.zaps = P\"!\"^1
m.fas = P\"/\"
m.fass = P\"/\"^1
m.dot = P\".\"

m.sel = P\"[\"
m.ser = P\"]\"
"]
block_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]section_6 -> { header_39 block_40 section_41}
{rank=same; header_39 block_40 section_41}

header_39 [label="Lines"]
block_40 [label="block 73-nil"]
section_41 [label="section: 81-91"]


block_40 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These patterns are used in line detection.  Grimoire is designed such that
the first characters of a line are a reliable guide to the substance of what
is to follow. 



"]section_41 -> { header_43 block_44 block_45 section_46}
{rank=same; header_43 block_44 block_45 section_46}

header_43 [label="Tagline"]
block_44 [label="block 81-84"]
block_45 [label="block 85-nil"]
section_46 [label="section: 92-104"]


block_44 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Taglines begin with hashtags, which are system directives.

"]block_45 -> { codeblock_48}
{rank=same; codeblock_48}

codeblock_48 [label="code block 85-89"]


codeblock_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tagline_sys_p = #(m.WS * m.hax - (m.hax * m._))
m.tagline_user_p = #(m.WS * m.pat - (m.pat * m._))
m.tagline_p = m.tagline_sys_p + m.tagline_user_p
"]
block_45 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]section_46 -> { header_51 block_52 block_53 section_54}
{rank=same; header_51 block_52 block_53 section_54}

header_51 [label="Listline "]
block_52 [label="block 92-96"]
block_53 [label="block 97-nil"]
section_54 [label="section: 105-139"]


block_52 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Listlines are blocked into lists, our YAML-inspired arcical data
structure. 

"]block_53 -> { codeblock_56}
{rank=same; codeblock_56}

codeblock_56 [label="code block 97-102"]


codeblock_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.listline_base_p = #(m.WS * m.hep * m._)
m.listline_num_p = #(m.WS * m.digit^1 * m.dot)
m.listline_p = m.listline_base_p + m.listline_num_p

"]
block_53 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]section_54 -> { header_59 block_60 block_61 block_62 block_63 block_64}
{rank=same; header_59 block_60 block_61 block_62 block_63 block_64}

header_59 [label="Tableline"]
block_60 [label="block 105-109"]
block_61 [label="block 110-113"]
block_62 [label="block 114-125"]
block_63 [label="block 126-127"]
block_64 [label="block 128-nil"]


block_60 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  A table, our matrix data structure, is delineated by a =|=.  These
are blocked by whitespace in the familiar way. 

"]
block_61 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Tables, and lists for that matter, will support leading handles at 
some point.  I'm leaning towards hashtags behaving differently in that
respect.

"]block_62 -> { codeblock_67}
{rank=same; codeblock_67}

codeblock_67 [label="code block 114-124"]


codeblock_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tableline_p = #(m.WS * m.bar)

m.codestart_p = #(m.WS * m.hax * m.zaps)
m.codefinish_p = #(m.WS * m.hax * m.fass)

m.codestart = m.WS * m.hax * m.zaps * P(1)^1
m.codefinish = m.WS * m.hax * m.fass * P(1)^1

m.header = m.WS * m.tars * m._ * P(1)^1 
"]
block_62 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_63 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" The symbol rule will be made less restrictive eventually. 

"]block_64 -> { codeblock_71}
{rank=same; codeblock_71}

codeblock_71 [label="code block 128-137"]


codeblock_71 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.symbol = m.letter * (m.letter + m.digit + m.hep)^0 

m.url = m.symbol -- This is definitely not right at all

m.prose = (m.symbol + m._)^1 -- Or this

m.hashtag = m.hax * m.symbol
m.handle = m.pat * m.symbol
"]
block_64 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]section_7 -> { header_74 block_75 section_76}
{rank=same; header_74 block_75 section_76}

header_74 [label="Structures"]
block_75 [label="block 140-nil"]
section_76 [label="section: 143-154"]


block_75 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]section_76 -> { header_78 block_79 block_80 block_81}
{rank=same; header_78 block_79 block_80 block_81}

header_78 [label="Links"]
block_79 [label="block 143-144"]
block_80 [label="block 145-150"]
block_81 [label="block 151-nil"]


block_79 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]block_80 -> { codeblock_83}
{rank=same; codeblock_83}

codeblock_83 [label="code block 145-148"]


codeblock_83 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.inner_link = m.sel * m.url * m.ser
m.link = m.sel * m.inner_link * m.inner_link^-1 * m.ser 
"]
block_80 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]block_81 -> { codeblock_86}
{rank=same; codeblock_86}

codeblock_86 [label="code block 151-153"]


codeblock_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return m
"]
block_81 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
}
