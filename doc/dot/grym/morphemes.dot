digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 175"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-149"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7}

header_2 [label="1 : Morphemes"]

prose_3 [label="prose"]

section_4 [label="section: 6-26"]

section_5 [label="section: 27-85"]

section_6 [label="section: 96-125"]

section_7 [label="section: 150-162"]


prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Morphemes are the basic structures of any language.

"]
section_4 -> { header_10 prose_11 codeblock_12}
{rank=same; header_10 prose_11 codeblock_12}

header_10 [label="3 : Includes"]

prose_11 [label="prose"]

codeblock_12 [label="code block 8-25"]


prose_11 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local lpeg = require \"lpeg\"
local epeg = require \"../peg/epeg\"
local epnf = require \"../peg/epnf\"

local match = lpeg.match -- match a pattern against a string
local P = lpeg.P -- match a string literally
local S = lpeg.S  -- match anything in a set
local R = epeg.R  -- match anything in a range
local B = lpeg.B  -- match iff the pattern precedes the use of B
local C = lpeg.C  -- captures a match
local Csp = epeg.Csp -- captures start and end position of match
local Cg = lpeg.Cg -- named capture group (for **balanced highlighting**)
local Cb = lpeg.Cb -- Mysterious! TODO make not mysterious
local Cmt = lpeg.Cmt -- match-time capture
local Ct = lpeg.Ct -- a table with all captures from the pattern
local V = lpeg.V -- create a variable within a grammar"]
section_5 -> { header_16 prose_17 codeblock_18 section_19 section_20 section_21}
{rank=same; header_16 prose_17 codeblock_18 section_19 section_20 section_21}

header_16 [label="2 : Morpheme module"]

prose_17 [label="prose"]

codeblock_18 [label="code block 29-31"]

section_19 [label="section: 33-54"]

section_20 [label="section: 55-85"]

section_21 [label="section: 86-95"]


prose_17 -> { raw_22}
{rank=same; raw_22}

raw_22 [label="raw"]


raw_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_18 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local m = {}"]
section_19 -> { header_25 prose_26 codeblock_27}
{rank=same; header_25 prose_26 codeblock_27}

header_25 [label="3 : Fundamentals"]

prose_26 [label="prose"]

codeblock_27 [label="code block 38-52"]


prose_26 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  These sequences are designed to be fundamental to several languages, Clu
in particular.
"]
codeblock_27 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.letter = R\"AZ\" + R\"az\"

m.digit = R\"09\"

m.number = m.digit^1 -- We will improve this

m._ = P\" \"

m.WS = m._^0

m.NL = P\"\\n\"

m.__TAB__ = P\"\\t\" -- First thing we do is eliminate these"]
section_20 -> { header_31 prose_32 codeblock_33}
{rank=same; header_31 prose_32 codeblock_33}

header_31 [label="3 : Hoon layer"]

prose_32 [label="prose"]

codeblock_33 [label="code block 61-84"]


prose_32 -> { raw_34}
{rank=same; raw_34}

raw_34 [label="raw"]


raw_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  I find mixing literals and token-likes in with variables distracting.
We use the Hoon names for ASCII tier glyphs.  It's one of the better urbit
innovations.
"]
codeblock_33 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tar = P\"*\"
m.tars = P\"*\"^1
m.hax = P\"#\"
m.pat = P\"@\"
m.hep = P\"-\"
m.bar = P\"|\"
m.zap = P\"!\"
m.wut = P\"?\"
m.zaps = P\"!\"^1
m.fas = P\"/\"
m.fass = P\"/\"^1
m.dot = P\".\"
m.col = P\":\"

m.sel = P\"[\"
m.ser = P\"]\"
m.pal = P\"(\"
m.par = P\")\"
m.kel = P\"{\"
m.ker = P\"}\"
m.gal = P\"<\"
m.gar = P\">\""]
section_21 -> { header_37 prose_38 codeblock_39}
{rank=same; header_37 prose_38 codeblock_39}

header_37 [label="3 : Compounds"]

prose_38 [label="prose"]

codeblock_39 [label="code block 88-93"]


prose_38 -> { raw_40}
{rank=same; raw_40}

raw_40 [label="raw"]


raw_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_39 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.symbol = m.letter * (m.letter + m.digit + m.hep + m.zap + m.wut)^0

m.hashtag = m.hax * m.symbol
m.handle = m.pat * m.symbol"]
section_6 -> { header_43 prose_44 section_45 section_46 section_47}
{rank=same; header_43 prose_44 section_45 section_46 section_47}

header_43 [label="2 : Lines"]

prose_44 [label="prose"]

section_45 [label="section: 103-113"]

section_46 [label="section: 114-125"]

section_47 [label="section: 126-149"]


prose_44 -> { raw_48}
{rank=same; raw_48}

raw_48 [label="raw"]


raw_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  These patterns are used in line detection.  Grimoire is designed such that
the first characters of a line are a reliable guide to the substance of what
is to follow. 

"]
section_45 -> { header_50 prose_51 codeblock_52}
{rank=same; header_50 prose_51 codeblock_52}

header_50 [label="3 : Tagline"]

prose_51 [label="prose"]

codeblock_52 [label="code block 107-111"]


prose_51 -> { raw_53}
{rank=same; raw_53}

raw_53 [label="raw"]


raw_53 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Taglines begin with hashtags, which are system directives.
"]
codeblock_52 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tagline_hash_p = #(m.WS * m.hax - (m.hax * m._))
m.tagline_handle_p = #(m.WS * m.pat - (m.pat * m._))
m.tagline_p = m.tagline_hash_p + m.tagline_hash_p"]
section_46 -> { header_56 prose_57 codeblock_58}
{rank=same; header_56 prose_57 codeblock_58}

header_56 [label="3 : Listline "]

prose_57 [label="prose"]

codeblock_58 [label="code block 119-123"]


prose_57 -> { raw_59}
{rank=same; raw_59}

raw_59 [label="raw"]


raw_59 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Listlines are blocked into lists, our YAML-inspired arcical data
structure. 
"]
codeblock_58 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.listline_base_p = #(m.WS * m.hep * m._)
m.listline_num_p = #(m.WS * m.digit^1 * m.dot)
m.listline_p = m.listline_base_p + m.listline_num_p"]
section_47 -> { header_62 prose_63 prose_64 codeblock_65 prose_66}
{rank=same; header_62 prose_63 prose_64 codeblock_65 prose_66}

header_62 [label="3 : Tableline"]

prose_63 [label="prose"]

prose_64 [label="prose"]

codeblock_65 [label="code block 135-145"]

prose_66 [label="prose"]


prose_63 -> { raw_67}
{rank=same; raw_67}

raw_67 [label="raw"]


raw_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  A table, our matrix data structure, is delineated by a =|=.  These
are blocked by whitespace in the familiar way. 
"]
prose_64 -> { raw_69}
{rank=same; raw_69}

raw_69 [label="raw"]


raw_69 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Tables, and lists for that matter, will support leading handles at 
some point.  I'm leaning towards hashtags behaving differently in that
respect.
"]
codeblock_65 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tableline_p = #(m.WS * m.bar)

m.codestart_p = #(m.WS * m.hax * m.zaps)
m.codefinish_p = #(m.WS * m.hax * m.fass)

m.codestart = m.WS * m.hax * m.zaps * P(1)^1
m.codefinish = m.WS * m.hax * m.fass * P(1)^1

m.header = m.WS * m.tars * m._ * P(1)^1 "]
prose_66 -> { raw_72}
{rank=same; raw_72}

raw_72 [label="raw"]


raw_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 The symbol rule will be made less restrictive eventually. 

"]
section_7 -> { header_74 prose_75 codeblock_76 section_77}
{rank=same; header_74 prose_75 codeblock_76 section_77}

header_74 [label="2 : Structures"]

prose_75 [label="prose"]

codeblock_76 [label="code block 155-160"]

section_77 [label="section: 163-175"]


prose_75 -> { raw_78}
{rank=same; raw_78}

raw_78 [label="raw"]


raw_78 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  These will ultimately need to be propertly recursive.  Prose in particular
has the inner markups as a mutual loop that always advances. 
"]
codeblock_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.url = m.letter * (m.symbol + m.dot + m.fas + m.col)^0 - m.ser -- This is definitely not right at all

m.prose = (m.symbol + m._)^1 -- Or this
m.link_prose = m.prose - m.ser -- accurate"]
section_77 -> { header_81 prose_82 codeblock_83 codeblock_84}
{rank=same; header_81 prose_82 codeblock_83 codeblock_84}

header_81 [label="3 : Links"]

prose_82 [label="prose"]

codeblock_83 [label="code block 165-169"]

codeblock_84 [label="code block 172-174"]


prose_82 -> { raw_85}
{rank=same; raw_85}

raw_85 [label="raw"]


raw_85 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_83 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.inner_link = m.sel * m.url * m.ser
m.text_link = m.sel * m.link_prose * m.ser
m.link = m.sel * m.text_link * m.inner_link^-1 * m.ser "]
codeblock_84 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return m"]

}
