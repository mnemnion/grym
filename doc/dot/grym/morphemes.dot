digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 173"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-147"]


section_1 -> { header_2 block_3 section_4 section_5 section_6 section_7}
{rank=same; header_2 block_3 section_4 section_5 section_6 section_7}

header_2 [label="1 : Morphemes"]

block_3 [label="block 1-147"]

section_4 [label="section: 6-26"]

section_5 [label="section: 27-83"]

section_6 [label="section: 94-123"]

section_7 [label="section: 148-160"]


block_3 -> { prose_8}
{rank=same; prose_8}

prose_8 [label="prose"]


prose_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Morphemes are the basic structures of any language.

"]
section_4 -> { header_10 block_11 block_12}
{rank=same; header_10 block_11 block_12}

header_10 [label="3 : Includes"]

block_11 [label="block 6-7"]

block_12 [label="block 8-26"]


block_11 -> { prose_13}
{rank=same; prose_13}

prose_13 [label="prose"]


prose_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_12 -> { codeblock_15}
{rank=same; codeblock_15}

codeblock_15 [label="code block 8-25"]


codeblock_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local lpeg = require \"lpeg\"
local epeg = require \"../peg/epeg\"
local epnf = require \"../peg/epnf\"

local match = lpeg.match -- match a pattern against a string
local P = lpeg.P -- match a string literally
local S = lpeg.S  -- match anything in a set
local R = epeg.R  -- match anything in a range
local B = lpeg.B  -- match iff the pattern precedes the use of B
local C = lpeg.C  -- captures a match
local Csp = epeg.Csp -- captures start and end position of match
local Cg = lpeg.Cg -- named capture group (for **balanced highlighting**)
local Cb = lpeg.Cb -- Mysterious! TODO make not mysterious
local Cmt = lpeg.Cmt -- match-time capture
local Ct = lpeg.Ct -- a table with all captures from the pattern
local V = lpeg.V -- create a variable within a grammar"]
section_5 -> { header_17 block_18 block_19 section_20 section_21 section_22}
{rank=same; header_17 block_18 block_19 section_20 section_21 section_22}

header_17 [label="2 : Morpheme module"]

block_18 [label="block 27-28"]

block_19 [label="block 29-83"]

section_20 [label="section: 33-52"]

section_21 [label="section: 53-83"]

section_22 [label="section: 84-93"]


block_18 -> { prose_23}
{rank=same; prose_23}

prose_23 [label="prose"]


prose_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_19 -> { codeblock_25}
{rank=same; codeblock_25}

codeblock_25 [label="code block 29-31"]


codeblock_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local m = {}"]
section_20 -> { header_27 block_28 block_29}
{rank=same; header_27 block_28 block_29}

header_27 [label="3 : Fundamentals"]

block_28 [label="block 33-37"]

block_29 [label="block 38-52"]


block_28 -> { prose_30}
{rank=same; prose_30}

prose_30 [label="prose"]


prose_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These sequences are designed to be fundamental to several languages, Clu
in particular.
"]
block_29 -> { codeblock_32}
{rank=same; codeblock_32}

codeblock_32 [label="code block 38-50"]


codeblock_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.letter = R\"AZ\" + R\"az\"

m.digit = R\"09\"

m._ = P\" \"

m.WS = m._^0

m.NL = P\"\\n\"

m.__TAB__ = P\"\\t\" -- First thing we do is eliminate these"]
section_21 -> { header_34 block_35 block_36}
{rank=same; header_34 block_35 block_36}

header_34 [label="3 : Hoon layer"]

block_35 [label="block 53-58"]

block_36 [label="block 59-83"]


block_35 -> { prose_37}
{rank=same; prose_37}

prose_37 [label="prose"]


prose_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  I find mixing literals and token-likes in with variables distracting.
We use the Hoon names for ASCII tier glyphs.  It's one of the better urbit
innovations.
"]
block_36 -> { codeblock_39}
{rank=same; codeblock_39}

codeblock_39 [label="code block 59-82"]


codeblock_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tar = P\"*\"
m.tars = P\"*\"^1
m.hax = P\"#\"
m.pat = P\"@\"
m.hep = P\"-\"
m.bar = P\"|\"
m.zap = P\"!\"
m.wut = P\"?\"
m.zaps = P\"!\"^1
m.fas = P\"/\"
m.fass = P\"/\"^1
m.dot = P\".\"
m.col = P\":\"

m.sel = P\"[\"
m.ser = P\"]\"
m.pal = P\"(\"
m.par = P\")\"
m.kel = P\"{\"
m.ker = P\"}\"
m.gal = P\"<\"
m.gar = P\">\""]
section_22 -> { header_41 block_42 block_43}
{rank=same; header_41 block_42 block_43}

header_41 [label="3 : Compounds"]

block_42 [label="block 84-85"]

block_43 [label="block 86-93"]


block_42 -> { prose_44}
{rank=same; prose_44}

prose_44 [label="prose"]


prose_44 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_43 -> { codeblock_46}
{rank=same; codeblock_46}

codeblock_46 [label="code block 86-91"]


codeblock_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.symbol = m.letter * (m.letter + m.digit + m.hep + m.zap + m.wut)^0

m.hashtag = m.hax * m.symbol
m.handle = m.pat * m.symbol"]
section_6 -> { header_48 block_49 section_50 section_51 section_52}
{rank=same; header_48 block_49 section_50 section_51 section_52}

header_48 [label="2 : Lines"]

block_49 [label="block 94-123"]

section_50 [label="section: 101-111"]

section_51 [label="section: 112-123"]

section_52 [label="section: 124-147"]


block_49 -> { prose_53}
{rank=same; prose_53}

prose_53 [label="prose"]


prose_53 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These patterns are used in line detection.  Grimoire is designed such that
the first characters of a line are a reliable guide to the substance of what
is to follow. 

"]
section_50 -> { header_55 block_56 block_57}
{rank=same; header_55 block_56 block_57}

header_55 [label="3 : Tagline"]

block_56 [label="block 101-104"]

block_57 [label="block 105-111"]


block_56 -> { prose_58}
{rank=same; prose_58}

prose_58 [label="prose"]


prose_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Taglines begin with hashtags, which are system directives.
"]
block_57 -> { codeblock_60}
{rank=same; codeblock_60}

codeblock_60 [label="code block 105-109"]


codeblock_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tagline_hash_p = #(m.WS * m.hax - (m.hax * m._))
m.tagline_handle_p = #(m.WS * m.pat - (m.pat * m._))
m.tagline_p = m.tagline_hash_p + m.tagline_hash_p"]
section_51 -> { header_62 block_63 block_64}
{rank=same; header_62 block_63 block_64}

header_62 [label="3 : Listline "]

block_63 [label="block 112-116"]

block_64 [label="block 117-123"]


block_63 -> { prose_65}
{rank=same; prose_65}

prose_65 [label="prose"]


prose_65 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Listlines are blocked into lists, our YAML-inspired arcical data
structure. 
"]
block_64 -> { codeblock_67}
{rank=same; codeblock_67}

codeblock_67 [label="code block 117-121"]


codeblock_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.listline_base_p = #(m.WS * m.hep * m._)
m.listline_num_p = #(m.WS * m.digit^1 * m.dot)
m.listline_p = m.listline_base_p + m.listline_num_p"]
section_52 -> { header_69 block_70 block_71 block_72 block_73}
{rank=same; header_69 block_70 block_71 block_72 block_73}

header_69 [label="3 : Tableline"]

block_70 [label="block 124-128"]

block_71 [label="block 129-132"]

block_72 [label="block 133-144"]

block_73 [label="block 145-147"]


block_70 -> { prose_74}
{rank=same; prose_74}

prose_74 [label="prose"]


prose_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  A table, our matrix data structure, is delineated by a =|=.  These
are blocked by whitespace in the familiar way. 
"]
block_71 -> { prose_76}
{rank=same; prose_76}

prose_76 [label="prose"]


prose_76 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Tables, and lists for that matter, will support leading handles at 
some point.  I'm leaning towards hashtags behaving differently in that
respect.
"]
block_72 -> { codeblock_78}
{rank=same; codeblock_78}

codeblock_78 [label="code block 133-143"]


codeblock_78 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tableline_p = #(m.WS * m.bar)

m.codestart_p = #(m.WS * m.hax * m.zaps)
m.codefinish_p = #(m.WS * m.hax * m.fass)

m.codestart = m.WS * m.hax * m.zaps * P(1)^1
m.codefinish = m.WS * m.hax * m.fass * P(1)^1

m.header = m.WS * m.tars * m._ * P(1)^1 "]
block_73 -> { prose_80}
{rank=same; prose_80}

prose_80 [label="prose"]


prose_80 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" The symbol rule will be made less restrictive eventually. 

"]
section_7 -> { header_82 block_83 block_84 section_85}
{rank=same; header_82 block_83 block_84 section_85}

header_82 [label="2 : Structures"]

block_83 [label="block 148-152"]

block_84 [label="block 153-160"]

section_85 [label="section: 161-173"]


block_83 -> { prose_86}
{rank=same; prose_86}

prose_86 [label="prose"]


prose_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These will ultimately need to be propertly recursive.  Prose in particular
has the inner markups as a mutual loop that always advances. 
"]
block_84 -> { codeblock_88}
{rank=same; codeblock_88}

codeblock_88 [label="code block 153-158"]


codeblock_88 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.url = m.letter * (m.symbol + m.dot + m.fas + m.col)^0 - m.ser -- This is definitely not right at all

m.prose = (m.symbol + m._)^1 -- Or this
m.link_prose = m.prose - m.ser -- accurate"]
section_85 -> { header_90 block_91 block_92 block_93}
{rank=same; header_90 block_91 block_92 block_93}

header_90 [label="3 : Links"]

block_91 [label="block 161-162"]

block_92 [label="block 163-169"]

block_93 [label="block 170-173"]


block_91 -> { prose_94}
{rank=same; prose_94}

prose_94 [label="prose"]


prose_94 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_92 -> { codeblock_96}
{rank=same; codeblock_96}

codeblock_96 [label="code block 163-167"]


codeblock_96 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.inner_link = m.sel * m.url * m.ser
m.text_link = m.sel * m.link_prose * m.ser
m.link = m.sel * m.text_link * m.inner_link^-1 * m.ser "]
block_93 -> { codeblock_98}
{rank=same; codeblock_98}

codeblock_98 [label="code block 170-172"]


codeblock_98 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return m"]

}
