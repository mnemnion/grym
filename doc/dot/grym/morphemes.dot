digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 175"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-149"]


section_1 -> { header_2 block_3 section_4 section_5 section_6 section_7}
{rank=same; header_2 block_3 section_4 section_5 section_6 section_7}

header_2 [label="1 : Morphemes"]

block_3 [label="block 1-149"]

section_4 [label="section: 6-26"]

section_5 [label="section: 27-85"]

section_6 [label="section: 96-125"]

section_7 [label="section: 150-162"]


block_3 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Morphemes are the basic structures of any language.

"]
section_4 -> { header_9 block_10 block_11}
{rank=same; header_9 block_10 block_11}

header_9 [label="3 : Includes"]

block_10 [label="block 6-7"]

block_11 [label="block 8-26"]


block_10 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_11 -> { codeblock_13}
{rank=same; codeblock_13}

codeblock_13 [label="code block 8-25"]


codeblock_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local lpeg = require \"lpeg\"
local epeg = require \"../peg/epeg\"
local epnf = require \"../peg/epnf\"

local match = lpeg.match -- match a pattern against a string
local P = lpeg.P -- match a string literally
local S = lpeg.S  -- match anything in a set
local R = epeg.R  -- match anything in a range
local B = lpeg.B  -- match iff the pattern precedes the use of B
local C = lpeg.C  -- captures a match
local Csp = epeg.Csp -- captures start and end position of match
local Cg = lpeg.Cg -- named capture group (for **balanced highlighting**)
local Cb = lpeg.Cb -- Mysterious! TODO make not mysterious
local Cmt = lpeg.Cmt -- match-time capture
local Ct = lpeg.Ct -- a table with all captures from the pattern
local V = lpeg.V -- create a variable within a grammar"]
block_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_5 -> { header_16 block_17 block_18 section_19 section_20 section_21}
{rank=same; header_16 block_17 block_18 section_19 section_20 section_21}

header_16 [label="2 : Morpheme module"]

block_17 [label="block 27-28"]

block_18 [label="block 29-85"]

section_19 [label="section: 33-54"]

section_20 [label="section: 55-85"]

section_21 [label="section: 86-95"]


block_17 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_18 -> { codeblock_23}
{rank=same; codeblock_23}

codeblock_23 [label="code block 29-31"]


codeblock_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local m = {}"]
block_18 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_19 -> { header_26 block_27 block_28}
{rank=same; header_26 block_27 block_28}

header_26 [label="3 : Fundamentals"]

block_27 [label="block 33-37"]

block_28 [label="block 38-54"]


block_27 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These sequences are designed to be fundamental to several languages, Clu
in particular.
"]
block_28 -> { codeblock_30}
{rank=same; codeblock_30}

codeblock_30 [label="code block 38-52"]


codeblock_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.letter = R\"AZ\" + R\"az\"

m.digit = R\"09\"

m.number = m.digit^1 -- We will improve this

m._ = P\" \"

m.WS = m._^0

m.NL = P\"\\n\"

m.__TAB__ = P\"\\t\" -- First thing we do is eliminate these"]
block_28 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_20 -> { header_33 block_34 block_35}
{rank=same; header_33 block_34 block_35}

header_33 [label="3 : Hoon layer"]

block_34 [label="block 55-60"]

block_35 [label="block 61-85"]


block_34 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  I find mixing literals and token-likes in with variables distracting.
We use the Hoon names for ASCII tier glyphs.  It's one of the better urbit
innovations.
"]
block_35 -> { codeblock_37}
{rank=same; codeblock_37}

codeblock_37 [label="code block 61-84"]


codeblock_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tar = P\"*\"
m.tars = P\"*\"^1
m.hax = P\"#\"
m.pat = P\"@\"
m.hep = P\"-\"
m.bar = P\"|\"
m.zap = P\"!\"
m.wut = P\"?\"
m.zaps = P\"!\"^1
m.fas = P\"/\"
m.fass = P\"/\"^1
m.dot = P\".\"
m.col = P\":\"

m.sel = P\"[\"
m.ser = P\"]\"
m.pal = P\"(\"
m.par = P\")\"
m.kel = P\"{\"
m.ker = P\"}\"
m.gal = P\"<\"
m.gar = P\">\""]
block_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
section_21 -> { header_40 block_41 block_42}
{rank=same; header_40 block_41 block_42}

header_40 [label="3 : Compounds"]

block_41 [label="block 86-87"]

block_42 [label="block 88-95"]


block_41 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_42 -> { codeblock_44}
{rank=same; codeblock_44}

codeblock_44 [label="code block 88-93"]


codeblock_44 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.symbol = m.letter * (m.letter + m.digit + m.hep + m.zap + m.wut)^0

m.hashtag = m.hax * m.symbol
m.handle = m.pat * m.symbol"]
block_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_6 -> { header_47 block_48 section_49 section_50 section_51}
{rank=same; header_47 block_48 section_49 section_50 section_51}

header_47 [label="2 : Lines"]

block_48 [label="block 96-125"]

section_49 [label="section: 103-113"]

section_50 [label="section: 114-125"]

section_51 [label="section: 126-149"]


block_48 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These patterns are used in line detection.  Grimoire is designed such that
the first characters of a line are a reliable guide to the substance of what
is to follow. 

"]
section_49 -> { header_53 block_54 block_55}
{rank=same; header_53 block_54 block_55}

header_53 [label="3 : Tagline"]

block_54 [label="block 103-106"]

block_55 [label="block 107-113"]


block_54 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Taglines begin with hashtags, which are system directives.
"]
block_55 -> { codeblock_57}
{rank=same; codeblock_57}

codeblock_57 [label="code block 107-111"]


codeblock_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tagline_hash_p = #(m.WS * m.hax - (m.hax * m._))
m.tagline_handle_p = #(m.WS * m.pat - (m.pat * m._))
m.tagline_p = m.tagline_hash_p + m.tagline_hash_p"]
block_55 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_50 -> { header_60 block_61 block_62}
{rank=same; header_60 block_61 block_62}

header_60 [label="3 : Listline "]

block_61 [label="block 114-118"]

block_62 [label="block 119-125"]


block_61 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  Listlines are blocked into lists, our YAML-inspired arcical data
structure. 
"]
block_62 -> { codeblock_64}
{rank=same; codeblock_64}

codeblock_64 [label="code block 119-123"]


codeblock_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.listline_base_p = #(m.WS * m.hep * m._)
m.listline_num_p = #(m.WS * m.digit^1 * m.dot)
m.listline_p = m.listline_base_p + m.listline_num_p"]
block_62 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_51 -> { header_67 block_68 block_69 block_70 block_71}
{rank=same; header_67 block_68 block_69 block_70 block_71}

header_67 [label="3 : Tableline"]

block_68 [label="block 126-130"]

block_69 [label="block 131-134"]

block_70 [label="block 135-146"]

block_71 [label="block 147-149"]


block_68 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  A table, our matrix data structure, is delineated by a =|=.  These
are blocked by whitespace in the familiar way. 
"]
block_69 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Tables, and lists for that matter, will support leading handles at 
some point.  I'm leaning towards hashtags behaving differently in that
respect.
"]
block_70 -> { codeblock_74}
{rank=same; codeblock_74}

codeblock_74 [label="code block 135-145"]


codeblock_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.tableline_p = #(m.WS * m.bar)

m.codestart_p = #(m.WS * m.hax * m.zaps)
m.codefinish_p = #(m.WS * m.hax * m.fass)

m.codestart = m.WS * m.hax * m.zaps * P(1)^1
m.codefinish = m.WS * m.hax * m.fass * P(1)^1

m.header = m.WS * m.tars * m._ * P(1)^1 "]
block_70 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_71 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" The symbol rule will be made less restrictive eventually. 

"]
section_7 -> { header_78 block_79 block_80 section_81}
{rank=same; header_78 block_79 block_80 section_81}

header_78 [label="2 : Structures"]

block_79 [label="block 150-154"]

block_80 [label="block 155-162"]

section_81 [label="section: 163-175"]


block_79 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  These will ultimately need to be propertly recursive.  Prose in particular
has the inner markups as a mutual loop that always advances. 
"]
block_80 -> { codeblock_83}
{rank=same; codeblock_83}

codeblock_83 [label="code block 155-160"]


codeblock_83 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.url = m.letter * (m.symbol + m.dot + m.fas + m.col)^0 - m.ser -- This is definitely not right at all

m.prose = (m.symbol + m._)^1 -- Or this
m.link_prose = m.prose - m.ser -- accurate"]
block_80 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_81 -> { header_86 block_87 block_88 block_89}
{rank=same; header_86 block_87 block_88 block_89}

header_86 [label="3 : Links"]

block_87 [label="block 163-164"]

block_88 [label="block 165-171"]

block_89 [label="block 172-175"]


block_87 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_88 -> { codeblock_91}
{rank=same; codeblock_91}

codeblock_91 [label="code block 165-169"]


codeblock_91 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="m.inner_link = m.sel * m.url * m.ser
m.text_link = m.sel * m.link_prose * m.ser
m.link = m.sel * m.text_link * m.inner_link^-1 * m.ser "]
block_88 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_89 -> { codeblock_94}
{rank=same; codeblock_94}

codeblock_94 [label="code block 172-174"]


codeblock_94 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return m"]
block_89 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

}
