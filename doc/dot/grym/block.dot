digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 180"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-126"]


section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9 section_10 section_11}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9 section_10 section_11}

header_2 [label="1 : Block module"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

prose_7 [label="prose"]

section_8 [label="section: 33-50"]

section_9 [label="section: 51-75"]

section_10 [label="section: 76-91"]

section_11 [label="section: 127-180"]


header_2 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Block module"]
prose_3 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   A Block is the container for the next level of granularity below
 a Section. Any Section has a Header and one or more Blocks. Both the
 Header and the Block may be virtual, that is, without contents.
"]
prose_4 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 The most general premise is that Blocks are delineated by blank line
 whitespace. 

"]
prose_5 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 A paragraph of prose is the simplest block, and the default.  A list with
 a tag line is a block also, as is a table.  Most importantly for our short
 path, code blocks are enclosed in blocks as well.
"]
prose_6 -> { raw_19 interpolated_20 raw_21}
{rank=same; raw_19 interpolated_20 raw_21}

raw_19 [label="raw"]

interpolated_20 [label="interpolated"]

raw_21 [label="raw"]


raw_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Blocking needs to identify when it has structure, and when prose, on a 
 line-by-line basis.  It must also apply the cling rule to make sure that
 e.g. tags are part of the block indicated by whitespacing. 
 
 Blocking need not, and mostly should not, parse within structure or prose.
 These categories are determined by the beginning of a line, making this
 tractable. 
 
 The cling rule requires lookahead. LPEG is quite capable of this, as is 
 packrat PEG parsing generally.  In the bootstrap implementation, we will
 parse once for ownership, again (in the "]
interpolated_20 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lines"]
raw_21 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" array of each Section) for
 blocking, and a final time to parse within blocks. 
"]
prose_7 -> { raw_25 interpolated_26 raw_27 interpolated_28 raw_29}
{rank=same; raw_25 interpolated_26 raw_27 interpolated_28 raw_29}

raw_25 [label="raw"]

interpolated_26 [label="interpolated"]

raw_27 [label="raw"]

interpolated_28 [label="interpolated"]

raw_29 [label="raw"]


raw_25 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Grimoire is intended to work, in linear time, as a single-pass PEG
 grammar.  Presently (Feb 2018) I'm intending to prototype that with 
 PEGylator and port it to "]
interpolated_26 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="hammer"]
raw_27 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" with a "]
interpolated_28 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="quipu"]
raw_29 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" back-end. 

"]
section_8 -> { header_35 prose_36 codeblock_37}
{rank=same; header_35 prose_36 codeblock_37}

header_35 [label="3 : includes"]

prose_36 [label="prose"]

codeblock_37 [label="code block 35-48"]


header_35 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_36 -> { raw_39}
{rank=same; raw_39}

raw_39 [label="raw"]


raw_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"node/node\"
local Codeblock = require \"grym/codeblock\"
local Structure = require \"grym/structure\"
local Prose = require \"grym/prose\"

local s = require \"status\"

local m = require \"grym/morphemes\"
local util = require \"../lib/util\"
local freeze = util.freeze"]
section_9 -> { header_42 prose_43 codeblock_44}
{rank=same; header_42 prose_43 codeblock_44}

header_42 [label="2 : Metatable for Blocks"]

prose_43 [label="prose"]

codeblock_44 [label="code block 53-73"]


header_42 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Metatable for Blocks"]
prose_43 -> { raw_46}
{rank=same; raw_46}

raw_46 [label="raw"]


raw_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local B = setmetatable({}, { __index = Node })
B.__index = B

B.__tostring = function(block) 
    return \"Block\"
end

function B.addLine(block, line)
    if L.match(m.tagline_hash_p, line) then
        block[#block + 1] = Structure(line, \"hashline\", block.str)
    elseif L.match(m.tagline_handle_p, line) then
        block[#block + 1] = Structure(line, \"handleline\", block.str)
        -- Eventually Blocks won't have lines, meantime:
    else
        block.lines[#block.lines + 1] = line
    end

    return block
end"]
section_10 -> { header_49 prose_50 codeblock_51 section_52}
{rank=same; header_49 prose_50 codeblock_51 section_52}

header_49 [label="2 : Parse the prose within a block"]

prose_50 [label="prose"]

codeblock_51 [label="code block 78-90"]

section_52 [label="section: 92-126"]


header_49 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Parse the prose within a block"]
prose_50 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_51 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function B.parseProse(block)
    if block[1] then
        if block[1].id == \"codeblock\" then
            return \"\"
        end
    else
        block[1] = Prose(block)
        block.lines = nil
        return block[1]
    end
end"]
section_52 -> { header_57 prose_58 codeblock_59}
{rank=same; header_57 prose_58 codeblock_59}

header_57 [label="3 : toValue"]

prose_58 [label="prose"]

codeblock_59 [label="code block 97-124"]


header_57 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** toValue"]
prose_58 -> { raw_61}
{rank=same; raw_61}

raw_61 [label="raw"]


raw_61 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Adds a .val field which is the union of all lines.
 Useful in visualization. 
"]
codeblock_59 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function B.toString(block)
    local phrase = \"\"
    for _,v in ipairs(block.lines) do
        phrase = phrase .. v .. \"\\n\"
    end
    return phrase
end

function B.toValue(block)
    block.val = block:toString()
    return block.val
end

function B.toMarkdown(block)
    if block[1] and (block[1].id == \"codeblock\"
      or block[1].id == \"prose\") then
        return block[1]:toMarkdown()
    else
        return block:toString()
    end
end

function B.dotLabel(block)
    return \"block \" .. tostring(block.line_first) 
        .. \"-\" .. tostring(block.line_last)
end"]
section_11 -> { header_64 prose_65 codeblock_66 prose_67 codeblock_68}
{rank=same; header_64 prose_65 codeblock_66 prose_67 codeblock_68}

header_64 [label="2 : Constructor/module"]

prose_65 [label="prose"]

codeblock_66 [label="code block 129-151"]

prose_67 [label="prose"]

codeblock_68 [label="code block 163-179"]


header_64 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Constructor/module"]
prose_65 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_66 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local b = {}

local function new(Block, lines, linum, str)
    local block = setmetatable({}, B)
    block.lines = {}
    block.line_first = linum
    if (lines) then 
        if type(lines) == \"string\" then
            block:addLine(lines)
        elseif type(lines) == \"table\" then
            for _, l in ipairs(lines) do
                block:addLine(l)
            end
        else
            freeze(\"Error: in block.new type of `lines` is \" .. type(lines))
        end
    end

    block.id = \"block\"
    return block
end"]
prose_67 -> { raw_73}
{rank=same; raw_73}

raw_73 [label="raw"]


raw_73 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - returns: 
        1. true for structure, false for prose
        2. id of structure line or \"\" for prose

"]
codeblock_68 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function structureOrProse(line)
    if L.match(m.tagline_p, line) then
        return true, \"tagline\"
    elseif L.match(m.listline_p, line) then
        return true, \"listline\"
    elseif L.match(m.tableline_p, line) then
        return true, \"tableline\"
    end
    return false, \"\"
end

b[\"__call\"] = new
b[\"__index\"] = b

return setmetatable({}, b)"]

}
