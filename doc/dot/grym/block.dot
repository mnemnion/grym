digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 171"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-171"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10 block_11 block_12 block_13 block_14 block_15 block_16 block_17 block_18 block_19}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 block_8 block_9 block_10 block_11 block_12 block_13 block_14 block_15 block_16 block_17 block_18 block_19}

header_2 [label="1 : Block module"]

block_3 [label="block 1-6"]

block_4 [label="block 7-10"]

block_5 [label="block 11-14"]

block_6 [label="block 15-27"]

block_7 [label="block 28-33"]

block_8 [label="block 34-46"]

block_9 [label="block 47-48"]

block_10 [label="block 49-70"]

block_11 [label="block 71-72"]

block_12 [label="block 73-89"]

block_13 [label="block 90-92"]

block_14 [label="block 93-117"]

block_15 [label="block 118-119"]

block_16 [label="block 120-144"]

block_17 [label="block 145-148"]

block_18 [label="block 149-153"]

block_19 [label="block 154-171"]


block_3 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   A Block is the container for the next level of granularity below
 a Section. Any Section has a Header and one or more Blocks. Both the
 Header and the Block may be virtual, that is, without contents.
"]
block_4 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" The most general premise is that Blocks are delineated by blank line
 whitespace. 

"]
block_5 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" A paragraph of prose is the simplest block, and the default.  A list with
 a tag line is a block also, as is a table.  Most importantly for our short
 path, code blocks are enclosed in blocks as well.
"]
block_6 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Blocking needs to identify when it has structure, and when prose, on a 
 line-by-line basis.  It must also apply the cling rule to make sure that
 e.g. tags are part of the block indicated by whitespacing. 
 
 Blocking need not, and mostly should not, parse within structure or prose.
 These categories are determined by the beginning of a line, making this
 tractable. 
 
 The cling rule requires lookahead. LPEG is quite capable of this, as is 
 packrat PEG parsing generally.  In the bootstrap implementation, we will
 parse once for ownership, again (in the `lines` array of each Section) for
 blocking, and a final time to parse within blocks. 
"]
block_7 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Grimoire is intended to work, in linear time, as a single-pass PEG
 grammar.  Presently (Feb 2018) I'm intending to prototype that with 
 PEGylator and port it to `hammer` with a `quipu` back-end. 


"]
block_8 -> { codeblock_25}
{rank=same; codeblock_25}

codeblock_25 [label="code block 34-45"]


codeblock_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"peg/node\"
local Codeblock = require \"grym/codeblock\"
local Structure = require \"grym/structure\"
local Prose = require \"grym/prose\"

local m = require \"grym/morphemes\"
local util = require \"../lib/util\"
local freeze = util.freeze"]
block_8 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_9 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Metatable for Blocks
"]
block_10 -> { codeblock_29}
{rank=same; codeblock_29}

codeblock_29 [label="code block 49-69"]


codeblock_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local B = setmetatable({}, { __index = Node })
B.__index = B

B.__tostring = function(block) 
    return \"Block\"
end

function B.addLine(block, line)
    if L.match(m.tagline_hash_p, line) then
        block[#block + 1] = Structure(line, \"hashline\")
    elseif L.match(m.tagline_handle_p, line) then
        block[#block + 1] = Structure(line, \"handleline\")
        -- Eventually Blocks won't have lines, meantime:
    else
        block.lines[#block.lines + 1] = line
    end

    return block
end"]
block_10 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_11 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Parse the prose within a block
"]
block_12 -> { codeblock_33}
{rank=same; codeblock_33}

codeblock_33 [label="code block 73-87"]


codeblock_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function B.parseProse(block)
    if block[1] then
        if block[1].id == \"codeblock\" then
            return \"\"
        end
    end
    local phrase = \" \"
    for _,v in ipairs(block.lines) do
        phrase = phrase .. \" \" .. v
    end
    -- Parse here
    return phrase
end"]
block_12 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_13 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Adds a .val field which is the union of all lines.
 Useful in visualization. 
"]
block_14 -> { codeblock_37}
{rank=same; codeblock_37}

codeblock_37 [label="code block 93-115"]


codeblock_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function B.toValue(block)
    block.val = \"\"
    for _,v in ipairs(block.lines) do
        block.val = block.val .. v .. \"\\n\"
    end

    return block.val
end

function B.toMarkdown(block)
    if block[1] and block[1].id == \"codeblock\" then
        return block[1]:toMarkdown()
    end
    
    return block:toValue()
end

function B.dotLabel(block)
    return \"block \" .. tostring(block.line_first) 
        .. \"-\" .. tostring(block.line_last)
end"]
block_14 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_15 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Constructor/module
"]
block_16 -> { codeblock_41}
{rank=same; codeblock_41}

codeblock_41 [label="code block 120-142"]


codeblock_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local b = {}

local function new(Block, lines, linum)
    local block = setmetatable({}, B)
    block.lines = {}
    block.line_first = linum
    if (lines) then 
        if type(lines) == \"string\" then
            block:addLine(lines)
        elseif type(lines) == \"table\" then
            for _, l in ipairs(lines) do
                block:addLine(l)
            end
        else
            freeze(\"Error: in block.new type of `lines` is \" .. type(lines))
        end
    end

    block.id = \"block\"
    return block
end"]
block_16 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_17 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Sorts lines into structure and prose.
 
 - line : taken from block.lines
"]
block_18 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - returns: 
        1. true for structure, false for prose
        2. id of structure line or \"\" for prose

"]
block_19 -> { codeblock_46}
{rank=same; codeblock_46}

codeblock_46 [label="code block 154-170"]


codeblock_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function structureOrProse(line)
    if L.match(m.tagline_p, line) then
        return true, \"tagline\"
    elseif L.match(m.listline_p, line) then
        return true, \"listline\"
    elseif L.match(m.tableline_p, line) then
        return true, \"tableline\"
    end
    return false, \"\"
end

b[\"__call\"] = new
b[\"__index\"] = b

return setmetatable({}, b)"]
block_19 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

}
