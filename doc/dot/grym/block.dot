digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 180"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-126"]


section_1 -> { header_2}
{rank=same; header_2}

header_2 [label="1 : Block module"]


section_3 -> { header_7}
{rank=same; header_7}

header_7 [label="3 : includes"]


codeblock_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"peg/node\"
local Codeblock = require \"grym/codeblock\"
local Structure = require \"grym/structure\"
local Prose = require \"grym/prose\"

local s = require \"status\"

local m = require \"grym/morphemes\"
local util = require \"../lib/util\"
local freeze = util.freeze"]
section_4 -> { header_10}
{rank=same; header_10}

header_10 [label="2 : Metatable for Blocks"]


codeblock_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local B = setmetatable({}, { __index = Node })
B.__index = B

B.__tostring = function(block) 
    return \"Block\"
end

function B.addLine(block, line)
    if L.match(m.tagline_hash_p, line) then
        block[#block + 1] = Structure(line, \"hashline\")
    elseif L.match(m.tagline_handle_p, line) then
        block[#block + 1] = Structure(line, \"handleline\")
        -- Eventually Blocks won't have lines, meantime:
    else
        block.lines[#block.lines + 1] = line
    end

    return block
end"]
section_5 -> { header_13}
{rank=same; header_13}

header_13 [label="2 : Parse the prose within a block"]


codeblock_14 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function B.parseProse(block)
    if block[1] then
        if block[1].id == \"codeblock\" then
            return \"\"
        end
    else
        block[1] = Prose(block)
        block.lines = nil
        return block[1]
    end
end"]
section_15 -> { header_17}
{rank=same; header_17}

header_17 [label="3 : toValue"]


codeblock_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function B.toString(block)
    local phrase = \"\"
    for _,v in ipairs(block.lines) do
        phrase = phrase .. v .. \"\\n\"
    end
    return phrase
end

function B.toValue(block)
    block.val = block:toString()
    return block.val
end

function B.toMarkdown(block)
    if block[1] and (block[1].id == \"codeblock\"
      or block[1].id == \"prose\") then
        return block[1]:toMarkdown()
    else
        return block:toString()
    end
end

function B.dotLabel(block)
    return \"block \" .. tostring(block.line_first) 
        .. \"-\" .. tostring(block.line_last)
end"]
section_6 -> { header_20}
{rank=same; header_20}

header_20 [label="2 : Constructor/module"]


codeblock_21 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local b = {}

local function new(Block, lines, linum)
    local block = setmetatable({}, B)
    block.lines = {}
    block.line_first = linum
    if (lines) then 
        if type(lines) == \"string\" then
            block:addLine(lines)
        elseif type(lines) == \"table\" then
            for _, l in ipairs(lines) do
                block:addLine(l)
            end
        else
            freeze(\"Error: in block.new type of `lines` is \" .. type(lines))
        end
    end

    block.id = \"block\"
    return block
end"]
codeblock_22 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function structureOrProse(line)
    if L.match(m.tagline_p, line) then
        return true, \"tagline\"
    elseif L.match(m.listline_p, line) then
        return true, \"listline\"
    elseif L.match(m.tableline_p, line) then
        return true, \"tableline\"
    end
    return false, \"\"
end

b[\"__call\"] = new
b[\"__index\"] = b

return setmetatable({}, b)"]

}
