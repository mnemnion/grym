digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 118"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-48"]


section_1 -> { header_2 prose_3 codeblock_4 prose_5 prose_6 section_7 section_8}
{rank=same; header_2 prose_3 codeblock_4 prose_5 prose_6 section_7 section_8}

header_2 [label="1 : Header metatable"]

prose_3 [label="prose"]

codeblock_4 [label="code block 6-12"]

prose_5 [label="prose"]

prose_6 [label="prose"]

section_7 [label="section: 25-48"]

section_8 [label="section: 49-55"]


prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 A specialized type of Node, used for first-pass ownership and 
 all subsequent operations. 
"]
codeblock_4 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"peg/node\"

local m = require \"grym/morphemes\""]
prose_5 -> { raw_12}
{rank=same; raw_12}

raw_12 [label="raw"]


raw_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 A header contains a header line, that is, one which begins with `WS^0 * '*'^1 * ' '`.
"]
prose_6 -> { raw_14}
{rank=same; raw_14}

raw_14 [label="raw"]


raw_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 In addition to the standard Node fields, a header has:
 
  - `parent()`, a function that returns its parent, which is either a **block** or a **doc**.
  - `dent`, the level of indentation of the header. Must be non-negative. 
  - `level`, the level of ownership (number of tars).
  - `line`, the rest of the line (stripped of lead whitespace and tars)

"]
section_7 -> { header_16 prose_17 codeblock_18}
{rank=same; header_16 prose_17 codeblock_18}

header_16 [label="2 : Metatable for Headers"]

prose_17 [label="prose"]

codeblock_18 [label="code block 27-47"]


prose_17 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_18 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local H = setmetatable({}, { __index = Node })
H.__index = H

H.__tostring = function(header) 
    return \"Lvl \" .. tostring(header.level) .. \" ^: \" 
           .. tostring(header.line)
end

function H.dotLabel(header)
    return tostring(header.level) .. \" : \" .. header.line
end

function H.toMarkdown(header)
    local haxen = \"\"
    if header.level > 0 then
        haxen = (\"#\"):rep(header.level)
    end
    return haxen .. \" \" .. header.line
end"]
section_8 -> { header_22 prose_23 codeblock_24 section_25}
{rank=same; header_22 prose_23 codeblock_24 section_25}

header_22 [label="2 : Constructor/module"]

prose_23 [label="prose"]

codeblock_24 [label="code block 51-53"]

section_25 [label="section: 56-118"]


prose_23 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local h = {}"]
section_25 -> { header_29 prose_30 prose_31 codeblock_32 prose_33 structure_34 structure_35 codeblock_36}
{rank=same; header_29 prose_30 prose_31 codeblock_32 prose_33 structure_34 structure_35 codeblock_36}

header_29 [label="3 : Header:match(str)"]

prose_30 [label="prose"]

prose_31 [label="prose"]

codeblock_32 [label="code block 68-79"]

prose_33 [label="prose"]

structure_34 [label="structure"]

structure_35 [label="structure"]

codeblock_36 [label="code block 93-117"]


prose_30 -> { raw_37}
{rank=same; raw_37}

raw_37 [label="raw"]


raw_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Matches a header line.
"]
prose_31 -> { raw_39}
{rank=same; raw_39}

raw_39 [label="raw"]


raw_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - str :  The string to match against.
 "]
codeblock_32 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function h.match(str) 
    if str ~= \"\" and L.match(m.header, str) then
        local trimmed = str:sub(L.match(m.WS, str))
        local level = L.match(m.tars, trimmed) - 1
        local bareline = trimmed:sub(L.match(m.tars * m.WS, trimmed))
        return true, level, bareline
    else 
        return false, 0, \"\"
    end
end"]
prose_33 -> { raw_42}
{rank=same; raw_42}

raw_42 [label="raw"]


raw_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Creates a Header Node.
"]
structure_34 -> { handleline_44}
{rank=same; handleline_44}

handleline_44 [label="handleline"]


handleline_44 -> { handle_45}
{rank=same; handle_45}

handle_45 [label="handle"]


handle_45 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_35 -> { handleline_47}
{rank=same; handleline_47}

handleline_47 [label="handleline"]


handleline_47 -> { handle_48}
{rank=same; handle_48}

handle_48 [label="handle"]


handle_48 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
codeblock_36 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Header, line, level, first, last, parent)
    local header = setmetatable({}, H)
    header.line = line
    header.level = level
    header.first = first
    header.last = last
    header.parent = function() return parent end
    header.id = \"header\"
    -- for now lets set root to 'false'
    -- nodes classically return root but unclear that I actually use
    header.root = false
    return header
end

function H.howdy() 
    io.write(\"Why hello!\\n\")
end


h.__call = new
h.__index = h

return setmetatable({}, h)"]

}
