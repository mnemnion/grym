digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 118"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-48"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 section_7 section_8}
{rank=same; header_2 block_3 block_4 block_5 block_6 section_7 section_8}

header_2 [label="1 : Header metatable"]

block_3 [label="block 1-5"]

block_4 [label="block 6-14"]

block_5 [label="block 15-16"]

block_6 [label="block 17-48"]

section_7 [label="section: 25-48"]

section_8 [label="section: 49-55"]


block_3 -> { prose_9}
{rank=same; prose_9}

prose_9 [label="prose"]


prose_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 A specialized type of Node, used for first-pass ownership and 
 all subsequent operations. 
"]
block_4 -> { codeblock_11}
{rank=same; codeblock_11}

codeblock_11 [label="code block 6-12"]


codeblock_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"peg/node\"

local m = require \"grym/morphemes\""]
block_5 -> { prose_13}
{rank=same; prose_13}

prose_13 [label="prose"]


prose_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" A header contains a header line, that is, one which begins with `WS^0 * '*'^1 * ' '`.
"]
block_6 -> { prose_15}
{rank=same; prose_15}

prose_15 [label="prose"]


prose_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" In addition to the standard Node fields, a header has:
 
  - `parent()`, a function that returns its parent, which is either a **block** or a **doc**.
  - `dent`, the level of indentation of the header. Must be non-negative. 
  - `level`, the level of ownership (number of tars).
  - `line`, the rest of the line (stripped of lead whitespace and tars)

"]
section_7 -> { header_17 block_18 block_19}
{rank=same; header_17 block_18 block_19}

header_17 [label="2 : Metatable for Headers"]

block_18 [label="block 25-26"]

block_19 [label="block 27-48"]


block_18 -> { prose_20}
{rank=same; prose_20}

prose_20 [label="prose"]


prose_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_19 -> { codeblock_22}
{rank=same; codeblock_22}

codeblock_22 [label="code block 27-47"]


codeblock_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local H = setmetatable({}, { __index = Node })
H.__index = H

H.__tostring = function(header) 
    return \"Lvl \" .. tostring(header.level) .. \" ^: \" 
           .. tostring(header.line)
end

function H.dotLabel(header)
    return tostring(header.level) .. \" : \" .. header.line
end

function H.toMarkdown(header)
    local haxen = \"\"
    if header.level > 0 then
        haxen = (\"#\"):rep(header.level)
    end
    return haxen .. \" \" .. header.line
end"]
section_8 -> { header_24 block_25 block_26 section_27}
{rank=same; header_24 block_25 block_26 section_27}

header_24 [label="2 : Constructor/module"]

block_25 [label="block 49-50"]

block_26 [label="block 51-55"]

section_27 [label="section: 56-118"]


block_25 -> { prose_28}
{rank=same; prose_28}

prose_28 [label="prose"]


prose_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_26 -> { codeblock_30}
{rank=same; codeblock_30}

codeblock_30 [label="code block 51-53"]


codeblock_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local h = {}"]
section_27 -> { header_32 block_33 block_34 block_35 block_36 block_37 block_38 block_39}
{rank=same; header_32 block_33 block_34 block_35 block_36 block_37 block_38 block_39}

header_32 [label="3 : Header:match(str)"]

block_33 [label="block 56-59"]

block_34 [label="block 60-61"]

block_35 [label="block 62-81"]

block_36 [label="block 82-83"]

block_37 [label="block 84-89"]

block_38 [label="block 90-92"]

block_39 [label="block 93-118"]


block_33 -> { prose_40}
{rank=same; prose_40}

prose_40 [label="prose"]


prose_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Matches a header line.
"]
block_34 -> { prose_42}
{rank=same; prose_42}

prose_42 [label="prose"]


prose_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" - str :  The string to match against.
 "]
block_35 -> { codeblock_44}
{rank=same; codeblock_44}

codeblock_44 [label="code block 68-79"]


codeblock_44 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function h.match(str) 
    if str ~= \"\" and L.match(m.header, str) then
        local trimmed = str:sub(L.match(m.WS, str))
        local level = L.match(m.tars, trimmed) - 1
        local bareline = trimmed:sub(L.match(m.tars * m.WS, trimmed))
        return true, level, bareline
    else 
        return false, 0, \"\"
    end
end"]
block_36 -> { prose_46}
{rank=same; prose_46}

prose_46 [label="prose"]


prose_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" Creates a Header Node.
"]
block_37 -> { structure_48 structure_49 structure_50 structure_51 structure_52}
{rank=same; structure_48 structure_49 structure_50 structure_51 structure_52}

structure_48 [label="structure"]

structure_49 [label="structure"]

structure_50 [label="structure"]

structure_51 [label="structure"]

structure_52 [label="structure"]


structure_48 -> { handleline_53}
{rank=same; handleline_53}

handleline_53 [label="handleline"]


handleline_53 -> { handle_54}
{rank=same; handle_54}

handle_54 [label="handle"]


handle_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_49 -> { handleline_56}
{rank=same; handleline_56}

handleline_56 [label="handleline"]


handleline_56 -> { handle_57}
{rank=same; handle_57}

handle_57 [label="handle"]


handle_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_50 -> { handleline_59}
{rank=same; handleline_59}

handleline_59 [label="handleline"]


handleline_59 -> { handle_60}
{rank=same; handle_60}

handle_60 [label="handle"]


handle_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_51 -> { handleline_62}
{rank=same; handleline_62}

handleline_62 [label="handleline"]


handleline_62 -> { handle_63}
{rank=same; handle_63}

handle_63 [label="handle"]


handle_63 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_52 -> { handleline_65}
{rank=same; handleline_65}

handleline_65 [label="handleline"]


handleline_65 -> { handle_66}
{rank=same; handle_66}

handle_66 [label="handle"]


handle_66 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_38 -> { structure_68}
{rank=same; structure_68}

structure_68 [label="structure"]


structure_68 -> { handleline_69}
{rank=same; handleline_69}

handleline_69 [label="handleline"]


handleline_69 -> { handle_70}
{rank=same; handle_70}

handle_70 [label="handle"]


handle_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_39 -> { codeblock_72}
{rank=same; codeblock_72}

codeblock_72 [label="code block 93-117"]


codeblock_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Header, line, level, first, last, parent)
    local header = setmetatable({}, H)
    header.line = line
    header.level = level
    header.first = first
    header.last = last
    header.parent = function() return parent end
    header.id = \"header\"
    -- for now lets set root to 'false'
    -- nodes classically return root but unclear that I actually use
    header.root = false
    return header
end

function H.howdy() 
    io.write(\"Why hello!\\n\")
end


h.__call = new
h.__index = h

return setmetatable({}, h)"]

}
