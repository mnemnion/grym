digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 115"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-49"]


section_1 -> { header_2 prose_3 codeblock_4 prose_5 prose_6 section_7 section_8}
{rank=same; header_2 prose_3 codeblock_4 prose_5 prose_6 section_7 section_8}

header_2 [label="1 : Header metatable"]

prose_3 [label="prose"]

codeblock_4 [label="code block 6-12"]

prose_5 [label="prose"]

prose_6 [label="prose"]

section_7 [label="section: 25-49"]

section_8 [label="section: 50-56"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" * Header metatable"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 A specialized type of Node, used for first-pass ownership and 
 all subsequent operations. 
"]
codeblock_4 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local Node = require \"node/node\"

local m = require \"grym/morphemes\""]
prose_5 -> { raw_13 bold_14 raw_15}
{rank=same; raw_13 bold_14 raw_15}

raw_13 [label="raw"]

bold_14 [label="bold"]

raw_15 [label="raw"]


raw_13 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 A header contains a header line, that is, one which begins with `WS^0 "]
bold_14 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" '"]
raw_15 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="'^1 * ' '`.
"]
prose_6 -> { raw_19 bold_20 raw_21 bold_22 raw_23}
{rank=same; raw_19 bold_20 raw_21 bold_22 raw_23}

raw_19 [label="raw"]

bold_20 [label="bold"]

raw_21 [label="raw"]

bold_22 [label="bold"]

raw_23 [label="raw"]


raw_19 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 In addition to the standard Node fields, a header has:
 
  - `parent()`, a function that returns its parent, which is either a "]
bold_20 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="block"]
raw_21 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" or a "]
bold_22 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="doc"]
raw_23 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
  - `dent`, the level of indentation of the header. Must be non-negative. 
  - `level`, the level of ownership (number of tars).
  - `line`, the rest of the line (stripped of lead whitespace and tars)

"]
section_7 -> { header_29 prose_30 codeblock_31}
{rank=same; header_29 prose_30 codeblock_31}

header_29 [label="2 : Metatable for Headers"]

prose_30 [label="prose"]

codeblock_31 [label="code block 27-48"]


header_29 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  ** Metatable for Headers"]
prose_30 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_31 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local H = setmetatable({}, { __index = Node })
H.id = \"header\"
H.__index = H

H.__tostring = function(header) 
    return \"Lvl \" .. tostring(header.level) .. \" ^: \" 
           .. tostring(header.line)
end

function H.dotLabel(header)
    return tostring(header.level) .. \" : \" .. header.line
end

function H.toMarkdown(header)
    local haxen = \"\"
    if header.level > 0 then
        haxen = (\"#\"):rep(header.level)
    end
    return haxen .. \" \" .. header.line
end"]
section_8 -> { header_36 prose_37 codeblock_38 section_39}
{rank=same; header_36 prose_37 codeblock_38 section_39}

header_36 [label="2 : Constructor/module"]

prose_37 [label="prose"]

codeblock_38 [label="code block 52-54"]

section_39 [label="section: 57-115"]


header_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="  ** Constructor/module"]
prose_37 -> { raw_41}
{rank=same; raw_41}

raw_41 [label="raw"]


raw_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_38 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local h = {}"]
section_39 -> { header_44 prose_45 prose_46 codeblock_47 prose_48 structure_49 structure_50 codeblock_51}
{rank=same; header_44 prose_45 prose_46 codeblock_47 prose_48 structure_49 structure_50 codeblock_51}

header_44 [label="3 : Header:match(str)"]

prose_45 [label="prose"]

prose_46 [label="prose"]

codeblock_47 [label="code block 69-80"]

prose_48 [label="prose"]

structure_49 [label="structure"]

structure_50 [label="structure"]

codeblock_51 [label="code block 94-114"]


header_44 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="    *** Header:match(str)"]
prose_45 -> { raw_53}
{rank=same; raw_53}

raw_53 [label="raw"]


raw_53 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Matches a header line.
"]
prose_46 -> { raw_55}
{rank=same; raw_55}

raw_55 [label="raw"]


raw_55 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 - str :  The string to match against.
 "]
codeblock_47 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function h.match(str) 
    if str ~= \"\" and L.match(m.header, str) then
        local trimmed = str:sub(L.match(m.WS, str))
        local level = L.match(m.tars, trimmed) - 1
        local bareline = trimmed:sub(L.match(m.tars * m.WS, trimmed))
        return true, level, bareline
    else 
        return false, 0, \"\"
    end
end"]
prose_48 -> { raw_58}
{rank=same; raw_58}

raw_58 [label="raw"]


raw_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
 Creates a Header Node.
"]
structure_49 -> { handleline_60}
{rank=same; handleline_60}

handleline_60 [label="handleline"]


handleline_60 -> { handle_61}
{rank=same; handle_61}

handle_61 [label="handle"]


handle_61 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
structure_50 -> { handleline_63}
{rank=same; handleline_63}

handleline_63 [label="handleline"]


handleline_63 -> { handle_64}
{rank=same; handle_64}

handle_64 [label="handle"]


handle_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
codeblock_51 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Header, line, level, first, last, str)
    local header = setmetatable({}, H)
    header.line = line
    header.level = level
    header.first = first
    header.last = last
    header.str = str
    return header
end

function H.howdy() 
    io.write(\"Why hello!\\n\")
end


h.__call = new
h.__index = h

return setmetatable({}, h)"]

}
