digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 148"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-55"]


section_1 -> { header_2 block_3 block_4 block_5 block_6 block_7 section_8}
{rank=same; header_2 block_3 block_4 block_5 block_6 block_7 section_8}

header_2 [label="1 : Weave"]

block_3 [label="block 1-5"]

block_4 [label="block 6-7"]

block_5 [label="block 8-10"]

block_6 [label="block 11-48"]

block_7 [label="block 49-55"]

section_8 [label="section: 56-148"]


block_3 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Our weaver is currently somewhat narrowly focused on markdown.
"]
block_4 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="This will change in time.
"]
block_5 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Now to activate dot!

"]
block_6 -> { codeblock_12}
{rank=same; codeblock_12}

codeblock_12 [label="code block 11-47"]


codeblock_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local pl_file = require \"pl.file\"
local pl_dir = require \"pl.dir\"
local pl_path = require \"pl.path\"
local getfiles = pl_dir.getfiles
local makepath = pl_dir.makepath
local getdirectories = pl_dir.getdirectories
local extension = pl_path.extension
local dirname = pl_path.dirname
local basename = pl_path.basename
local read = pl_file.read
local write = pl_file.write
local isdir = pl_path.isdir

local u = require \"lib/util\"
local a = require \"lib/ansi\"


local s = require \"lib/status\"

local Node = require \"peg/node\"

local m = require \"grym/morphemes\"
local walk = require \"walk\"
local strHas = walk.strHas
local endsWith = walk.endsWith
local subLastFor = walk.subLastFor
local writeOnChange = walk.writeOnChange

local epeg = require \"peg/epeg\"

local Doc = require \"grym/doc\"

local W, w = u.inherit(Node)"]
block_6 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_7 -> { codeblock_15}
{rank=same; codeblock_15}

codeblock_15 [label="code block 49-53"]


codeblock_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function W.weaveMd(weaver, doc)
  return doc:toMarkdown()
end"]
block_7 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_8 -> { header_18 block_19 block_20 block_21 block_22 block_23}
{rank=same; header_18 block_19 block_20 block_21 block_22 block_23}

header_18 [label="3 : .dot to .svg"]

block_19 [label="block 56-60"]

block_20 [label="block 61-77"]

block_21 [label="block 78-136"]

block_22 [label="block 137-145"]

block_23 [label="block 146-148"]


block_19 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  The sh-lib monkeypatches the global metatable, and all we want is one
command, so we do something odd here:
"]
block_20 -> { codeblock_25}
{rank=same; codeblock_25}

codeblock_25 [label="code block 61-75"]


codeblock_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local dot_sh = (require \"sh\"):clear_G().command('dot', '-Tsvg')

local function dotToSvg(dotted, out_file)
    local run_dot = dot_sh({__input = dotted})
    if run_dot.__exitcode == 0 then
        return tostring(run_dot)
    else 
        s:complain(a.red(\"Dot returned \") 
                    .. tostring(run_dot.__exitcode)
                    .. a.red(\" for \" .. out_file ))
        return \"\"
    end
end"]
block_20 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_21 -> { codeblock_28}
{rank=same; codeblock_28}

codeblock_28 [label="code block 78-134"]


codeblock_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function weave_dir(weaver, pwd, depth)
    local depth = depth + 1
    for dir in pl_dir.walk(pwd, false, false) do
        if not strHas(\".git\", dir) and isdir(dir)
            and not strHas(\"src/lib\", dir) then

            local files = getfiles(dir)
            s:chat((\"  \"):rep(depth) .. \"* \" .. dir)
            local subdirs = getdirectories(dir)
            for _, f in ipairs(files) do
                if extension(f) == \".orb\" then
                    -- Weave and prepare out directory
                    local orb_f = read(f)
                    local doc = Doc(orb_f)
                    local doc_md_dir = subLastFor(\"/orb\", \"/doc/md\", dirname(f))
                    local doc_dot_dir = subLastFor(\"/orb\", \"/doc/dot\", dirname(f))
                    local doc_svg_dir = subLastFor(\"/orb\", \"/doc/svg\", dirname(f))
                    makepath(doc_md_dir)
                    makepath(doc_dot_dir)
                    makepath(doc_svg_dir)
                    local bare_name = basename(f):sub(1, -5) --  == #\".orb\"
                    local out_md_name = doc_md_dir .. \"/\" .. bare_name .. \".md\"
                    local out_dot_name = doc_dot_dir .. \"/\" .. bare_name .. \".dot\"
                    local out_svg_name = doc_svg_dir .. \"/\" .. bare_name .. \".svg\"
                    local woven_md = weaver:weaveMd(doc) or \"\"
                    local woven_dot = doc:dot() or \"\"
                    local woven_svg = dotToSvg(woven_dot, out_dot_name)
                    -- Compare, report, and write out if necessary
                    local last_md = read(out_md_name) or \"\"
                    local last_dot = read(out_dot_name) or \"\"
                    local last_svg = read(out_svg_name) or \"\"
                    writeOnChange(woven_md, last_md, out_md_name, depth)
                    writeOnChange(woven_dot, last_dot, out_dot_name, depth)
                    writeOnChange(woven_svg, last_svg, out_svg_name, depth)
                end
            end
        end
    end

    return true
end

local function weave_all(weaver, pwd)
    for dir in pl_dir.walk(pwd, false, false) do
        if not strHas(\".git\", dir) and isdir(dir) 
            and endsWith(\"orb\", dir) then
            s:chat(a.green(\"Weave: \" .. dir))
            return weave_dir(weaver, dir, 0)
        end
    end

    return false
end

W.weave_all = weave_all"]
block_21 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
block_22 -> { codeblock_31}
{rank=same; codeblock_31}

codeblock_31 [label="code block 137-144"]


codeblock_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(Weaver, doc)
    local weaver = setmetatable({}, W)


    return weaver
end"]
block_22 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
block_23 -> { codeblock_34}
{rank=same; codeblock_34}

codeblock_34 [label="code block 146-148"]


codeblock_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return W"]
block_23 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]

}
