* Codex

A Codex is currently a directory in our Orb-style format.

We're trying to work our way into a proper database.


** Instance Fields

- docs :  Array keyed by full path name of file, and the spun-up Doc as
          the value.

- serve :  A [[Watcher][link in bio]] for file changes.  Only present when
           initialized with =orb serve=.



#!lua
local s = require "core/status" ()
s.verbose = true


local Dir  = require "walk/directory"
local File = require "walk/file"
local Path = require "walk/path"
local Deck = require "walk/deck"

local knitter = require "knit/knitter"

local Watcher = require "femto/watcher"
#/lua


#!lua
local Codex = {}
Codex.__index = Codex
local __Codices = {} -- One codex per directory
#/lua


** spin

The spin step is passed through to the Orb deck.

This needs to generalize on a per-file basis.

Currently spinning just loads files into the Deck(s).

#!lua
function Codex.spin(codex)
   codex.orb:spin()
end
#/lua

** serve

#!lua
local function changer(codex)
   local function onchange(watcher, fname)
      local full_name = tostring(codex.orb) .. "/" .. fname
      print ("changed " .. full_name)
      if codex.docs[full_name] then
         print("true")
         -- read the file (stubbed)
         local doc = codex.files[full_name]:read()

         print(doc)
      else
         print("false")
      end
   end

   return onchange
end


local function renamer(codex)
   local function onrename(watcher, fname)
      print ("renamed " .. fname)
   end

   return onrename
end

function Codex.serve(codex)
   codex.server = Watcher { onchange = changer(codex),
                            onrename = renamer(codex) }
   codex.server(tostring(codex.orb))
end
#/lua




*** isACodex

  Used in our constructor to determine to what degree the local
directory fits the Codex format.  If it meets all the [[critera][httk://]]
then =codex.codex= is set to =true=.

Any partial matches are added to the Codex as they are found.

#!lua
local function isACodex(dir, codex)
   local isCo = false
   local orbDir, srcDir, libDir, srcLibDir = nil, nil, nil, nil
   codex.root = dir
   dir:getsubdirs()
   for i, sub in ipairs(dir.subdirs) do
      local name = sub:basename()
      if name == "orb" then
         s:verb("orb: " .. tostring(sub))
         orbDir = sub
         codex.orb = sub
      elseif name == "src" then
         s:verb("src: " .. tostring(sub))
         srcDir = Dir(sub)
         codex.src = sub
         srcDir:getsubdirs()
         for j, subsub in ipairs(sub.subdirs) do
            local subname = subsub:basename()
            if subname == "lib" then
               s:verb("src/lib: " .. tostring(subsub))
               srcLibDir = subsub
            end
         end
          --]]
      elseif name == "lib" then
         s:verb("lib: " .. tostring(sub))
         libDir = sub
         codex.lib = sub
      end
   end
   if orbDir and srcDir and libDir and srcLibDir then
      -- check equality of /lib and /src/lib
      codex.codex = true
   end
   return codex
end
#/lua

#!lua
local function new(dir)
   if type(dir) == "string" then
      dir = Dir(dir)
   end
   if __Codices[dir] then
      return __Codices[dir]
   end
   local codex = setmetatable({}, Codex)
   codex = isACodex(dir, codex)
   if codex.orb then
      codex.orb = Deck(codex, codex.orb)
   end
   codex.docs  = {}
   codex.files = {}
   codex.srcs  = {}
   return codex
end
#/lua


#!lua
Codex.idEst = new
return new
#/lua
